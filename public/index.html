<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>NBA Teammate Game</title>
  <script src="https://cdn.socket.io/4.6.1/socket.io.min.js" crossorigin="anonymous"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

 <style>
  body {
    font-family: Arial, sans-serif;
    max-width: 600px;
    margin: auto;
    padding: 1rem;
    line-height: 1.5;
    background-color: #f9f9f9;
    color: #222;
  }

  h1, h2, h3 {
    text-align: center;
    margin-bottom: 1rem;
  }

  input[type="text"] {
    width: 100%;
    padding: 0.5rem;
    font-size: 1rem;
    margin-top: 0.25rem;
    box-sizing: border-box;
  }

  button {
    padding: 0.5rem 1rem;
    font-size: 1rem;
    margin-top: 0.5rem;
    cursor: pointer;
  }

  #status {
    text-align: center;
    margin-top: 1rem;
    font-style: italic;
    color: #555;
  }

  #waitingRoom {
    text-align: center;
    margin-top: 2rem;
  }

  #displayRoomCode {
    font-size: 1.5rem;
    font-weight: bold;
    display: inline-block;
    margin-top: 0.5rem;
  }

  #gameArea {
    margin-top: 2rem;
    position: relative;
  }

  #turnSection {
    margin-bottom: 1.5rem;
  }

  #timer {
    font-size: 2rem;
    font-weight: bold;
    text-align: center;
    color: #333;
    margin: 1rem 0;
  }

  #guessControls {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
  }

  #guessControls input {
    flex: 1;
  }

 #autocomplete-list {
  position: absolute;
  top: 100%; /* ensures it appears right below the input */
  left: 0;
  right: 0;
  z-index: 99;
  background-color: white;
  border: 1px solid #ccc;
  max-height: 200px;
  overflow-y: auto;
}

.autocomplete-item {
  display: flex;
  justify-content: space-between;
  padding: 6px 10px;
  cursor: pointer;
}

.autocomplete-item:hover {
  background-color: #f0f0f0;
}

.career-years {
  font-size: 0.8em;
  color: gray;
}


  #autocomplete-list div {
    padding: 0.5rem;
    cursor: pointer;
  }

  #autocomplete-list div:hover {
    background: #f0f0f0;
  }

  #successful-guesses-container {
    margin-top: 1rem;
    text-align: center;
  }

  #successful-guesses-list {
    list-style: none;
    padding-left: 0;
    margin-top: 0.5rem;
    text-align: center;
  }

  #successful-guesses-list li {
    margin: 0.5rem 0;
  }

  .hidden {
    display: none !important;
  }

  /* Unified message styling */
  .message {
    margin-top: 0.5rem;
    font-size: 1rem;
    text-align: center;
    color: #333;
    transition: opacity 1s ease;
    opacity: 1;
  }

  .message.error {
    color: red;
    font-weight: bold;
  }

  .message.fade-out {
    opacity: 0;
  }

  #gameOverContainer {
    display: none;
    text-align: center;
    margin-top: 2rem;
  }

  #rematchBtn {
  display: block; /* ← Change this from "none" or "inline-block" to block */
  margin: 1.5rem auto 0; /* auto left/right centers it */
  padding: 0.5rem 1.5rem;
  font-weight: bold;
  border: none;
  border-radius: 4px;
  background-color: #007bff;
  color: white;
  transition: background-color 0.3s ease;
}


  #rematchBtn:hover {
    background-color: #0056b3;
  }

  @media (max-width: 480px) {
    #guessControls {
      flex-direction: column;
    }

    #autocomplete-list {
      width: 100%;
    }
  }
</style>


</head>
<body>
  <h1>NBA Teammate Game</h1>
  <div id="setupSection">
  <div>
    <label>Username: <input type="text" id="usernameInput" /></label>
  </div>

<input type="text" id="usernameInput" placeholder="Enter username" />
<button id="findGameBtn">Find Game</button>


  <div>
    <label>Room ID: <input type="text" id="roomIdInput" value="room1" /></label>
    <button id="joinBtn">Join Game</button>
  </div>
</div>


  <div id="status"></div>

  <div id="waitingRoom" style="display: none; text-align: center; margin-top: 2rem;">
    <h2>Waiting Room</h2>
    <p>Waiting for another player to join...</p>
    <p>Share this Room ID with your opponent.</p>
    <code id="displayRoomCode" style="font-size: 1.5rem; font-weight: bold;"></code>
  </div>

<div id="gameArea" style="display:none; position: relative;">
  <div id="turnSection">
    <p>Name any teammate of: <strong id="currentPlayerName"></strong></p>
    <p>Time left: <span id="timer">15</span> seconds</p>

    <!-- ✅ Apply position: relative here -->
    <div id="guessControls" style="position: relative;">
      <input
        type="text"
        id="guessInput"
        placeholder="Type a teammate's name..."
        autocomplete="off"
      />
      <button id="submitGuessBtn" disabled>Submit Guess</button>

      <!-- ✅ Move this inside guessControls -->
      <div id="autocomplete-list"></div>
    </div>
  </div>

  <div id="messageContainer"></div>
  <div id="gameOverContainer"></div>

  <button id="rematchBtn" style="display: none;">Request Rematch</button>

  <div id="successful-guesses-container" style="margin-top: 2px;">
    <h3>Turn History</h3>
    <ul id="successful-guesses-list"></ul>
  </div>
</div>



<script>
  document.addEventListener('DOMContentLoaded', () => {
const socket = io(); // connects to the same origin automatically

  let roomId = null;
  let selectedPlayer = null;
  let fetchTimeout = null;
  let gameStarted = false;
  let gameOver = false;
  let leadoffPlayerName = null;


  const statusDiv = document.getElementById('status');
  const joinBtn = document.getElementById('joinBtn');
  const findGameBtn = document.getElementById('findGameBtn');
  const roomIdInput = document.getElementById('roomIdInput');

  const waitingRoom = document.getElementById('waitingRoom');
  const gameArea = document.getElementById('gameArea');
  const currentPlayerNameEl = document.getElementById('currentPlayerName');
  const timerEl = document.getElementById('timer');
  const guessInput = document.getElementById('guessInput');
  const submitGuessBtn = document.getElementById('submitGuessBtn');
  const messagesEl = document.getElementById('messageContainer');
  const autocompleteList = document.getElementById('autocomplete-list');
  const rematchBtn = document.getElementById('rematchBtn');
  const successfulGuesses = [];

  joinBtn.onclick = () => {
    const username = document.getElementById('usernameInput').value.trim();
    roomId = roomIdInput.value.trim();

    if (!username) {
      alert('Enter a username');
      return;
    }

    if (!roomId) {
      alert('Enter a room ID');
      return;
    }

    socket.emit('joinGame', { roomId, username });
    statusDiv.textContent = `Joined room: ${roomId}`;
    document.getElementById('displayRoomCode').textContent = roomId;
    waitingRoom.style.display = 'block';
    gameArea.style.display = 'none';
  };

  findGameBtn.onclick = () => {
  const username = document.getElementById('usernameInput').value.trim();

  if (!username) {
    alert('Enter a username');
    return;
  }

  socket.emit('findGame', username);
  statusDiv.textContent = `Looking for a game...`;
};


  // 1. Connection & Room Setup
socket.on('connect', () => {
  // Connected
});

socket.on('playersUpdate', (count) => {
  statusDiv.textContent = `Players in room: ${count}`;

  if (count < 2) {
    waitingRoom.style.display = 'block';
    gameArea.style.display = 'none';
    rematchBtn.style.display = 'none';  // Hide rematch if waiting
  } else {
    waitingRoom.style.display = 'none';
    gameArea.style.display = 'block';
  }
});

socket.on('matchFound', ({ roomId: matchedRoomId, username }) => {
  console.log('[CLIENT] Match found in room:', matchedRoomId);

  roomId = matchedRoomId;

  socket.emit('joinGame', { roomId, username });

  statusDiv.textContent = `Match found! Joined room: ${roomId}`;
  document.getElementById('displayRoomCode').textContent = roomId;
  waitingRoom.style.display = 'block';
  gameArea.style.display = 'none';
});


// 2. Game Lifecycle
socket.on('gameStarted', (data) => {
  console.log('[CLIENT] Received gameStarted event:', data);

  gameStarted = true;
  gameOver = false;

  leadoffPlayerName = data.leadoffPlayer || null;

  // Clear old timers
  if (window.timerInterval) {
    clearInterval(window.timerInterval);
    window.timerInterval = null;
  }

  // Reset guess input and controls
  guessInput.disabled = true;
  submitGuessBtn.disabled = true;
  guessInput.value = '';
  clearGuessError();
  clearAutocomplete();

  // Reset rematch button
  rematchBtn.style.display = 'none';
  rematchBtn.disabled = false;
  rematchBtn.textContent = 'Rematch';

  // Hide join UI
  joinBtn.classList.add('hidden');
  roomIdInput.disabled = true;
  document.getElementById("setupSection")?.classList.add("hidden");
  document.getElementById("usernameInput")?.classList.add("hidden");
  document.getElementById("roomIdInput")?.classList.add("hidden");

  // Clear any messages
  messagesEl.innerHTML = '';
  messagesEl.style.display = 'block';

  // Reset game history
  successfulGuesses.length = 0;
  renderSuccessfulGuesses();

  // Set new player and timer
  currentPlayerNameEl.textContent = data.currentPlayerName;
  timerEl.textContent = data.timeLeft;

  // Show gameplay area again
  gameArea.style.display = 'block';
  document.getElementById('turnSection').style.display = 'block';

  // Hide the gameOver UI
  const gameOverContainer = document.getElementById('gameOverContainer');
  gameOverContainer.innerHTML = '';
  gameOverContainer.style.display = 'none';
});


socket.on('gameOver', (data) => {
  console.log('gameOver received:', data);
  gameOver = true;

  // Disable inputs
  guessInput.disabled = true;
  submitGuessBtn.disabled = true;

  if (window.timerInterval) {
    clearInterval(window.timerInterval);
    window.timerInterval = null;
  }

  // Hide gameplay UI
  document.getElementById('turnSection').style.display = 'none';
  messagesEl.style.display = 'none';

  // Show Game Over Message
  const container = document.getElementById('gameOverContainer');
  container.innerHTML = '';
  container.style.display = 'flex';
container.style.justifyContent = 'center';
container.style.alignItems = 'center';


  const gameOverMsg = document.createElement('div');
  gameOverMsg.textContent = data.message || 'Game Over!';
  gameOverMsg.style.fontSize = '1.5rem';
  gameOverMsg.style.textAlign = 'center';
  gameOverMsg.style.fontWeight = 'bold';
  gameOverMsg.style.marginTop = '1rem';

  if (data.role === 'winner') {
    gameOverMsg.style.color = 'green';
  } else if (data.role === 'loser') {
    gameOverMsg.style.color = 'darkred';
  } else {
    gameOverMsg.style.color = 'gray';
  }

  container.appendChild(gameOverMsg);

  // Show Rematch Button
  rematchBtn.style.display = 'block';
  rematchBtn.disabled = false;
  rematchBtn.textContent = 'Rematch';
});

// 3. Turn Management
socket.on('yourTurn', (data) => {
  // Show input & button
  document.getElementById('guessControls').style.display = 'block';

  // Enable input & button
  guessInput.disabled = false;
  submitGuessBtn.disabled = false;

  // Update UI
  currentPlayerNameEl.textContent = data.currentPlayerName || 'Your Turn';
  timerEl.textContent = data.timeLeft || 15;
  document.getElementById('turnSection').style.display = 'block';
  messagesEl.style.display = 'block';

  showMessage(data.message || "It's your turn to guess!", 'info');
});

socket.on('opponentTurn', (data) => {
  // Hide input & button
  document.getElementById('guessControls').style.display = 'none';

  // Disable input & button just in case
  guessInput.disabled = true;
  submitGuessBtn.disabled = true;

  // Update UI
  currentPlayerNameEl.textContent = data.currentPlayerName || "Opponent's Turn";
  timerEl.textContent = '';
  document.getElementById('turnSection').style.display = 'block';
  messagesEl.style.display = 'block';

  showMessage(data.message || "Waiting for your opponent to guess...", 'info');
});

socket.on('message', (msg) => {
  // Pass type 'error' or 'info' depending on your app logic; default to 'error' for now
  showMessage(msg, 'error');
});


socket.on('turnEnded', (data) => {
  if (data.successfulGuess) {
    const match = data.successfulGuess.match(/"([^"]+)"/);
    const playerName = match ? match[1] : data.successfulGuess;
    successfulGuesses.push(playerName);
    renderSuccessfulGuesses();
  }

  if (data.message) {
    showMessage(data.message, data.message.startsWith('Incorrect guess') ? 'error' : 'info');
  }

  updateTurn(data);
});

socket.on('timerTick', (data) => {
  timerEl.textContent = data.timeLeft;
});


  // Autocomplete logic
guessInput.addEventListener('input', function() {
  const val = this.value.trim();
  clearAutocomplete();
  selectedPlayer = null;
  submitGuessBtn.disabled = true;

  if (!val) {
    showAutocompleteSuggestions([]);
    return;
  }

  if (fetchTimeout) clearTimeout(fetchTimeout);

  fetchTimeout = setTimeout(async () => {
    try {
      const res = await fetch(`/players?q=${encodeURIComponent(val)}`);
      if (!res.ok) throw new Error('Network response not ok');

      const results = await res.json();
      if (results.length === 0) {
        showAutocompleteSuggestions([]);
        return;
      }

      // ✅ Create an array of actual HTML elements to pass to showAutocompleteSuggestions
      const suggestions = results.map(player => {
        const wrapper = document.createElement('div');
        wrapper.className = 'autocomplete-item';

        const nameSpan = document.createElement('span');
        nameSpan.textContent = player.player_name;

        const yearsSpan = document.createElement('span');
        yearsSpan.className = 'career-years';
        yearsSpan.textContent = ` ${player.first_year || '?'}–${player.last_year || '?'}`;

        yearsSpan.style.fontSize = '0.8em';
        yearsSpan.style.color = 'gray';
        yearsSpan.style.marginLeft = '5px';

        wrapper.appendChild(nameSpan);
        wrapper.appendChild(yearsSpan);

        wrapper.addEventListener('click', () => {
        guessInput.value = player.player_name;
        selectedPlayer = player.player_name;
        submitGuessBtn.disabled = false;
        clearAutocomplete();
      });

        return wrapper;
      });

      showAutocompleteSuggestions(suggestions);

    } catch (err) {
      console.error('Autocomplete fetch error:', err);
      showAutocompleteSuggestions([]);
    }
  }, 300);
});





  guessInput.addEventListener('change', () => {
    if (guessInput.value !== selectedPlayer) {
      selectedPlayer = null;
      submitGuessBtn.disabled = true;
    }
  });

  submitGuessBtn.onclick = () => {
    const guess = guessInput.value.trim();
    clearGuessError();

    if (!guess) {
      showGuessError('Enter a guess');
      return;
    }
    if (guess !== selectedPlayer) {
      showGuessError('Please select a player from the dropdown list.');
      return;
    }

    socket.emit('playerGuess', { roomId, guess });
    guessInput.value = '';
    selectedPlayer = null;
    submitGuessBtn.disabled = true;
    clearAutocomplete();
  };


rematchBtn.onclick = () => {
  if (!roomId) {
    console.error('[CLIENT] No roomId found on rematch!');
    return;
  }

  console.log('[CLIENT] Sending rematch request with roomId:', roomId);
  socket.emit('requestRematch', { roomId });

  rematchBtn.disabled = true;
  rematchBtn.textContent = 'Waiting for opponent...';
  rematchBtn.style.backgroundColor = '';  // Remove any highlight if present
};

// When another player requests a rematch
socket.on('rematchRequested', ({ username }) => {
  showMessage(`${username} wants a rematch! Click your Rematch button to accept.`, 'info', true);

 
});



// When rematch actually starts
socket.on('rematchStarted', () => {
  resetGameUI();

  // Clear any rematch prompt message
  const rematchInfo = document.getElementById('rematch-info');
  if (rematchInfo) rematchInfo.remove();

  // Reset rematch button styles
  rematchBtn.disabled = false;
  rematchBtn.style.backgroundColor = ''; // Reset highlight
});



function resetGameUI() {
  gameStarted = true;
  gameOver = false;

  // Clear old timers
  if (window.timerInterval) {
    clearInterval(window.timerInterval);
    window.timerInterval = null;
  }

  guessInput.disabled = true;
  submitGuessBtn.disabled = true;
  guessInput.value = '';
  clearGuessError();
  clearAutocomplete();

  // Reset rematch button visibility and style
  rematchBtn.style.display = 'none';  // Or 'inline-block' if you want it visible immediately
  rematchBtn.disabled = false;
  rematchBtn.textContent = 'Rematch';
  rematchBtn.style.backgroundColor = ''; // Clear any highlight

  // Reset UI parts
  messagesEl.innerHTML = '';
  messagesEl.style.display = 'block';

  successfulGuesses.length = 0;
  renderSuccessfulGuesses();

  currentPlayerNameEl.textContent = '';
  timerEl.textContent = '';

  // Show/hide game areas as needed
  waitingRoom.style.display = 'none';
  gameArea.style.display = 'block';
  document.getElementById('turnSection').style.display = 'block';

  // Hide game over container
  const gameOverContainer = document.getElementById('gameOverContainer');
  gameOverContainer.innerHTML = '';
  gameOverContainer.style.display = 'none';

  // Clear persistent rematch message
  const messageContainer = document.getElementById('messageContainer');
  if (messageContainer) {
    messageContainer.innerHTML = '';
  }
}







 function clearGuessError() {
  const container = document.getElementById('messageContainer');
  container.innerHTML = '';
}

function showMessage(message, type = 'info', persist = false) {
  const container = document.getElementById('messageContainer');
  container.innerHTML = '';

  const div = document.createElement('div');
  div.textContent = message;
  div.classList.add('message');

  if (type === 'error') div.classList.add('error');

  container.appendChild(div);

  if (!persist) {
    setTimeout(() => {
      div.classList.add('fade-out');
      setTimeout(() => container.innerHTML = '', 1000);
    }, 3000);
  }
}






  function updateTurn(data) {
    currentPlayerNameEl.textContent = data.currentPlayerName || '???';
    timerEl.textContent = data.timeLeft || 15;
  }



 function clearAutocomplete() {
  autocompleteList.innerHTML = '';
  autocompleteList.style.display = 'none';
}


function showAutocompleteSuggestions(suggestions) {
  const list = document.getElementById('autocomplete-list');
  list.innerHTML = '';

  if (suggestions.length === 0) {
    list.style.display = 'none';  // Hide when empty
    return;
  }

  list.style.display = 'block'; // Show when populated

  suggestions.forEach(suggestionEl => {
    // suggestionEl is an element, append it directly
    list.appendChild(suggestionEl);
  });
}





  function renderSuccessfulGuesses() {
  const listEl = document.getElementById('successful-guesses-list');
  listEl.innerHTML = '';

  // Don't reverse this — just prepend the leadoff player
  const displayList = leadoffPlayerName
    ? [leadoffPlayerName, ...successfulGuesses]
    : [...successfulGuesses];

  displayList.forEach((guess, index) => {
    const li = document.createElement('li');
    li.style.margin = '0.5rem 0';
    li.style.fontWeight = (index === displayList.length - 1) ? 'bold' : 'normal';
    li.style.color = (index === 0 && leadoffPlayerName) ? '#007bff' : '#000'; // blue for leadoff
    li.textContent = guess;
    listEl.appendChild(li);

    if (index < displayList.length - 1) {
      const arrow = document.createElement('div');
      arrow.style.textAlign = 'center';
      arrow.style.fontSize = '1.2rem';
      arrow.style.color = '#888';
      arrow.textContent = '↓';
      listEl.appendChild(arrow);
    }
  });
}





  });
</script>
</body>
</html>