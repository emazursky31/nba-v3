<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>NBA Teammate Game</title>
  <script src="https://cdn.socket.io/4.6.1/socket.io.min.js" crossorigin="anonymous"></script>
  <script type="module">
  import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm'

  const SUPABASE_URL = 'https://rbjdlzgptvpfsnkakasj.supabase.co'
  const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJiamRsemdwdHZwZnNua2FrYXNqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg5ODYxMzksImV4cCI6MjA2NDU2MjEzOX0.U0EhIpOaKrHQmAJHcCBVJLKDGEW-m91eNj2bWRejYpk'
  const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY)

  window.supabase = supabase // Expose for later use
</script>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

 <style>
/* Revert to original site-wide styling */
  body {
    font-family: Arial, sans-serif;
    max-width: 600px;
    margin: auto;
    padding: 1rem;
    line-height: 1.5;
    background-color: #f9f9f9;
    color: #222;
  }

  h1, h2, h3 {
    text-align: center;
    margin-bottom: 1rem;
  }

  input[type="text"] {
    width: 100%;
    padding: 0.5rem;
    font-size: 1rem;
    margin-top: 0.25rem;
    box-sizing: border-box;
  }

  button {
    padding: 0.5rem 1rem;
    font-size: 1rem;
    margin-top: 0.5rem;
    cursor: pointer;
  }

  #status {
    text-align: center;
    margin-top: 1rem;
    font-style: italic;
    color: #555;
  }

  #waitingRoom {
    text-align: center;
    margin-top: 2rem;
  }

  #displayRoomCode {
    font-size: 1.5rem;
    font-weight: bold;
    display: inline-block;
    margin-top: 0.5rem;
  }

  #gameArea {
    margin-top: 2rem;
    position: relative;
  }

  @keyframes pulse-border {
  0% {
    box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.5);
  }
  70% {
    box-shadow: 0 0 0 10px rgba(40, 167, 69, 0);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(40, 167, 69, 0);
  }
}

  #turnSection {
    margin-bottom: 1.5rem;
  }

  #turnSection.your-turn {
  border: 3px solid #28a745;
  background-color: #e8f5e9;
  padding: 1rem;
  border-radius: 8px;
  box-shadow: 0 0 12px rgba(40, 167, 69, 0.3);
  transition: all 0.3s ease;
  animation: pulse-border 1.5s infinite;
}

#turnSection.opponent-turn {
  opacity: 0.6;
}


  #timer {
    font-size: 2rem;
    font-weight: bold;
    text-align: center;
    color: #333;
    margin: 1rem 0;
  }

  #guessControls {
  display: flex;
  gap: 0.75rem; /* a bit more gap */
  margin-bottom: 1rem;
  align-items: center; /* vertical center */
  justify-content: center; /* center horizontally */
}

 #guessControls input {
  flex: 1 1 auto;
  min-width: 0; /* helps prevent overflow */
  padding: 0.75rem 1rem; /* more padding for easier touch */
  font-size: 1.1rem;
  border-radius: 4px;
  border: 1px solid #ccc;
  box-sizing: border-box;
}

#submitGuessBtn {
  padding: 0.85rem 1.75rem;
  font-size: 1.1rem;
  min-width: 130px;
  min-height: 56px; /* ‚Üê Ensures at least 56px tall */
  border-radius: 6px;
  cursor: pointer;
  background-color: #007bff;
  color: white;
  border: none;
  transition: background-color 0.25s ease;
}

#submitGuessBtn:disabled {
  background-color: #aaa;
  cursor: not-allowed;
}

#submitGuessBtn:hover:not(:disabled) {
  background-color: #0056b3;
}

#autocomplete-list {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  z-index: 9999;
  background-color: white;
  border: 1px solid #ccc;
  max-height: 200px;
  overflow-y: auto;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
}

.autocomplete-item {
  display: flex;
  justify-content: space-between;
  padding: 6px 10px;
  cursor: pointer;
}

.autocomplete-item:hover {
  background-color: #f0f0f0;
}

.career-years {
  font-size: 0.8em;
  color: gray;
}



  #autocomplete-list div {
    padding: 0.5rem;
    cursor: pointer;
  }

  #autocomplete-list div:hover {
    background: #f0f0f0;
  }

  #successful-guesses-container {
    margin-top: 1rem;
    text-align: center;
  }

  #successful-guesses-list {
    list-style: none;
    padding-left: 0;
    margin-top: 0.5rem;
    text-align: center;
  }

  #successful-guesses-list li {
    margin: 0.5rem 0;
  }

  .hidden {
    display: none !important;
  }

  /* Unified message styling */
  .message {
    margin-top: 0.5rem;
    font-size: 1rem;
    text-align: center;
    color: #333;
    transition: opacity 1s ease;
    opacity: 1;
  }

  .message.error {
    color: red;
    font-weight: bold;
  }

  .message.fade-out {
    opacity: 0;
  }

 .turn-prompt {
  font-size: 1.3rem;
  color: #222;
  margin-bottom: 1rem;
  text-align: center;
  line-height: 1.6;
}

.turn-prompt .turn-player-name {
  display: block;
  font-size: 1.6rem;
  margin-top: 0.5rem;
  color: #007bff;
}

#playersDisplay {
  text-align: center;
  margin-top: 1rem;
  font-size: 1.3rem;
  font-weight: bold;
  color: #222;
}

.player-name {
  padding: 0 0.5rem;
}

.player-name.you {
  color: #28a745; /* green */
}

.player-name.opponent {
  color: #007bff; /* blue */
}

.vs-separator {
  color: #555;
  padding: 0 0.5rem;
}

#welcome-message {
  font-size: 1.5rem;
  margin-bottom: 1rem;
  text-align: center;
  color: #333;
}


  #gameOverContainer {
    display: none;
    text-align: center;
    margin-top: 2rem;
  }

  #rematchBtn {
  display: block; /* ‚Üê Change this from "none" or "inline-block" to block */
  margin: 1.5rem auto 0; /* auto left/right centers it */
  padding: 0.5rem 1.5rem;
  font-weight: bold;
  border: none;
  border-radius: 4px;
  background-color: #007bff;
  color: white;
  transition: background-color 0.3s ease;
}


  #rematchBtn:hover {
    background-color: #0056b3;
  }

 #scoreboardSection {
  position: fixed;
  top: 1rem;
  right: 1rem;
  z-index: 1000;
}

#jumbotronScoreboard {
   background: #fff !important;
  color: #111 !important;
  border: 2px solid #111 !important;
  width: 180px !important;
  min-width: 120px !important;
  max-width: 95vw;
  font-family: Arial, sans-serif;
  box-shadow: none;
}

.scoreboard-box {
  background: #fff !important;
  border: 2px solid #111 !important;
  color: #111 !important;
  min-width: 120px !important;
  border-radius: 6px;
}

.scoreboard-header,
.scoreboard-scores {
  display: flex;
  flex-direction: row;
  width: 100%;
  height: 100%;
}

.scoreboard-header span,
.scoreboard-scores span {
  flex: 1 1 0;
  width: 50%;
  box-sizing: border-box;
  text-align: center;
  padding: 0.5rem;
}

.scoreboard-header .divider,
.scoreboard-scores .divider {
  background: #111 !important;
}

.scoreboard-header {
   background: #fff !important;
  color: #111 !important;
  border-bottom: 1px solid #111 !important;
}

.scoreboard-scores {
  background: #fff !important;
  color: #111 !important;
}

.divider {
  border-left: 1px solid #333;
  flex: 0 0 1px;
  padding: 0;
}


@media (max-width: 480px) {
  #guessControls {
    flex-direction: column;
    gap: 0.6rem;
  }

  #guessControls input, 
  #submitGuessBtn {
    width: 100%;
    min-width: auto;
  }

  #submitGuessBtn {
    font-size: 1.2rem;
    padding: 1rem;          /* visually balances a bigger tap target */
    min-height: 56px;       /* reaffirm minimum height */
  }

  #jumbotronScoreboard {
    width: 98vw !important;
    min-width: 0 !important;
    font-size: 0.95rem;
    padding: 0.2rem 0.1rem;
  }
  .scoreboard-box {
    min-width: 0 !important;
    font-size: 0.95rem;
  }
}

.auth-tabs-container {
  width: 100%;
  max-width: 600px;
  margin: 2rem auto;
}
.auth-tabs {
  display: flex;
  justify-content: center;
  margin-bottom: 1.5rem;
}
.auth-tab {
  flex: 1;
  padding: 1rem 2rem;
  background: #f0f0f0;
  border: none;
  border-bottom: 3px solid transparent;
  color: #333;
  font-size: 1.1rem;
  font-weight: bold;
  cursor: pointer;
  transition: background 0.2s, border-bottom 0.2s, color 0.2s;
}
.auth-tab.active {
  background: #fff;
  border-bottom: 3px solid #007bff;
  color: #007bff;
  z-index: 2;
}
.auth-forms-row {
  display: flex;
  gap: 2rem;
  justify-content: center;
  align-items: flex-start;
}
.auth-form {
  background: #fff;
  border: 1.5px solid #e0e4ea;
  border-radius: 18px;
  box-shadow: 0 6px 24px rgba(0,0,0,0.10), 0 1.5px 4px rgba(0,0,0,0.04);
  padding: 2.2rem 2rem 1.7rem 2rem;
  min-width: 260px;
  width: 100%;
  max-width: 340px;
  display: none;
  flex-direction: column;
  gap: 1.2rem;
  align-items: stretch;
  transition: box-shadow 0.2s, border 0.2s;
}
.auth-form.active {
  display: flex;
  z-index: 1;
  border: 2.5px solid #007bff;
  box-shadow: 0 10px 32px rgba(0,123,255,0.10), 0 2px 8px rgba(0,0,0,0.06);
}
.auth-form input {
  border-radius: 8px;
  border: 1.2px solid #d1d5db;
  padding: 0.85rem 1rem;
  font-size: 1.05rem;
  background: #f8fafc;
  color: #222;
  transition: border 0.2s;
}
.auth-form input:focus {
  border: 1.5px solid #007bff;
  outline: none;
  background: #fff;
}
.auth-form button {
  border-radius: 8px;
  background: linear-gradient(90deg, #007bff 60%, #0056b3 100%);
  color: #fff;
  font-weight: 600;
  font-size: 1.08rem;
  border: none;
  padding: 0.85rem 0;
  margin-top: 0.5rem;
  box-shadow: 0 2px 8px rgba(0,123,255,0.08);
  transition: background 0.2s, box-shadow 0.2s;
  cursor: pointer;
}
.auth-form button:hover {
  background: linear-gradient(90deg, #0056b3 60%, #007bff 100%);
  box-shadow: 0 4px 16px rgba(0,123,255,0.13);
}
.auth-form h2 {
  margin-bottom: 0.5rem;
  color: #007bff;
  font-size: 1.35rem;
  font-weight: 700;
  letter-spacing: 0.01em;
  text-align: center;
}
.auth-form p, .auth-form a {
  font-size: 0.97rem;
  color: #555;
  text-align: center;
}
.auth-form a {
  color: #007bff;
  text-decoration: underline;
  cursor: pointer;
}
.auth-form a:hover {
  color: #0056b3;
}
</style>


</head>
<body>
<nav>
  <span id="nav-username" style="display: none;"></span>
  <a href="#" id="nav-home-link" style="display: none;">üè† Home</a>
  <button id="nav-signin-btn">Sign In</button>
  <button id="nav-signout-btn" style="display: none;">Sign Out</button>
</nav>



<h1>NBA Teammate Game</h1>


<!-- üîë Sign Up / Sign In -->
  <section data-route="/signup">
    <div class="auth-tabs-container">
      <div class="auth-tabs">
        <button id="tab-signup" class="auth-tab active" type="button">Sign Up</button>
        <button id="tab-signin" class="auth-tab" type="button">Sign In</button>
      </div>
      <div class="auth-forms-row">
        <form id="signupForm" class="auth-form active" autocomplete="off">
          <h2>Sign Up</h2>
          <input type="email" id="signup-email" placeholder="Email" required>
          <input type="password" id="signup-password" placeholder="Password" required>
          <input id="signup-username" placeholder="Username" required>
          <button id="signupBtn" type="submit">Sign Up</button>
        </form>
        <form id="signinForm" class="auth-form" autocomplete="off">
          <h2>Sign In</h2>
          <input type="email" id="signin-email" placeholder="Email" required>
          <input type="password" id="signin-password" placeholder="Password" required>
          <button id="signinBtn" type="submit">Sign In</button>
          <p><a href="#" id="forgotPasswordLink">Forgot password?</a></p>
        </form>
      </div>
    </div>
  </section>


 <!-- üîó Check your email after sign up -->
  <section data-route="/verify" class="hidden">
    <h2>Check your email!</h2>
    <p>We've sent you a confirmation link. Click it to verify your account.</p>
  </section>


   <!-- ‚úÖ Confirmation success -->
  <section data-route="/confirmed" class="hidden">
    <h2>Account Confirmed</h2>
    <p>Your email is verified! You can now continue.</p>
    <button id="confirmedContinueBtn">Continue</button>
  </section>

  <!-- üîë Reset password -->
  <section data-route="/reset" class="hidden">
    <h2>Reset Password</h2>
    <input type="email" id="reset-email" placeholder="Email">
    <button id="resetBtn">Send Reset Link</button>
  </section>

  <!-- ‚úÖ Reset success -->
  <section data-route="/reset-confirmed" class="hidden">
    <h2>Password Reset</h2>
    <p>Check your email for a link to set a new password.</p>
  </section>

<!-- Set password -->
  <section data-route="/update-password" class="hidden">
  <h2>Set a New Password</h2>
  <input type="password" id="new-password" placeholder="New password" />
  <button id="updatePasswordBtn">Update Password</button>
</section>


  <!-- ‚úèÔ∏è Create username/profile
  <section data-route="/username" class="hidden">
    <h2>Create Profile</h2>
    <input id="create-username" placeholder="Choose a username">
    <button id="saveUsernameBtn">Save</button>
  </section> -->


<!-- Home Screen -->
<section id="homeSelection" data-route="/home" class="hidden" style="text-align: center; margin-top: 2rem;">
  <h2 id="home-welcome"></h2>
  <h2>üè† Home</h2>

  <div id="gameModeSelection" style="margin-top: 1rem;">
    <button id="privateGameBtn">üîí Start Private Game</button>
    <button id="findGameBtn">üåê Join Public Game</button>
  </div>

  <div id="playerStats" style="margin-top: 2rem;">
    <h3>Your Stats</h3>
    <p id="player-history">Games played, wins, and other stats will appear here.</p>
  </div>
</section>


<!-- Invite link container (used only in private games) -->
<section id="inviteLinkContainer" data-route="/invite" class="hidden" style="text-align: center; margin-top: 1rem;"></section>

<!-- Status message -->
<section id="status" data-route="/status" style="text-align: center; margin-top: 1rem;"></section>

<!-- Waiting Room View -->
<section id="waitingRoom" data-route="/waiting" class="hidden" style="text-align: center; margin-top: 2rem;">
  <h2>Waiting Room</h2>
  <p>Waiting for another player to join...</p>
  <code id="displayRoomCode" style="font-size: 1.5rem; font-weight: bold;"></code>
  <div id="inviteLinkWrapper" style="margin-top: 1rem;">
    <p>Invite a friend to join using this link:</p>
    <input id="inviteLink" type="text" readonly style="width: 80%; max-width: 400px; padding: 0.5rem;" />
    <button id="copyInviteBtn">Copy Link</button>
  <div id="copyToast" style="display:none; color: green; margin-top: 0.5rem;">Link copied!</div>
  </div>
</section>

<!-- Scoreboard UI -->
<!-- <section id="scoreboardSection">
  <div id="jumbotronScoreboard" class="scoreboard-box">
    <div class="scoreboard-header">
      <span id="player1Name">Player 1</span>
      <span id="player2Name">Player 2</span>
    </div>
    <div class="scoreboard-scores">
      <span id="player1Score" class="scoreDigits">0</span>
      <span id="player2Score" class="scoreDigits">0</span>
    </div>
  </div>
</section> -->


<!-- In-Game UI -->
<section id="gameArea" data-route="/play" class="hidden" style="position: relative;">
 <div id="playersDisplay">
  <span class="player-name you" id="playerYou">You</span>
  <span class="vs-separator">vs</span>
  <span class="player-name opponent" id="playerOpponent">Opponent</span>
</div>

  <div id="turnSection">
  <p class="turn-prompt" id="turnPromptText">
  üéØ Name any teammate of:<br>
  <strong class="turn-player-name" id="currentPlayerName">LeBron James</strong>
</p>


   <p>Time left: <span id="timer">15</span> seconds</p>
    <div id="guessControls" style="position: relative;">
      <input
        type="text"
        id="guessInput"
        placeholder="Type a teammate's name..."
        autocomplete="off"
        autocorrect="off"
        autocapitalize="off"
        spellcheck="false"
      />
      <button id="submitGuessBtn" disabled>Submit Guess</button>
      <div id="autocomplete-list"></div>
    </div>
  </div>

  <div id="messageContainer"></div>
</section>



<!-- Game Over UI -->
<section data-route="/gameover" class="hidden" style="text-align: center; margin-top: 2rem;">
  <div id="gameOverContainer" style="display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 1rem;">
    <!-- Game over message will be dynamically added here -->

    <!-- Add this container for winner/loser details -->
    <div id="gameOverResults" style="font-size: 1.2rem; margin-top: 1rem;"></div>
  </div>
  <button id="rematchBtn" style="margin-top: 1rem;">Request Rematch</button>
</section>


<!-- Shared Turn History List -->
<div id="successful-guesses-container" style="text-align: center; margin-top: 2rem;">
  <h3 style="margin-bottom: 0.5rem;">Turn History</h3>
  <ul id="successful-guesses-list" style="list-style: none; padding: 0;"></ul>
</div>


<script>
    // Core state
  let roomId = null;
  let myRoomId = null;
  let selectedPlayer = null;
  let fetchTimeout = null;
  let gameStarted = false;
  let gameOver = false;
  let leadoffPlayerName = null;
  let myUsername = null;
  let opponentName = null;
  let successfulGuesses = [];
  let isPrivateGame = false;
  let socket = null;
  let isLeavingGame = false;


document.addEventListener('DOMContentLoaded', async () => {
  console.log('[DEBUG] DOMContentLoaded');

  // --- 1Ô∏è‚É£ Email confirmation or recovery flow ---
  const urlHash = window.location.hash;
  const urlSearch = window.location.search;
  const searchParams = new URLSearchParams(urlSearch);
  const typeParam = searchParams.get('type');
  const urlParams = new URLSearchParams(window.location.search);
  const justConfirmed = urlParams.get('justConfirmed') === 'true';
  console.log('[DEBUG] On load: urlHash:', urlHash, 'urlSearch:', urlSearch, 'typeParam:', typeParam);

  if (
    (urlHash.includes('access_token') && 
      (urlHash.includes('type=signup') || urlHash.includes('type=recovery') || urlHash.includes('type=email_confirm')))
    || (typeParam === 'signup' || typeParam === 'recovery' || typeParam === 'email_confirm')
  ) {
    console.log('[DEBUG] Found email confirmation or recovery in URL');
    try {
      const { data: { user }, error } = await supabase.auth.getUser();
      if (error) {
        console.error('[ERROR] Email confirmation failed:', error.message);
      } else {
        console.log('[DEBUG] Email confirmed for:', user?.email);
      }
    } catch (e) {
      console.error('[ERROR] Exception during email confirmation:', e);
    }

    // ‚úÖ Always route to confirmation screen and stop here
    navigateTo('/confirmed');
    return;
  }

  // --- 2Ô∏è‚É£ Connect socket early ---
  socket = io();

  // --- 3Ô∏è‚É£ Get current Supabase session ---
  const { data } = await supabase.auth.getSession();
  if (data.session?.user) {
    myUsername = data.session.user.user_metadata?.username || data.session.user.email;
  } else {
    myUsername = localStorage.getItem('username') || null;
  }

  // --- 4Ô∏è‚É£ Load room info ---
  const params = new URLSearchParams(window.location.search);
  const roomFromUrl = params.get('room');
  if (roomFromUrl) {
    console.log('[DEBUG] Found invite link for room:', roomFromUrl);
    myRoomId = roomFromUrl;
    roomId = roomFromUrl;
    isPrivateGame = true;
    localStorage.setItem('privateRoomId', roomFromUrl);
  } else {
    const savedRoom = localStorage.getItem('privateRoomId');
    if (savedRoom) {
      console.log('[DEBUG] Found saved private room:', savedRoom);
      myRoomId = savedRoom;
      roomId = savedRoom;
      isPrivateGame = true;
    }
  }

  console.log('[DEBUG] Final state before routing:', {
    myUsername,
    myRoomId,
    isPrivateGame,
    isLeavingGame,
  });

  // --- 5Ô∏è‚É£ Determine initial route ---
  if (!myUsername) {
    navigateTo('/signup');
  } else if (isLeavingGame) {
    console.log('[DEBUG] Routing to /home because isLeavingGame=true');
    navigateTo('/home');
  } else if (myRoomId && !isLeavingGame && localStorage.getItem('isLeavingGame') !== 'true') {
    socket.emit('joinGame', { roomId: myRoomId, username: myUsername });
    navigateTo('/waiting');
  }
  else {
    navigateTo('/home');
  }

    // ‚úÖ Elements you actually use‚Ä¶
    const privateGameBtn = document.getElementById('privateGameBtn');
    const findGameBtn = document.getElementById('findGameBtn');
    const inviteLinkContainer = document.getElementById('inviteLinkContainer');
    const statusDiv = document.getElementById('status');
    const waitingRoom = document.getElementById('waitingRoom');
    const gameArea = document.getElementById('gameArea');
    const currentPlayerNameEl = document.getElementById('currentPlayerName');
    const timerEl = document.getElementById('timer');
    const guessInput = document.getElementById('guessInput');
    const submitGuessBtn = document.getElementById('submitGuessBtn');
    const messagesEl = document.getElementById('messageContainer');
    const autocompleteList = document.getElementById('autocomplete-list');
    const rematchBtn = document.getElementById('rematchBtn');


// submitUsernameBtn.onclick = async () => {
//   const entered = usernameInput.value.trim();
//   if (!entered) return alert('Please enter a username.');

//   const { data: { user } } = await supabase.auth.getUser();
//   if (!user) {
//     alert('No authenticated user!');
//     return;
//   }

//   const { error } = await supabase.from('profiles').upsert([
//     { id: user.id, username: entered }
//   ]);
//   if (error) {
//     alert('Failed to save username: ' + error.message);
//     return;
//   }

//   myUsername = entered;
//   localStorage.setItem('username', myUsername);

//   if (myRoomId) {
//     socket.emit('joinGame', { roomId: myRoomId, username: myUsername });
//     navigateTo('/waiting');
//   } else {
//     navigateTo('/mode');
//   }
// };


const copyInviteBtn = document.getElementById('copyInviteBtn');
const copyToast = document.getElementById('copyToast');
const inviteInput = document.getElementById('inviteLink');

copyInviteBtn.onclick = () => {
  navigator.clipboard.writeText(inviteInput.value)
    .then(() => {
      copyToast.style.display = 'block';

      // Hide toast after 2 seconds
      setTimeout(() => {
        copyToast.style.display = 'none';
      }, 2000);
    })
    .catch(err => {
      alert('Failed to copy link. Please copy it manually.');
      console.error('Clipboard copy failed:', err);
    });
};


function updateSplitScoreboard(stats, player1, player2) {
  const p1Name = player1 || 'Player 1';
  const p2Name = player2 || 'Player 2';

  document.getElementById('player1Name').textContent = p1Name;
  document.getElementById('player2Name').textContent = p2Name;

  // Defensive fallback for stats object
  const safeStats = stats || {};

  // Extract wins safely, default to 0 if missing or invalid
  const player1Stats = safeStats[p1Name];
  const player2Stats = safeStats[p2Name];

  const p1Wins = (player1Stats && typeof player1Stats.wins === 'number') ? player1Stats.wins : 0;
  const p2Wins = (player2Stats && typeof player2Stats.wins === 'number') ? player2Stats.wins : 0;

  document.getElementById('player1Score').textContent = p1Wins;
  document.getElementById('player2Score').textContent = p2Wins;
}


document.getElementById('nav-home-link')?.addEventListener('click', (e) => {
  e.preventDefault();
  isLeavingGame = true;
  if (socket && socket.connected) {
    socket.emit('leaveGame');
  }
  navigateTo('/home');
});



function markLeadoffInGuesses(guesses, leadoffName) {
  return guesses.map(g => ({
    ...g,
    isLeadoff: g.name === leadoffName
  }));
}




//     if (!roomFromUrl) {
//   handleUsernameEntry();
// }

function startPrivateGame() {
  console.log('[DEBUG] startPrivateGame called');

  if (isLeavingGame) {
    console.log('[DEBUG] startPrivateGame aborted: isLeavingGame is true');
    return; // ‚úÖ Do NOT start private game while intentionally leaving
  }

  if (!myUsername) {
    alert('Missing username');
    return;
  }

  if (gameStarted && !gameOver) {
    alert('Finish your current game first.');
    return;
  }

  isPrivateGame = true;
  isLeavingGame = false; // ‚úÖ You‚Äôre intentionally starting a new match

  // ‚úÖ Generate new room and clear stale room data
  const generatedRoomId = `room-${Math.random().toString(36).substring(2, 8)}`;
  roomId = generatedRoomId;
  myRoomId = generatedRoomId;

  socket.emit('joinGame', { roomId: myRoomId, username: myUsername });

  statusDiv.textContent = `Started private room: ${myRoomId}`;
  document.getElementById('displayRoomCode').textContent = myRoomId;

  inviteLinkContainer.innerHTML = `
    Share this link to invite a friend:<br>
    <a href="${window.location.origin}?room=${myRoomId}" target="_blank">
      ${window.location.origin}?room=${myRoomId}
    </a>
  `;

  navigateTo('/waiting');
}


function joinPublicGame() {
  console.log('[DEBUG] joinPublicGame called');

  // ‚úÖ If you‚Äôre intentionally finding a new game, clear any stale leaving flags FIRST
  
    console.log('[DEBUG] joinPublicGame: Clearing stale isLeavingGame flag');
    isLeavingGame = false;
    localStorage.removeItem('isLeavingGame');
  

  if (!myUsername) {
    alert('Missing username');
    return;
  }

  // ‚úÖ Extra safety: block if already in a game
  if (gameStarted && !gameOver) {
    alert('Finish your current game first.');
    return;
  }

  // ‚úÖ Always clear stale room info & mark this as public game
  myRoomId = null;
  roomId = null;
  isPrivateGame = false;

  // ‚úÖ Also reset local game state just in case
  selectedPlayer = null;
  successfulGuesses = [];
  gameOver = false;

  console.log('[DEBUG] Emitting findMatch with username:', myUsername);
  socket.emit('findMatch', myUsername);

  statusDiv.textContent = 'Looking for a game...';
  navigateTo('/waiting');
}






    socket.on('connect', () => {});

socket.on('playersUpdate', (count) => {
  console.log('[DEBUG] playersUpdate received:', count);

  if (isLeavingGame) {
    console.log('[DEBUG] playersUpdate skipped: isLeavingGame is true');
    return;
  }

  statusDiv.textContent = `Players in room: ${count}`;

  if (count < 2) {
    rematchBtn.style.display = 'none';
    navigateTo('/waiting');
  } else {
    navigateTo('/play');
  }
});




socket.on('matched', ({ roomId, opponent }) => {
  if (isLeavingGame || localStorage.getItem('isLeavingGame') === 'true') {
    console.log('[DEBUG] Ignoring matched event because isLeavingGame is true');
    return;
  }

  if (gameStarted && !gameOver) return;

  // ‚úÖ Once matched, clear stale flags
  isLeavingGame = false;
  localStorage.removeItem('isLeavingGame');

  myRoomId = roomId;
  opponentName = opponent;

  statusDiv.textContent = `Matched with ${opponent}! Joining game...`;

  navigateTo('/waiting');
  socket.emit('joinGame', { roomId: myRoomId, username: myUsername });
});





// 2. Game Lifecycle
socket.on('gameStarted', (data) => {
  if (isLeavingGame) {
    console.log('[DEBUG] Ignoring gameStarted because isLeavingGame === true');
    return;
  }

  // 1Ô∏è‚É£ Immediately navigate to /play so DOM elements exist
  navigateTo('/play');

  console.log('[CLIENT] Received gameStarted event:', data);

  gameStarted = true;
  gameOver = false;

  leadoffPlayerName = data.leadoffPlayer || null;

  // Clear old timers
  if (window.timerInterval) {
    clearInterval(window.timerInterval);
    window.timerInterval = null;
    console.warn('[CLIENT] Cleared leftover timer before starting new one.');
  }

  // Use setTimeout 0 to let /play DOM render before manipulating it
  setTimeout(() => {
    // Clear input + errors
    guessInput.disabled = true;
    submitGuessBtn.disabled = true;
    guessInput.value = '';
    clearGuessError();
    clearAutocomplete();

    // Reset rematch state
    rematchBtn.style.display = 'none';
    rematchBtn.disabled = false;
    rematchBtn.textContent = 'Rematch';

    // Clear any messages
    messagesEl.innerHTML = '';
    messagesEl.style.display = 'block';

    // Reset turn history cleanly
    successfulGuesses = [];

    if (data.leadoffPlayer && data.leadoffPlayer.trim() !== '') {
      leadoffPlayerName = data.leadoffPlayer;
      successfulGuesses.push({
        guesser: 'Leadoff',
        name: leadoffPlayerName,
        isLeadoff: true
      });
    }

    console.log('[CLIENT] successfulGuesses after reset:', successfulGuesses);
    renderSuccessfulGuesses();

    // Set current player name
    currentPlayerNameEl.textContent = data.currentPlayerName;

    // ‚úÖ Update "You" and "Opponent" names
    const playerYouEl = document.getElementById('playerYou');
    const playerOpponentEl = document.getElementById('playerOpponent');
    if (playerOpponentEl && data.opponentName) {
      playerOpponentEl.textContent = data.opponentName;
      opponentName = data.opponentName;  // keep local variable updated
    }
    if (playerYouEl) playerYouEl.textContent = myUsername || 'You';

    // ‚úÖ Highlight active player
    const isYourTurn = data.currentPlayerName === myUsername;
    if (playerYouEl && playerOpponentEl) {
      playerYouEl.classList.toggle('active-turn', isYourTurn);
      playerOpponentEl.classList.toggle('active-turn', !isYourTurn);
    }

    // Set initial timer
    timerEl.textContent = data.timeLeft || 15;
    console.log('[CLIENT] Timer initialized at:', data.timeLeft || 15);

    socket.emit('getMatchStats');
  }, 0);
});



socket.on('matchStats', (stats) => {
  console.log('[CLIENT] Updated matchStats:', stats);
  updateSplitScoreboard(stats, myUsername, opponentName);
});



socket.on('gameOver', (data) => {
  console.log('[DEBUG] gameOver received:', data);

  // ‚úÖ If I intentionally left, skip handling
  if (isLeavingGame) {
    console.debug('[DEBUG] Ignoring gameOver because isLeavingGame === true');
    isLeavingGame = false; // reset for next time
    return; // skip all the rest
  }

  gameOver = true;

  // Stop input & timer
  guessInput.disabled = true;
  submitGuessBtn.disabled = true;

  if (window.timerInterval) {
    clearInterval(window.timerInterval);
    window.timerInterval = null;
  }
  timerEl.textContent = '';

  // Ensure myUsername & opponentName
  if (!myUsername && data.winnerName && data.loserName) {
    if (data.role === 'winner') {
      myUsername = data.winnerName;
      opponentName = data.loserName;
    } else {
      myUsername = data.loserName;
      opponentName = data.winnerName;
    }
  } else if (!opponentName && data.winnerName && data.loserName) {
    opponentName = (myUsername === data.winnerName) ? data.loserName : data.winnerName;
  }

  // Show game over container
  const container = document.getElementById('gameOverContainer');
  container.style.display = 'flex';
  container.innerHTML = '';

  const gameOverMsg = document.createElement('div');
  gameOverMsg.style.fontSize = '1.5rem';
  gameOverMsg.style.textAlign = 'center';
  gameOverMsg.style.fontWeight = 'bold';
  gameOverMsg.style.marginTop = '1rem';

  if (data.message) {
    gameOverMsg.textContent = data.message;
  } else if (data.reason === 'opponent_left') {
    const opponent = opponentName || 'Your opponent';
    gameOverMsg.textContent = `${opponent} left the game.`;
  } else {
    gameOverMsg.textContent = 'Game Over!';
  }

  if (data.role === 'winner') {
    gameOverMsg.style.color = 'green';
  } else if (data.role === 'loser') {
    gameOverMsg.style.color = 'darkred';
  } else {
    gameOverMsg.style.color = 'gray';
  }

  container.appendChild(gameOverMsg);

  const resultsDiv = document.getElementById('gameOverResults');
  if (resultsDiv) {
    if (data.winnerName && data.loserName) {
      resultsDiv.innerHTML = `
        <p><strong>Winner:</strong> ${data.winnerName}</p>
        <p><strong>Loser:</strong> ${data.loserName}</p>
      `;
    } else {
      resultsDiv.innerHTML = '';
    }
  }

  if (data.canRematch === false || data.reason === 'opponent_left') {
    rematchBtn.style.display = 'none';
  } else {
    rematchBtn.style.display = 'block';
    rematchBtn.disabled = false;
    rematchBtn.textContent = 'Rematch';
  }

  // Let server 'matchStats' handle scoreboard update
  navigateTo('/gameover');
});




// 3. Turn Management
socket.on('yourTurn', (data) => {
  navigateTo('/play');

  const turnSection = document.getElementById('turnSection');

  turnSection.classList.add('your-turn');
  turnSection.classList.remove('opponent-turn');

  document.getElementById('guessControls').style.display = 'block';
  guessInput.disabled = false;
  submitGuessBtn.disabled = !guessInput.value.trim();

  currentPlayerNameEl.textContent = data.currentPlayerName || 'Your Turn';
  timerEl.textContent = data.timeLeft || 15;

  turnSection.style.display = 'block';
  messagesEl.style.display = 'block';

  showMessage(data.message || "It's your turn to guess!", 'info');

 const turnPromptEl = document.getElementById('turnPromptText');
if (turnPromptEl) {
  turnPromptEl.innerHTML = `üéØ Name any teammate of:<br><strong class="turn-player-name">${data.currentPlayerName}</strong>`;
}



  // ‚úÖ Highlight the current player in playersDisplay
  const playerYouEl = document.getElementById('playerYou');
  const playerOpponentEl = document.getElementById('playerOpponent');

  if (playerYouEl && playerOpponentEl) {
    playerYouEl.classList.add('active-turn');
    playerOpponentEl.classList.remove('active-turn');
  }
});



socket.on('opponentTurn', (data) => {
  navigateTo('/play');

  const turnSection = document.getElementById('turnSection');

  turnSection.classList.remove('your-turn');
  turnSection.classList.add('opponent-turn');

  document.getElementById('guessControls').style.display = 'none';
  guessInput.disabled = true;
  submitGuessBtn.disabled = true;

  currentPlayerNameEl.textContent = data.currentPlayerName || "Opponent's Turn";
  timerEl.textContent = '';

  turnSection.style.display = 'block';
  messagesEl.style.display = 'block';

  showMessage(data.message || "Waiting for your opponent to guess...", 'info');

  const turnPromptEl = document.getElementById('turnPromptText');
if (turnPromptEl) {
  turnPromptEl.innerHTML = `üïí Waiting for opponent to name a teammate of:<br><strong class="turn-player-name">${data.currentPlayerName}</strong>`;
}



  // ‚úÖ Highlight the opponent in playersDisplay
  const playerYouEl = document.getElementById('playerYou');
  const playerOpponentEl = document.getElementById('playerOpponent');

  if (playerYouEl && playerOpponentEl) {
    playerYouEl.classList.remove('active-turn');
    playerOpponentEl.classList.add('active-turn');
  }
});




socket.on('message', (msg) => {
  navigateTo('/play'); // Ensure user is on the gameplay page
  showMessage(msg, 'error');
});

socket.on('turnEnded', (data) => {
  navigateTo('/play');

  if (Array.isArray(data.successfulGuesses)) {
    successfulGuesses = markLeadoffInGuesses(data.successfulGuesses, leadoffPlayerName);
    renderSuccessfulGuesses();
  }

  if (data.message) {
    showMessage(data.message, data.message.startsWith('Incorrect guess') ? 'error' : 'info');
  }

  updateTurn(data);
});




socket.on('timerTick', (data) => {
  timerEl.textContent = data.timeLeft;
});


  // Autocomplete logic
guessInput.addEventListener('input', function() {
  const val = this.value.trim();
  clearAutocomplete();
  selectedPlayer = null;
  submitGuessBtn.disabled = true;

  if (!val) {
    showAutocompleteSuggestions([]);
    return;
  }

  if (fetchTimeout) clearTimeout(fetchTimeout);

  fetchTimeout = setTimeout(async () => {
    try {
      const res = await fetch(`/players?q=${encodeURIComponent(val)}`);
      if (!res.ok) throw new Error('Network response not ok');

      const results = await res.json();
      if (results.length === 0) {
        showAutocompleteSuggestions([]);
        return;
      }

      // ‚úÖ Create an array of actual HTML elements to pass to showAutocompleteSuggestions
      const suggestions = results.map(player => {
        const wrapper = document.createElement('div');
        wrapper.className = 'autocomplete-item';

        const nameSpan = document.createElement('span');
        nameSpan.textContent = player.player_name;

        const yearsSpan = document.createElement('span');
        yearsSpan.className = 'career-years';
        yearsSpan.textContent = ` ${player.first_year || '?'}‚Äì${player.last_year || '?'}`;

        yearsSpan.style.fontSize = '0.8em';
        yearsSpan.style.color = 'gray';
        yearsSpan.style.marginLeft = '5px';

        wrapper.appendChild(nameSpan);
        wrapper.appendChild(yearsSpan);

        wrapper.addEventListener('click', () => {
        guessInput.value = player.player_name;
        selectedPlayer = player.player_name;
        submitGuessBtn.disabled = false;
        clearAutocomplete();
      });

        return wrapper;
      });

      showAutocompleteSuggestions(suggestions);

    } catch (err) {
      console.error('Autocomplete fetch error:', err);
      showAutocompleteSuggestions([]);
    }
  }, 300);
});





  guessInput.addEventListener('change', () => {
    if (guessInput.value !== selectedPlayer) {
      selectedPlayer = null;
      submitGuessBtn.disabled = true;
    }
  });

  function submitGuess() {
  const guess = guessInput.value.trim();
  clearGuessError();

  if (!guess) {
    showGuessError('Enter a guess');
    return;
  }
  if (guess !== selectedPlayer) {
    showGuessError('Please select a player from the dropdown list.');
    return;
  }

  socket.emit('playerGuess', { roomId, guess });
  guessInput.value = '';
  selectedPlayer = null;
  submitGuessBtn.disabled = true;
  clearAutocomplete();
}


function requestRematch() {
  if (!myRoomId) {
    console.error('No roomId defined. Cannot request rematch.');
    return;
  }
  rematchBtn.disabled = true;
  rematchBtn.textContent = 'Waiting for opponent...';
  socket.emit('requestRematch', { roomId: myRoomId });
}


// When another player requests a rematch
socket.on('rematchRequested', ({ username }) => {
  showMessage(`${username} wants a rematch! Click your Rematch button to accept.`, 'info', true);

 
});

// When rematch actually starts
socket.on('rematchStarted', () => {
  resetGameUI();

  // Clear any rematch prompt message
  const rematchInfo = document.getElementById('rematch-info');
  if (rematchInfo) rematchInfo.remove();

  // Reset rematch button styles
  rematchBtn.disabled = false;
  rematchBtn.style.backgroundColor = ''; // Reset highlight
  rematchBtn.textContent = 'Rematch';

  // ‚úÖ Re-join the same room to trigger new game start
  if (myRoomId && myUsername) {
    console.log('[CLIENT] Rejoining room for rematch:', myRoomId);
    socket.emit('joinGame', { roomId: myRoomId, username: myUsername });
    socket.emit('getMatchStats');
  } else {
    console.error('[CLIENT] Missing roomId or username for rematch.');
  }
});




function resetGameUI() {
  gameStarted = true;
  gameOver = false;

  // Clear old timers
  if (window.timerInterval) {
    clearInterval(window.timerInterval);
    window.timerInterval = null;
  }

  guessInput.disabled = true;
  submitGuessBtn.disabled = true;
  guessInput.value = '';
  clearGuessError();
  clearAutocomplete();

  // Reset rematch button visibility and style
  rematchBtn.style.display = 'none';  // Or 'inline-block' if you want it visible immediately
  rematchBtn.disabled = false;
  rematchBtn.textContent = 'Rematch';
  rematchBtn.style.backgroundColor = ''; // Clear any highlight

  // Reset UI parts
  messagesEl.innerHTML = '';
  messagesEl.style.display = 'block';

  successfulGuesses.length = 0;
  document.getElementById('successful-guesses-list').innerHTML = '';
  renderSuccessfulGuesses();

  currentPlayerNameEl.textContent = '';
  timerEl.textContent = '';

  // Show/hide game areas as needed
  waitingRoom.style.display = 'none';
  gameArea.style.display = 'block';
  document.getElementById('turnSection').style.display = 'block';

  // Hide game over container
  const gameOverContainer = document.getElementById('gameOverContainer');
  gameOverContainer.innerHTML = '';
  gameOverContainer.style.display = 'none';

  // Clear persistent rematch message
  const messageContainer = document.getElementById('messageContainer');
  if (messageContainer) {
    messageContainer.innerHTML = '';
  }
}





 function clearGuessError() {
  const container = document.getElementById('messageContainer');
  container.innerHTML = '';
}

function showMessage(message, type = 'info', persist = false) {
  const container = document.getElementById('messageContainer');
  container.innerHTML = '';

  const div = document.createElement('div');
  div.textContent = message;
  div.classList.add('message');

  if (type === 'error') div.classList.add('error');

  container.appendChild(div);

  if (!persist) {
    setTimeout(() => {
      div.classList.add('fade-out');
      setTimeout(() => container.innerHTML = '', 1000);
    }, 3000);
  }
}






  function updateTurn(data) {
    currentPlayerNameEl.textContent = data.currentPlayerName || '???';
    timerEl.textContent = data.timeLeft || 15;
  }



 function clearAutocomplete() {
  autocompleteList.innerHTML = '';
  autocompleteList.style.display = 'none';
}


function showAutocompleteSuggestions(suggestions) {
  const list = document.getElementById('autocomplete-list');
  list.innerHTML = '';

  if (suggestions.length === 0) {
    list.style.display = 'none';  // Hide when empty
    return;
  }

  list.style.display = 'block'; // Show when populated

  suggestions.forEach(suggestionEl => {
    // suggestionEl is an element, append it directly
    list.appendChild(suggestionEl);
  });
}


function renderSuccessfulGuesses() {
  const listEl = document.getElementById('successful-guesses-list');
  if (!listEl || !Array.isArray(successfulGuesses)) return;

  listEl.innerHTML = '';

  const displayList = [...successfulGuesses].reverse();

  displayList.forEach((guessObj, index) => {
    const name = guessObj.name || '';
    const isLeadoff = guessObj.isLeadoff || false;
    const guesser = guessObj.guesser || '';
    const sharedTeams = guessObj.sharedTeams || [];

    if (!name.trim()) return;

    // Guess box
    const box = document.createElement('div');
    box.style.border = '1px solid #ccc';
    box.style.borderRadius = '8px';
    box.style.padding = '0.75rem';
    box.style.margin = '0.5rem auto';
    box.style.maxWidth = '300px';
    box.style.textAlign = 'center';
    box.style.backgroundColor = isLeadoff
      ? '#e6f0ff'
      : (guesser === myUsername ? '#d4edda' : '#f1f1f1');
    box.style.boxShadow = '0 2px 6px rgba(0,0,0,0.05)';

    const nameEl = document.createElement('div');
    nameEl.textContent = name;
    nameEl.style.fontSize = '1.1rem';
    nameEl.style.fontWeight = 'bold';
    box.appendChild(nameEl);

    listEl.appendChild(box);

    // Shared stints above arrow, only if NOT leadoff
    if (!isLeadoff && sharedTeams.length > 0 && index < displayList.length - 1) {
      const sharedInfo = document.createElement('div');
      sharedInfo.style.textAlign = 'center';
      sharedInfo.style.fontSize = '0.85rem';
      sharedInfo.style.color = '#444';
      sharedInfo.style.marginBottom = '0.25rem';

      const teamStrings = sharedTeams.map(t => `${t.team} (${t.years})`);
      sharedInfo.textContent = teamStrings.join(' ‚Ä¢ ');

      listEl.appendChild(sharedInfo);
    }

    // Up arrow (except for last guess)
    if (index < displayList.length - 1) {
      const arrow = document.createElement('div');
      arrow.textContent = '‚Üë';
      arrow.style.fontSize = '1.2rem';
      arrow.style.color = '#888';
      arrow.style.textAlign = 'center';
      arrow.style.margin = '0.25rem 0 0 0';
      listEl.appendChild(arrow);
    }
  });
}

function handleGoHome() {
  console.debug('[CLIENT] handleGoHome called');

  // ‚úÖ Mark that you‚Äôre intentionally leaving ‚Äî and persist it!
  isLeavingGame = true;
  localStorage.setItem('isLeavingGame', 'true');

  // ‚úÖ Tell server if in an active game
  if (socket && socket.connected && gameStarted && !gameOver) {
    socket.emit('leaveGame');
  }

  // ‚úÖ Always clear local game state
  myRoomId = null;
  roomId = null;
  isPrivateGame = false;
  gameStarted = false;
  gameOver = true;
  selectedPlayer = null;
  successfulGuesses = [];

  localStorage.removeItem('privateRoomId');

  navigateTo('/home');
}



async function handleAuthSuccess() {
  const { data: { user }, error } = await supabase.auth.getUser();
  if (error || !user) {
    console.error('No user signed in');
    navigateTo('/signup');
    return;
  }

  const username = user.user_metadata?.username || null;

  if (!username) {
    console.error('No username found in user_metadata!');
    navigateTo('/signup');
    return;
  }

  // Try updating profiles row, but don‚Äôt block navigation if it fails
  const { error: updateError } = await supabase
    .from('profiles')
    .update({ username })
    .eq('id', user.id);

  if (updateError) {
    console.warn('Warning: Error updating profile:', updateError.message);
  } else {
    console.log('‚úÖ Username saved to profiles:', username);
  }

  myUsername = username;
  localStorage.setItem('username', myUsername);

  // Clear URL hash to remove confirmation tokens
  history.replaceState(null, '', window.location.pathname);

  navigateTo('/home');
}



   const signupBtn = document.getElementById('signupBtn');
   const signinBtn = document.getElementById('signinBtn');

   if (signupBtn) {
      signupBtn.addEventListener('click', signUp);
      console.log('[DEBUG] signupBtn listener attached');
    } else {
      console.error('[ERROR] signupBtn not found!');
    }

    if (signinBtn) {
      signinBtn.addEventListener('click', signIn);
      console.log('[DEBUG] signinBtn listener attached');
    } else {
      console.error('[ERROR] signinBtn not found!');
    }

async function signUp() {
  const email = document.getElementById('signup-email').value.trim();
  const password = document.getElementById('signup-password').value.trim();
  const username = document.getElementById('signup-username').value.trim();

  if (!email || !password || !username) {
    alert('Please fill in all fields.');
    return;
  }

  if (password.length < 6) {
    alert('Password must be at least 6 characters.');
    return;
  }

  console.log('[DEBUG] SignUp data =>', email, username);

  const { data, error } = await supabase.auth.signUp({
    email,
    password,
    options: {
      data: { username } // üóùÔ∏è Saves to user_metadata
    }
  });

  if (error) {
    console.error('SignUp error:', error.message);
    return;
  }

  console.log('‚úÖ Sign Up successful:', data);
  navigateTo('/verify'); // tell user to check email!
}



async function signIn() {
  const email = document.getElementById('signin-email').value.trim();
  const password = document.getElementById('signin-password').value.trim();

  if (!email || !password) {
    alert('Please enter both email and password.');
    return;
  }

  console.log('[DEBUG] SignIn data =>', email);

  const { data, error } = await supabase.auth.signInWithPassword({
    email,
    password
  });

  if (error) {
    console.error('SignIn error:', error.message);
    return;
  }

  console.log('‚úÖ Sign In successful:', data);
  await handleAuthSuccess();
}



async function signOut() {
  const { error } = await window.supabase.auth.signOut();
  if (error) {
    alert('Sign out error: ' + error.message);
    return;
  }
  alert('Signed out!');
  showUser();
}


async function updateNavUserState(session) {
  const usernameDiv = document.getElementById('nav-username');
  const signinBtn = document.getElementById('nav-signin-btn');
  const signoutBtn = document.getElementById('nav-signout-btn');
  const homeLink = document.getElementById('nav-home-link'); // ‚úÖ Add this

  if (!usernameDiv || !signinBtn || !signoutBtn || !homeLink) return;

  if (!session || !session.user) {
    // Not logged in
    usernameDiv.style.display = 'none';
    signinBtn.style.display = 'inline-block';
    signoutBtn.style.display = 'none';
    homeLink.style.display = 'none'; // ‚úÖ Hide Home link
  } else {
    // Logged in
    const user = session.user;
    usernameDiv.textContent = `Hello, ${user.user_metadata?.username || user.email}`;
    usernameDiv.style.display = 'inline-block';
    signinBtn.style.display = 'none';
    signoutBtn.style.display = 'inline-block';
    homeLink.style.display = 'inline-block'; // ‚úÖ Show Home link
  }
}



// Listen for auth state changes and update nav accordingly
if (window.supabase && window.supabase.auth) {
  window.supabase.auth.onAuthStateChange((event, session) => {
    updateNavUserState(session);
  });
}

// Run once on load
updateNavUserState();

// Example: hook up sign out button
document.getElementById('nav-signout-btn').addEventListener('click', async () => {
  await window.supabase.auth.signOut();
  updateNavUserState();
  // Redirect to signup/signin screen (main app route)
  navigateTo('/signup');
});

// Optional: hook up sign in button to your sign-in flow
document.getElementById('nav-signin-btn').addEventListener('click', () => {
  // redirect to your sign-in page
  window.location.href = '/signin.html';
});





async function resetPassword() {
  const emailInput = document.getElementById('reset-email');
  const email = emailInput.value.trim();

  if (!email) {
    alert('Please enter your email address.');
    return;
  }

  try {
    const { data, error } = await supabase.auth.resetPasswordForEmail(email, {
      redirectTo: `${window.location.origin}/update-password`
    });

    if (error) {
      console.error('[ERROR] Supabase reset error:', error.message);
      alert('Error sending reset email: ' + error.message);
      return;
    }

    console.log('[INFO] Password reset email sent:', data);
    navigateTo('/reset-confirmed'); // Switch to your "Check your email" screen!
  } catch (err) {
    console.error('[ERROR] Unexpected:', err);
    alert('An unexpected error occurred.');
  }
}

async function updatePassword() {
  const newPasswordInput = document.getElementById('new-password');
  const newPassword = newPasswordInput.value.trim();

  if (!newPassword) {
    alert('Please enter a new password.');
    return;
  }

  const { data, error } = await supabase.auth.updateUser({
    password: newPassword
  });

  if (error) {
    console.error('[ERROR] Failed to update password:', error.message);
    alert('Error updating password: ' + error.message);
    return;
  }

  console.log('[INFO] Password updated:', data);

  // ‚úÖ Redirect the user back to sign in, or show success
  alert('Password updated successfully! Please sign in with your new password.');
  navigateTo('/signup');
}


/**
 * Navigate to a route in the SPA
 * @param {string} path - The route path, e.g. '/confirmed'
 * @param {object} options - Optional settings
 *   options.skipPush - If true, skips updating the browser's address bar
 */
function navigateTo(path, options = {}) {
  if (!options.skipPush) {
    history.pushState({}, '', path);
  }

  showRouteSection(path);
  updateUIForRoute(path);
  attachRouteListeners(path);
}


// 1. Attach route-specific listeners
function attachRouteListeners(route) {
  switch (route) {
    case '/signup':
      document.getElementById('signupBtn')?.addEventListener('click', signUp);
      document.getElementById('signinBtn')?.addEventListener('click', signIn);
      document.getElementById('forgotPasswordLink')?.addEventListener('click', (e) => {
        e.preventDefault();
        navigateTo('/reset');
      });
      break;

    case '/confirmed':
     document.getElementById('confirmedContinueBtn')?.addEventListener('click', () => {
        handleAuthSuccess(); // your existing handler to continue into the app/game
      });

      // Also update nav user state here so nav reflects logged-in user on confirmed page
      updateNavUserState();
      break;

    case '/reset':
      document.getElementById('resetBtn')?.addEventListener('click', resetPassword);
      break;

    case '/update-password':
      document.getElementById('updatePasswordBtn')?.addEventListener('click', updatePassword);
      break;

    case '/home':
      document.getElementById('privateGameBtn')?.addEventListener('click', () => {
        isLeavingGame = false;  // ‚úÖ I want to join a new game now
        startPrivateGame();
      });
      document.getElementById('findGameBtn')?.addEventListener('click', () => {
        isLeavingGame = false;  // ‚úÖ I want to find a public game now
        joinPublicGame();
      });
      break;

    case '/play':
      // Setup listeners or UI related to the gameplay screen here
      // For example, you might want to add listeners for guess submission buttons:
      document.getElementById('submitGuessBtn')?.addEventListener('click', submitGuess);
      document.getElementById('rematchBtn')?.addEventListener('click', requestRematch);
      break;

    // Add other route handlers here as needed
  }
}



// 2. Show/hide sections based on route
function showRouteSection(path) {
  const allSections = document.querySelectorAll('section[data-route]');
  let matched = false;

  allSections.forEach(section => {
    const route = section.getAttribute('data-route');
    if (route === path) {
      section.classList.remove('hidden');
      matched = true;
    } else {
      section.classList.add('hidden');
    }
  });

  // Fallback if no matching route found
  if (!matched) {
    const defaultSection = document.querySelector('section[data-route="/signup"]');
    if (defaultSection) {
      defaultSection.classList.remove('hidden');
    }
  }
}

// 3. Update UI elements specific to certain routes
function updateUIForRoute(path) {
 if (path === '/home') {
  console.log('[DEBUG] updateUIForRoute: Handling /home');

  // ‚úÖ Mark that you are intentionally leaving
  if (socket && socket.connected) {
    isLeavingGame = true;
    socket.emit('leaveGame');
  }

  // üßπ Clear local game state
  gameStarted = false;
  gameOver = true;
  roomId = null;
  myRoomId = null;
  isPrivateGame = false;
  selectedPlayer = null;
  successfulGuesses = [];

  // ‚úÖ DO NOT reset isLeavingGame here!
  // Let it stay true until you explicitly join or navigate away.

  // Update welcome
  const welcomeEl = document.getElementById('home-welcome');
  if (welcomeEl && myUsername) {
    welcomeEl.textContent = `Welcome, ${myUsername}! Choose your game mode below.`;
  }
}



  if (path === '/waiting') {
    if (isLeavingGame) {
      console.log('[DEBUG] updateUIForRoute: Skipping /waiting because isLeavingGame is true');
      return;  // üõë Prevent accidental waiting room navigation
    }

    const codeEl = document.getElementById('displayRoomCode');
    const inviteWrapper = document.getElementById('inviteLinkWrapper');
    const inviteInput = document.getElementById('inviteLink');

    if (codeEl && myRoomId) {
      codeEl.textContent = myRoomId;
    }

    if (inviteWrapper && inviteInput) {
      if (isPrivateGame && myRoomId) {
        const inviteUrl = `${window.location.origin}?room=${myRoomId}`;
        inviteInput.value = inviteUrl;
        inviteWrapper.style.display = 'block';
        inviteInput.focus();
        inviteInput.select();
      } else {
        inviteInput.value = '';
        inviteWrapper.style.display = 'none';
      }
    }
  }

  // Guess container visibility
  const guessContainer = document.getElementById('successful-guesses-container');
  if (guessContainer) {
    guessContainer.style.display = (path === '/play' || path === '/gameover') ? 'block' : 'none';
  }

  // Scoreboard visibility
  const scoreboard = document.getElementById('scoreboardSection');
  if (scoreboard) {
    if (path === '/play' || path === '/gameover') {
      scoreboard.classList.remove('hidden');
    } else {
      scoreboard.classList.add('hidden');
    }
  }
}


// 4. Main renderRoute function
function renderRoute(path, addToHistory = true) {
  showRouteSection(path);
  attachRouteListeners(path);
  updateUIForRoute(path);

  if (addToHistory && window.location.pathname !== path) {
    window.history.pushState({}, '', path);
  }
}

// 5. Listen for back/forward navigation
window.addEventListener('popstate', () => {
  renderRoute(window.location.pathname, false);
});

// 6. Initial page load render
document.addEventListener('DOMContentLoaded', () => {
  renderRoute(window.location.pathname || '/signup', false);
});


document.getElementById('guessInput').addEventListener('focus', () => {
  // Only apply if screen width is <= 480px (adjust as needed for "mobile")
  if (window.innerWidth <= 480) {
    const guessControls = document.getElementById('guessControls');
    const topOffset = guessControls.getBoundingClientRect().top + window.scrollY;
    const padding = parseFloat(getComputedStyle(document.body).paddingTop) || 16;

    window.scrollTo({
      top: topOffset - padding,
      behavior: 'smooth'
    });
  }
});

// Handle browser back/forward navigation
window.addEventListener('popstate', () => {
  const path = window.location.pathname;
  showRouteSection(path);
  updateUIForRoute(path);
  attachRouteListeners(path);
});

// Initial route on page load
document.addEventListener('DOMContentLoaded', () => {
  const initialPath = (location.pathname === '/' || location.pathname === '') ? '/signup' : location.pathname;
  renderRoute(initialPath);
});


    // After all routing logic:
    if (justConfirmed) {
      if (typeParam === 'recovery' || urlHash.includes('type=recovery')) {
        navigateTo('/update-password');
        return;
      } else {
        navigateTo('/confirmed');
        return;
      }
    }
  }); // End of DOMContentLoaded

  // Tab switching logic for auth forms
    document.addEventListener('DOMContentLoaded', function() {
      const tabSignup = document.getElementById('tab-signup');
      const tabSignin = document.getElementById('tab-signin');
      const signupForm = document.getElementById('signupForm');
      const signinForm = document.getElementById('signinForm');
      tabSignup.addEventListener('click', function() {
        tabSignup.classList.add('active');
        tabSignin.classList.remove('active');
        signupForm.classList.add('active');
        signinForm.classList.remove('active');
      });
      tabSignin.addEventListener('click', function() {
        tabSignin.classList.add('active');
        tabSignup.classList.remove('active');
        signinForm.classList.add('active');
        signupForm.classList.remove('active');
      });
    });

    // Attach signup handler to the form submit event instead of button click
   const signupForm = document.getElementById('signupForm');
   if (signupForm) {
     signupForm.addEventListener('submit', function(e) {
       e.preventDefault();
       signUp();
     });
   }
   // Remove the old signupBtn click handler if present
</script>
</body>
</html>