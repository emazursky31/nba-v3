<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NBA Teammate Game</title>

  <!-- External CSS -->
  <link rel="stylesheet" href="style.css" />

  <!-- Socket.IO -->
  <script src="https://cdn.socket.io/4.6.1/socket.io.min.js" crossorigin="anonymous"></script>

  <!-- Supabase (ES Module) -->
  <script type="module">
    import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm'

    const SUPABASE_URL = 'https://rbjdlzgptvpfsnkakasj.supabase.co'
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJiamRsemdwdHZwZnNua2FrYXNqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg5ODYxMzksImV4cCI6MjA2NDU2MjEzOX0.U0EhIpOaKrHQmAJHcCBVJLKDGEW-m91eNj2bWRejYpk'
    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY)

    window.supabase = supabase // Expose for later use
  </script>
</head>

<body>
<nav>
  <span id="nav-username" style="display: none;"></span>
  <a href="#" id="nav-home-link" style="display: none;">üè† Home</a>
  <button id="nav-signin-btn" style="display: none;">Sign In</button>
  <button id="nav-signout-btn" style="display: none;">Sign Out</button>
</nav>


<h1>Who He Played With</h1>



<!-- üîë Sign Up / Sign In -->
  <section data-route="/signup">
    <div class="auth-tabs-container">
      <div class="auth-tabs">
        <button id="tab-signup" class="auth-tab active" type="button">Sign Up</button>
        <button id="tab-signin" class="auth-tab" type="button">Sign In</button>
      </div>
      <div class="auth-forms-row">
        <form id="signupForm" class="auth-form active" autocomplete="off">
          <h2>Sign Up</h2>
          <input type="email" id="signup-email" placeholder="Email" required>
          <input type="password" id="signup-password" placeholder="Password" required>
          <input id="signup-username" placeholder="Username" required>
          <button id="signupBtn" type="submit">Sign Up</button>
        </form>
        <form id="signinForm" class="auth-form" autocomplete="off">
          <h2>Sign In</h2>
          <input type="email" id="signin-email" placeholder="Email" required>
          <input type="password" id="signin-password" placeholder="Password" required>
          <button id="signinBtn" type="submit">Sign In</button>
          <p><a href="#" id="forgotPasswordLink">Forgot password?</a></p>
        </form>
      </div>
    </div>
  </section>


 <!-- üîó Check your email after sign up -->
  <section data-route="/verify" class="hidden">
    <h2>Check your email!</h2>
    <p>We've sent you a confirmation link. Click it to verify your account.</p>
  </section>


   <!-- ‚úÖ Confirmation success -->
  <section data-route="/confirmed" class="hidden">
    <h2>Account Confirmed</h2>
    <p>Your email is verified! You can now continue.</p>
    <button id="confirmedContinueBtn">Continue</button>
  </section>

  <!-- üîë Reset password -->
  <section data-route="/reset" class="hidden">
    <h2>Reset Password</h2>
    <input type="email" id="reset-email" placeholder="Email">
    <button id="resetBtn">Send Reset Link</button>
  </section>

  <!-- ‚úÖ Reset success -->
  <section data-route="/reset-confirmed" class="hidden">
    <h2>Password Reset</h2>
    <p>Check your email for a link to set a new password.</p>
  </section>

<!-- Set password -->
  <section data-route="/update-password" class="hidden">
  <h2>Set a New Password</h2>
  <input type="password" id="new-password" placeholder="New password" />
  <button id="updatePasswordBtn">Update Password</button>
</section>


  <!-- ‚úèÔ∏è Create username/profile
  <section data-route="/username" class="hidden">
    <h2>Create Profile</h2>
    <input id="create-username" placeholder="Choose a username">
    <button id="saveUsernameBtn">Save</button>
  </section> -->


<!-- Home Screen -->
<section id="homeSelection" data-route="/home" class="hidden" style="text-align: center; margin-top: 2rem;">
  <h2 id="home-welcome"></h2>
  <h2>üè† Home</h2>

  <div id="gameModeSelection" style="margin-top: 1rem;">
    <button id="privateGameBtn">üîí Start Private Game</button>
    <button id="findGameBtn">üåê Join Public Game</button>
  </div>

  <div id="playerStats" style="margin-top: 2rem;">
    <h3>Your Stats</h3>
    <p id="player-history">Games played, wins, and other stats will appear here.</p>
  </div>
</section>


<!-- Invite link container (used only in private games) -->
<section id="inviteLinkContainer" data-route="/invite" class="hidden" style="text-align: center; margin-top: 1rem;"></section>

<!-- Status message -->
<section id="status" data-route="/status" style="text-align: center; margin-top: 1rem;"></section>

<!-- Waiting Room View -->
<section id="waitingRoom" data-route="/waiting" class="hidden" style="text-align: center; margin-top: 2rem;">
  <h2>Waiting Room</h2>
  <p id="waitingStatus">Waiting for another player to join...</p>
  <code id="displayRoomCode" style="font-size: 1.5rem; font-weight: bold;"></code>
  <div id="inviteLinkWrapper" style="margin-top: 1rem;">
    <p>Invite a friend to join using this link:</p>
    <input id="inviteLink" type="text" readonly style="width: 80%; max-width: 400px; padding: 0.5rem;" />
    <button id="copyInviteBtn">Copy Link</button>
  <div id="copyToast" style="display:none; color: green; margin-top: 0.5rem;">Link copied!</div>
  </div>
</section>

<!-- Scoreboard UI -->
<!-- <section id="scoreboardSection">
  <div id="jumbotronScoreboard" class="scoreboard-box">
    <div class="scoreboard-header">
      <span id="player1Name">Player 1</span>
      <span id="player2Name">Player 2</span>
    </div>
    <div class="scoreboard-scores">
      <span id="player1Score" class="scoreDigits">0</span>
      <span id="player2Score" class="scoreDigits">0</span>
    </div>
  </div>
</section> -->


<!-- In-Game UI -->
<section id="gameArea" data-route="/play" class="hidden" style="position: relative;">
 <div id="playersDisplay">
  <span class="player-name you" id="playerYou">You</span>
  <span class="vs-separator">vs</span>
  <span class="player-name opponent" id="playerOpponent">Opponent</span>
</div>

  <div id="turnSection">
 <p class="turn-prompt" id="turnPromptText" style="display: flex; align-items: center; gap: 12px;">
  <!-- Dynamic content will be inserted here by JavaScript -->
  <img id="currentPlayerHeadshot" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAAvklEQVRoge3XsQ2AIBBF0ZLpDoBuwHFHqK8cQvMrIo3FLPHom/b2mX9rcNqZmZmZmZmZmZmdFz5ec3m6F3+v4PYs3PmR7JbiDD1N9g5IuT16CWYExozP7G9Czzxq/cE8ksYbFxExk2RcMUfYHNk0RMYPhk0QcMbJHUYyNsi9h5YDyYFSNqLD6c+5h3tGn+MO9ZftHJz5nz/rq3ZTzRzqkIxuYwAAAABJRU5ErkJggg==" alt="Current Player Headshot" width="60" height="60" style="border-radius: 50%; object-fit: cover;"/>
  <strong class="turn-player-name" id="currentPlayerName">Loading...</strong>
</p>



   <p>Time left: <span id="timer">15</span> seconds</p>
    <div id="guessControls" style="position: relative;">
      <input
        type="text"
        id="guessInput"
        placeholder="Type a teammate's name..."
        autocomplete="off"
        autocorrect="off"
        autocapitalize="off"
        spellcheck="false"
      />
      <button id="submitGuessBtn" disabled>Submit Guess</button>
      <div id="autocomplete-list"></div>
    </div>
  </div>

  <div id="messageContainer"></div>
</section>



<!-- Game Over UI -->
<section data-route="/gameover" class="hidden" style="text-align: center; margin-top: 2rem;">
  <div id="gameOverContainer" style="display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 1rem;">
    <!-- Game over message will be dynamically added here -->

    <!-- Add this container for winner/loser details -->
    <div id="gameOverResults" style="font-size: 1.2rem; margin-top: 1rem;"></div>
  </div>
  <button id="rematchBtn" style="margin-top: 1rem;">Request Rematch</button>
</section>


<!-- Shared Turn History List -->
<div id="successful-guesses-container" style="text-align: center; margin-top: 2rem;">
  <h3 style="margin-bottom: 1rem;">üÉè Player Deck</h3>
  <div id="card-deck" class="card-deck-container"></div>
</div>



<script>
// 1. Global variables and state (outside DOMContentLoaded)
// Core state
  let roomId = null;
  let myRoomId = null;
  let selectedPlayer = null;
  let fetchTimeout = null;
  let gameStarted = false;
  let gameOver = false;
  let leadoffPlayerName = null;
  let myUsername = null;
  let opponentName = null;
  let successfulGuesses = [];
  let isPrivateGame = false;
  let socket = null;
  let isLeavingGame = false;
// ‚úÖ Global route tracker
  let currentRoute = '';
  let statusDiv = null;
  let socketConnected = false;
  let emitQueue = [];

  // DOM element references (assigned in DOMContentLoaded)
let guessInput = null;
let submitGuessBtn = null;
let rematchBtn = null;
let messagesEl = null;
let currentPlayerNameEl = null;
let currentPlayerHeadshotEl = null;
let currentPlayerHeadshotUrl = null;
let timerEl = null;
let autocompleteList = null;
let waitingRoom = null;
let gameArea = null;
let inviteLinkContainer = null;
let myUserId = null;
let storedHeadshots = new Map();
const DEFAULT_PLAYER_IMAGE = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAAvklEQVRoge3XsQ2AIBBF0ZLpDoBuwHFHqK8cQvMrIo3FLPHom/b2mX9rcNqZmZmZmZmZmZmdFz5ec3m6F3+v4PYs3PmR7JbiDD1N9g5IuT16CWYExozP7G9Czzxq/cE8ksYbFxExk2RcMUfYHNk0RMYPhk0QcMbJHUYyNsi9h5YDyYFSNqLD6c+5h3tGn+MO9ZftHJz5nz/rq3ZTzRzqkIxuYwAAAABJRU5ErkJggg==';




// 2. Function definitions (outside DOMContentLoaded)
 // ‚úÖ Sign Up handler
  async function signUp(e) {
    e.preventDefault(); // üõë Stop default form submit

    const email = document.getElementById('signup-email').value.trim();
    const password = document.getElementById('signup-password').value.trim();
    const username = document.getElementById('signup-username').value.trim();

    if (!email || !password || !username) {
      alert('Please fill in all fields.');
      return;
    }

    if (password.length < 6) {
      alert('Password must be at least 6 characters.');
      return;
    }

    console.log('[DEBUG] SignUp data =>', email, username);

    const { data, error } = await supabase.auth.signUp({
      email,
      password,
      options: {
        data: { username }
      }
    });

    if (error) {
      console.error('SignUp error:', error.message);
      return;
    }

    console.log('‚úÖ Sign Up successful:', data);
    navigateTo('/verify'); // üëà Show verification screen
  }

  // ‚úÖ Sign In handler
  async function signIn(e) {
    e.preventDefault(); // üõë Stop default form submit

    const email = document.getElementById('signin-email').value.trim();
    const password = document.getElementById('signin-password').value.trim();

    if (!email || !password) {
      alert('Please fill in all fields.');
      return;
    }

    console.log('[DEBUG] SignIn data =>', email);

    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password
    });

    if (error) {
      console.error('SignIn error:', error.message);
      alert(error.message);
      return;
    }

    console.log('‚úÖ Sign In successful:', data);
    const user = data.user;
    myUsername = user.user_metadata?.username || user.email;
    myUserId = user.id;
    localStorage.setItem('username', myUsername);
    localStorage.setItem('userId', myUserId);

    console.log('[DEBUG] Username set to:', myUsername);
    console.log('[DEBUG] UserId set to:', myUserId);

    // ‚úÖ ADD: Notify server about authentication
    if (socket && socket.connected) {
      socket.emit('userSignedIn', { userId: myUserId, username: myUsername });
    }
    
    navigateTo('/home'); 
  }


function updateSplitScoreboard(stats, player1, player2) {
  const p1NameEl = document.getElementById('player1Name');
  const p2NameEl = document.getElementById('player2Name');

  if (!p1NameEl || !p2NameEl) {
    console.warn('[DEBUG] Scoreboard elements not found. Skipping updateSplitScoreboard.');
    return; // Or: queue the update!
  }

  const p1Name = player1 || 'Player 1';
  const p2Name = player2 || 'Player 2';

  p1NameEl.textContent = p1Name;
  p2NameEl.textContent = p2Name;

  const safeStats = stats || {};
  const player1Stats = safeStats[p1Name];
  const player2Stats = safeStats[p2Name];
  const p1Wins = (player1Stats && typeof player1Stats.wins === 'number') ? player1Stats.wins : 0;
  const p2Wins = (player2Stats && typeof player2Stats.wins === 'number') ? player2Stats.wins : 0;

  document.getElementById('player1Score').textContent = p1Wins;
  document.getElementById('player2Score').textContent = p2Wins;
}



function waitForScoreboard() {
  return new Promise((resolve) => {
    const check = () => {
      if (
        document.getElementById('player1Name') &&
        document.getElementById('player1Score')
      ) {
        resolve();
      } else {
        requestAnimationFrame(check);
      }
    };
    check();
  });
}



function markLeadoffInGuesses(guesses, leadoffName) {
  return guesses.map(g => ({
    ...g,
    isLeadoff: g.name === leadoffName
  }));
}



function startPrivateGame() {
  console.log('[DEBUG] startPrivateGame called');

  if (isLeavingGame) {
    console.log('[DEBUG] startPrivateGame aborted: isLeavingGame is true');
    return;
  }

  if (!myUsername) {
    alert('Missing username');
    return;
  }

  if (gameStarted && !gameOver) {
    alert('Finish your current game first.');
    return;
  }

  isPrivateGame = true;
  isLeavingGame = false;

  // Generate new room and clear stale room data
  const generatedRoomId = `room-${Math.random().toString(36).substring(2, 8)}`;
  roomId = generatedRoomId;
  myRoomId = generatedRoomId;

  window.supabase.auth.getUser().then(({ data }) => {
    const userId = data?.user?.id;
    if (!userId) {
      alert('Could not get your user ID. Please sign in again.');
      return;
    }
     myUserId = userId;
    localStorage.setItem('userId', myUserId);
    socket.emit('joinGame', { roomId: myRoomId, username: myUsername, userId });

    statusDiv.textContent = `Started private room: ${myRoomId}`;
    document.getElementById('displayRoomCode').textContent = myRoomId;

    // **Don't overwrite the container innerHTML!**
    const inviteInput = document.getElementById('inviteLink');
    if (inviteInput) {
      inviteInput.value = `${window.location.origin}?room=${myRoomId}`;
    }

    // Show the waiting room section
    waitingRoom.classList.remove('hidden');

    // Setup copy button listeners
    setupCopyInviteListeners();

    navigateTo('/waiting');
  });
}



async function joinPublicGame() {
  console.log('[DEBUG] joinPublicGame called');

   const { data: { session }, error } = await supabase.auth.getSession();
  if (error || !session?.user) {
    console.warn('[joinPublicGame] No valid session, redirecting to signup');
    navigateTo('/signup');
    return;
  }

  if (socket && socket.connected && session.user) {
    socket.emit('userSignedIn', { 
      userId: session.user.id, 
      username: session.user.user_metadata?.username || session.user.email 
    });
  }

  isLeavingGame = false;
  localStorage.removeItem('isLeavingGame');

  if (!myUsername) {
    console.warn('[DEBUG] myUsername is null, attempting to recover from session');
    // Try to get username from current session
    const { data: { user } } = await supabase.auth.getUser();
    if (user) {
      myUsername = user.user_metadata?.username || user.email;
      localStorage.setItem('username', myUsername);
      console.log('[DEBUG] Recovered username:', myUsername);
    }

    // If still no username, show error
    if (!myUsername) {
      alert('Missing username. Please sign out and sign in again.');
      return;
    }
  }

  if (gameStarted && !gameOver) {
    alert('Finish your current game first.');
    return;
  }

  myRoomId = null;
  roomId = null;
  isPrivateGame = false;
  selectedPlayer = null;
  successfulGuesses = [];
  gameOver = false;
  gameStarted = false;
  leadoffPlayerName = null;
  opponentName = null;

  // Clear UI elements
  if (currentPlayerNameEl) currentPlayerNameEl.textContent = '';
  if (timerEl) timerEl.textContent = '';
  if (currentPlayerHeadshotEl) currentPlayerHeadshotEl.src = DEFAULT_PLAYER_IMAGE;

  // Clear turn history
  const cardDeck = document.getElementById('card-deck');
  if (cardDeck) cardDeck.innerHTML = '';

  // Clear any persistent localStorage
  localStorage.removeItem('privateRoomId');
  localStorage.removeItem('isLeavingGame');

  // ‚úÖ Ensure socket is connected (don't re-initialize)
  if (!socket || !socket.connected) {
    console.log('[joinPublicGame] Socket not ready, waiting for connection...');
    // Socket should already be initialized in DOMContentLoaded
  }

  // Fetch user_id from Supabase and emit findMatch with userId
  const { data: { user } } = await supabase.auth.getUser();
  const userId = user?.id;
  if (!userId) {
    alert('Could not get your user ID. Please sign in again.');
    return;
  }

  myUserId = userId;
  localStorage.setItem('userId', myUserId);

  console.log('[DEBUG] Navigating to /waiting...');
  await navigateTo('/waiting');

  // ‚úÖ Add this: Ensure status message is set for public games
  if (statusDiv) {
    statusDiv.textContent = 'Looking for an opponent...';
  }

  console.log('[DEBUG] Using safeEmit to find match:', myUsername, userId);
  safeEmit('findMatch', { username: myUsername, userId });
}



  function safeEmit(event, data) {
    if (!socket) {
      console.warn(`[safeEmit] Socket is null ‚Äî this shouldn't happen after DOMContentLoaded`);
      return; // Don't emit if socket isn't ready
    }

  emitQueue.push({ event, data });

  if (socket && socket.connected) {
    console.log(`[safeEmit] Socket connected ‚Äî emitting "${event}" immediately`);
    flushEmitQueue();
  } else {
    console.log(`[safeEmit] Socket not connected ‚Äî queued "${event}"`);
  }
}

function flushEmitQueue() {
  if (!socket) {
    console.warn(`[flushEmitQueue] Socket is null ‚Äî cannot flush`);
    return;
  }

  while (socket.connected && emitQueue.length > 0) {
    const { event, data } = emitQueue.shift();
    console.log(`[safeEmit] Flushing queued "${event}"`);
    socket.emit(event, data);
  }
}


function updateHeadshot(player) {
  if (currentPlayerHeadshotEl) {
    currentPlayerHeadshotEl.src = player.headshot_url || DEFAULT_PLAYER_IMAGE;
    currentPlayerHeadshotEl.alt = `${player.player_name || 'Unknown'} Headshot`;
  }
}

function triggerGameEndCardSpread() {
  const deckContainer = document.getElementById('card-deck');
  if (!deckContainer) return;
  
  // Add a small delay to let the game over UI settle
  setTimeout(() => {
    deckContainer.classList.add('game-ended');  // ‚úÖ Add to the container itself
    
    // Optional: Add a subtle sound effect or visual feedback
    console.log('üé¥ Cards spreading out to show the full game sequence!');
  }, 1000); // 1 second delay after game ends
}

function resetCardSpread() {
  const deckContainer = document.getElementById('card-deck');
  if (!deckContainer) return;
  
  // Remove the game-ended class
  deckContainer.classList.remove('game-ended');
  
  // ‚úÖ Also force remove any lingering transform styles
  deckContainer.style.transform = '';
  
  // ‚úÖ Reset any individual card transforms
  const cards = deckContainer.querySelectorAll('.player-card');
  cards.forEach(card => {
    card.style.transform = '';
    card.style.left = '';
    card.style.zIndex = '';
  });
  
  console.log('üé¥ Card spread animation reset for new game');
}



function attachRouteListeners(route) {
  supabase.auth.getSession().then(({ data }) => {
    updateNavUserState(data.session);
  });

  switch (route) {
    case '/signup':
      // Setup auth tab switching
      setupAuthTabs();
      // Only non-form button listeners (forms handled by setupFormListeners)
      const forgotPasswordLink = document.getElementById('forgotPasswordLink');
      if (forgotPasswordLink) {
        forgotPasswordLink.addEventListener('click', (e) => {
          e.preventDefault();
          navigateTo('/reset');
        });
      }
      break;

    case '/confirmed':
      const confirmedContinueBtn = document.getElementById('confirmedContinueBtn');
      if (confirmedContinueBtn) {
        confirmedContinueBtn.addEventListener('click', () => {
          handleAuthSuccess();
        });
      }
      // Update nav state for confirmed page
      updateNavUserState();
      break;

    case '/home':
      const privateGameBtn = document.getElementById('privateGameBtn');
      const findGameBtn = document.getElementById('findGameBtn');
      
      if (privateGameBtn) {
        privateGameBtn.addEventListener('click', () => {
          if (privateGameBtn.disabled) return; // Prevent multiple clicks
          privateGameBtn.disabled = true;
          setTimeout(() => privateGameBtn.disabled = false, 2000); // Re-enable after 2s

          isLeavingGame = false;
          startPrivateGame();
        });
      }

      if (findGameBtn) {
        findGameBtn.addEventListener('click', () => {
          if (findGameBtn.disabled) return; // Prevent multiple clicks
          findGameBtn.disabled = true;
          setTimeout(() => findGameBtn.disabled = false, 2000); // Re-enable after 2s

          isLeavingGame = false;
          joinPublicGame();
        });
      }

      loadPlayerStats();
      break;

    case '/play':
      // Game-specific listeners
      const submitGuessBtn = document.getElementById('submitGuessBtn');
      const rematchBtn = document.getElementById('rematchBtn');
      
      if (submitGuessBtn) {
        submitGuessBtn.addEventListener('click', submitGuess);
      }
      
      if (rematchBtn) {
        rematchBtn.addEventListener('click', requestRematch);
      }
      
      // Setup autocomplete for gameplay
      setupAutocompleteListeners();
      setupMobileInputFocus();
      break;

    case '/waiting':
      if (isPrivateGame && myRoomId) {
        const inviteInput = document.getElementById('inviteLink');
        if (inviteInput) {
          inviteInput.value = `${window.location.origin}?room=${myRoomId}`;
        }

        const roomCodeEl = document.getElementById('displayRoomCode');
        if (roomCodeEl) {
          roomCodeEl.textContent = myRoomId;
        }

        waitingRoom.classList.remove('hidden');
      }
      // Setup copy invite button listener anyway
      setupCopyInviteListeners();
      break;


    // Add other route handlers as needed
  }
}

function navigateTo(path, options = {}) {
  return new Promise((resolve) => {
    // Track the intended route immediately
    currentRoute = path;

    if (!options.skipPush) {
      history.pushState({}, '', path);
    }

    showRouteSection(path);

    // Wrap updateUIForRoute with a guard
    if (currentRoute === path) {
      updateUIForRoute(path);
      attachRouteListeners(path);
    } else {
      console.debug('[navigateTo] Skipped updateUIForRoute ‚Äî stale path', path);
    }

    // Use rAF for next paint
    requestAnimationFrame(() => {
      resolve();
    });
  });
}

function setupMobileInputFocus() {
  const guessInput = document.getElementById('guessInput');
  if (guessInput) {
    guessInput.addEventListener('focus', () => {
      // Only apply if screen width is <= 480px (mobile)
      if (window.innerWidth <= 480) {
        const guessControls = document.getElementById('guessControls');
        const topOffset = guessControls.getBoundingClientRect().top + window.scrollY;
        const padding = parseFloat(getComputedStyle(document.body).paddingTop) || 16;

        window.scrollTo({
          top: topOffset - padding,
          behavior: 'smooth'
        });
      }
    });
  }
}

function setupAuthTabs() {
  const tabSignup = document.getElementById('tab-signup');
  const tabSignin = document.getElementById('tab-signin');
  const signupForm = document.getElementById('signupForm');
  const signinForm = document.getElementById('signinForm');
  
  if (tabSignup && tabSignin && signupForm && signinForm) {
    tabSignup.addEventListener('click', function() {
      tabSignup.classList.add('active');
      tabSignin.classList.remove('active');
      signupForm.classList.add('active');
      signinForm.classList.remove('active');
    });
    
    tabSignin.addEventListener('click', function() {
      tabSignin.classList.add('active');
      tabSignup.classList.remove('active');
      signinForm.classList.add('active');
      signupForm.classList.remove('active');
    });
  }
}



  function submitGuess() {
  const guess = guessInput.value.trim();
  clearGuessError();

  if (!guess) {
    showGuessError('Enter a guess');
    return;
  }
  if (guess !== selectedPlayer) {
    showGuessError('Please select a player from the dropdown list.');
    return;
  }

  socket.emit('playerGuess', { roomId, guess });
  guessInput.value = '';
  selectedPlayer = null;
  submitGuessBtn.disabled = true;
  clearAutocomplete();
}


function requestRematch() {
  if (!myRoomId) {
    console.error('No roomId defined. Cannot request rematch.');
    return;
  }
  rematchBtn.disabled = true;
  rematchBtn.textContent = 'Waiting for opponent...';
  socket.emit('requestRematch', { roomId: myRoomId });
}


function resetGameUI() {
  gameStarted = true;
  gameOver = false;

  // Clear old timers
  if (window.timerInterval) {
    clearInterval(window.timerInterval);
    window.timerInterval = null;
  }

  guessInput.disabled = true;
  submitGuessBtn.disabled = true;
  guessInput.value = '';
  clearGuessError();
  clearAutocomplete();

  // Reset rematch button visibility and style
  rematchBtn.style.display = 'none';
  rematchBtn.disabled = false;
  rematchBtn.textContent = 'Rematch';
  rematchBtn.style.backgroundColor = '';

  // Reset UI parts
  messagesEl.innerHTML = '';
  messagesEl.style.display = 'block';

  // ‚úÖ CRITICAL: Reset card spread animation BEFORE clearing cards
  resetCardSpread();

  // Clear stored headshots for new game
  storedHeadshots.clear();

  successfulGuesses.length = 0;
  document.getElementById('card-deck').innerHTML = '';
  renderSuccessfulGuesses();

  currentPlayerNameEl.textContent = 'Loading...';
  timerEl.textContent = '30';

  // Show/hide game areas as needed
  waitingRoom.style.display = 'none';
  gameArea.style.display = 'block';
  document.getElementById('turnSection').style.display = 'block';

  // Hide game over container
  const gameOverContainer = document.getElementById('gameOverContainer');
  gameOverContainer.innerHTML = '';
  gameOverContainer.style.display = 'none';

  // Clear persistent rematch message
  const messageContainer = document.getElementById('messageContainer');
  if (messageContainer) {
    messageContainer.innerHTML = '';
  }
}



function showGuessError(message) {
  showMessage(message, 'error');
}


 function clearGuessError() {
    const container = document.getElementById('messageContainer');
    container.innerHTML = '';
  }

  function showMessage(message, type = 'info', persist = false) {
    const container = document.getElementById('messageContainer');
    container.innerHTML = '';

    const div = document.createElement('div');
    div.textContent = message;
    div.classList.add('message');

    if (type === 'error') div.classList.add('error');

    container.appendChild(div);

    if (!persist) {
      setTimeout(() => {
        div.classList.add('fade-out');
        setTimeout(() => container.innerHTML = '', 1000);
      }, 3000);
    }
  }




  function clearAutocomplete() {
    autocompleteList.innerHTML = '';
    autocompleteList.style.display = 'none';
  }


function showAutocompleteSuggestions(suggestions) {
  const list = document.getElementById('autocomplete-list');
  list.innerHTML = '';

  if (suggestions.length === 0) {
    list.style.display = 'none';  // Hide when empty
    return;
  }

  list.style.display = 'block'; // Show when populated

  suggestions.forEach(suggestionEl => {
    // suggestionEl is an element, append it directly
    list.appendChild(suggestionEl);
  });
}


function renderSuccessfulGuesses() {
  const deckContainer = document.getElementById('card-deck');
  if (!deckContainer || !Array.isArray(successfulGuesses)) return;

  deckContainer.innerHTML = '';
  const reversedGuesses = [...successfulGuesses].reverse();

  reversedGuesses.forEach((guessObj, index) => {
    const name = guessObj?.name || '';
    const isLeadoff = !!guessObj?.isLeadoff;
    const guesser = guessObj?.guesser || '';
    const sharedTeams = Array.isArray(guessObj?.sharedTeams) ? guessObj.sharedTeams : [];
    const headshotUrl = guessObj?.headshot_url || DEFAULT_PLAYER_IMAGE;

    console.log(`Card ${index}: ${name}, headshot: ${headshotUrl}`);

    if (!name) return;

    const card = document.createElement('div');
    card.className = 'player-card';
    
    // Set the headshot URL as a CSS custom property
    card.style.setProperty('--headshot-url', `url("${headshotUrl}")`);
    card.setAttribute('data-headshot', headshotUrl);
    
    if (index === 0 && successfulGuesses.length > 1) {
      card.classList.add('new-card');
    }
    
    if (isLeadoff) {
      card.classList.add('leadoff');
    } else if (guesser === myUsername) {
      card.classList.add('your-guess');
    } else {
      card.classList.add('opponent-guess');
    }

    // Rest of the card creation code remains the same...
    const headerEl = document.createElement('div');
    headerEl.className = 'card-header';
    headerEl.textContent = isLeadoff ? 'Leadoff Player' : 'Teammate';
    card.appendChild(headerEl);

    const nameEl = document.createElement('div');
    nameEl.className = 'card-player-name';
    nameEl.textContent = name;
    card.appendChild(nameEl);

    const connectionEl = document.createElement('div');
    connectionEl.className = 'card-connection';
    
    if (!isLeadoff && sharedTeams.length > 0) {
      const teamStrings = sharedTeams.map(team => {
        if (typeof team === 'object' && team.team && team.years) {
          return `${team.team} (${team.years})`;
        }
        return team;
      });
      
      connectionEl.innerHTML = `<strong>Connected via:</strong><br>${teamStrings.join('<br>')}`;
    } else if (isLeadoff) {
      connectionEl.innerHTML = '<strong>Starting Player</strong><br>Begin the chain!';
    }
    card.appendChild(connectionEl);

    const footerEl = document.createElement('div');
    footerEl.className = 'card-footer';
    if (isLeadoff) {
      footerEl.textContent = 'Game Start';
    } else if (guesser === myUsername) {
      footerEl.textContent = 'Guessed by You';
    } else {
      footerEl.innerHTML = `Guessed by<br>${guesser}`;
    }
    card.appendChild(footerEl);

    deckContainer.appendChild(card);
  });
}





function setupGlobalNavListeners() {
  // Home navigation with game leave logic
  const navHomeLink = document.getElementById('nav-home-link');
  if (navHomeLink) {
    navHomeLink.addEventListener('click', (e) => {
      e.preventDefault();
      isLeavingGame = true;
      if (socket && socket.connected) {
        socket.emit('leaveGame');
      }
      navigateTo('/home');
    });
  }

  // Sign out button
  const navSignoutBtn = document.getElementById('nav-signout-btn');
if (navSignoutBtn) {
  navSignoutBtn.addEventListener('click', async () => {
    // Check if user is in an active game
    if (gameStarted && !gameOver && socket && socket.connected) {
      // Emit a specific sign-out event to give opponent the win
      socket.emit('playerSignedOut', { 
        roomId: myRoomId || roomId,
        username: myUsername,
        reason: 'signed_out'
      });
    }
    
    // Set leaving game flag to prevent reconnection attempts
    isLeavingGame = true;
    localStorage.setItem('isLeavingGame', 'true');
    
    // Sign out from Supabase
    await window.supabase.auth.signOut();
    
    // Clear game state
    gameStarted = false;
    gameOver = true;
    myRoomId = null;
    roomId = null;
    
    // Update UI and navigate
    updateNavUserState();
    navigateTo('/signup');
  });
}

  // Sign in button
  const navSigninBtn = document.getElementById('nav-signin-btn');
  if (navSigninBtn) {
    navSigninBtn.addEventListener('click', () => {
      window.location.href = '/signin.html';
    });
  }
}

function showRouteSection(path) {
  const allSections = document.querySelectorAll('section[data-route]');
  let matched = false;

  allSections.forEach(section => {
    const route = section.getAttribute('data-route');
    if (route === path) {
      section.classList.remove('hidden');
      matched = true;
    } else {
      section.classList.add('hidden');
    }
  });

  // Fallback if no matching route found
  if (!matched) {
    const defaultSection = document.querySelector('section[data-route="/signup"]');
    if (defaultSection) {
      defaultSection.classList.remove('hidden');
    }
  }
}

function updateUIForRoute(path) {
   if (path !== currentRoute) {
    console.debug('[updateUIForRoute] Skipped because stale:', path, 'Expected:', currentRoute);
    return;
  }

  console.debug('[updateUIForRoute] Handling:', path);
 if (path === '/home') {
  console.log('[DEBUG] updateUIForRoute: Handling /home');

  updateNavUserState();

  // ‚úÖ Mark that you are intentionally leaving
  if (socket && socket.connected) {
    isLeavingGame = true;
    socket.emit('leaveGame');
  }

  // üßπ Clear local game state
  gameStarted = false;
  gameOver = true;
  roomId = null;
  myRoomId = null;
  isPrivateGame = false;
  selectedPlayer = null;
  successfulGuesses = [];

  // ‚úÖ DO NOT reset isLeavingGame here!
  // Let it stay true until you explicitly join or navigate away.

  // Update welcome
  const welcomeEl = document.getElementById('home-welcome');
  if (welcomeEl && myUsername) {
    welcomeEl.textContent = `Welcome, ${myUsername}! Choose your game mode below.`;
  }
}



if (path === '/waiting') {
  if (isLeavingGame) {
    console.log('[DEBUG] updateUIForRoute: Skipping /waiting because isLeavingGame is true');
    return;  // üõë Prevent accidental waiting room navigation
  }

   // ‚úÖ Always set a status message, with fallback
  const waitingStatus = document.getElementById('waitingStatus');
  if (waitingStatus) {
    if (isPrivateGame) {
      waitingStatus.textContent = 'Waiting for a friend to join...';
    } else {
      waitingStatus.textContent = 'Looking for an opponent...';
    }
  }

  const codeEl = document.getElementById('displayRoomCode');
  const inviteWrapper = document.getElementById('inviteLinkWrapper');
  const inviteInput = document.getElementById('inviteLink');

  if (codeEl) {
    if (isPrivateGame && myRoomId) {
      // Extract just the readable part after "room-"
      const displayCode = myRoomId.replace('room-', '').substring(0, 8);
      codeEl.textContent = displayCode;
      codeEl.style.display = 'block';
    } else {
      codeEl.style.display = 'none';
    }
  }

 if (inviteWrapper && inviteInput) {
    if (isPrivateGame && myRoomId) {
      const inviteUrl = `${window.location.origin}?room=${myRoomId}`;
      inviteInput.value = inviteUrl;
      inviteWrapper.style.display = 'block';
    } else {
      inviteWrapper.style.display = 'none';
    }
  }
}


  // Guess container visibility
  const guessContainer = document.getElementById('successful-guesses-container');
  if (guessContainer) {
    guessContainer.style.display = (path === '/play' || path === '/gameover') ? 'block' : 'none';
  }

  // Scoreboard visibility
  const scoreboard = document.getElementById('scoreboardSection');
  if (scoreboard) {
    if (path === '/play' || path === '/gameover') {
      scoreboard.classList.remove('hidden');
    } else {
      scoreboard.classList.add('hidden');
    }
  }
}



function setupFormListeners() {
  // Signup form
  const signupForm = document.getElementById('signupForm');
  if (signupForm) {
    signupForm.addEventListener('submit', signUp);
    console.log('[DEBUG] signupForm listener attached');
  } else {
    console.warn('[WARN] signupForm not found - may not be on signup route');
  }

  // Signin form
  const signinForm = document.getElementById('signinForm');
  if (signinForm) {
    signinForm.addEventListener('submit', signIn);
    console.log('[DEBUG] signinForm listener attached');
  } else {
    console.warn('[WARN] signinForm not found - may not be on signin route');
  }

  // Reset password form
  const resetForm = document.getElementById('resetForm');
  if (resetForm) {
    resetForm.addEventListener('submit', resetPassword);
    console.log('[DEBUG] resetForm listener attached');
  } else {
    console.warn('[WARN] resetForm not found - may not be on reset route');
  }

  // Reset password button (not a form)
  const resetBtn = document.getElementById('resetBtn');
if (resetBtn) {
  resetBtn.addEventListener('click', resetPassword);
  console.log('[DEBUG] resetBtn listener attached');
} else {
  console.warn('[WARN] resetBtn not found - may not be on reset route');
}

// Update password button (not a form)
const updatePasswordBtn = document.getElementById('updatePasswordBtn');
if (updatePasswordBtn) {
  updatePasswordBtn.addEventListener('click', updatePassword);
  console.log('[DEBUG] updatePasswordBtn listener attached');
} else {
  console.warn('[WARN] updatePasswordBtn not found - may not be on update-password route');
}

  // Update password form
  const updatePasswordForm = document.getElementById('updatePasswordForm');
  if (updatePasswordForm) {
    updatePasswordForm.addEventListener('submit', updatePassword);
    console.log('[DEBUG] updatePasswordForm listener attached');
  } else {
    console.warn('[WARN] updatePasswordForm not found - may not be on update-password route');
  }

  // Username form (if you have one for setting username)
  const usernameForm = document.getElementById('usernameForm');
  if (usernameForm) {
    usernameForm.addEventListener('submit', setUsername);
    console.log('[DEBUG] usernameForm listener attached');
  } else {
    console.warn('[WARN] usernameForm not found - may not be on username route');
  }
}



function handleGoHome() {
  console.debug('[CLIENT] handleGoHome called');

  // ‚úÖ Mark that you‚Äôre intentionally leaving ‚Äî and persist it!
  isLeavingGame = true;
  localStorage.setItem('isLeavingGame', 'true');

  // ‚úÖ Tell server if in an active game
  if (socket && socket.connected && gameStarted && !gameOver) {
    socket.emit('leaveGame');
  }

  // ‚úÖ Always clear local game state
  myRoomId = null;
  roomId = null;
  isPrivateGame = false;
  gameStarted = false;
  gameOver = true;
  selectedPlayer = null;
  successfulGuesses = [];

  localStorage.removeItem('privateRoomId');

  navigateTo('/home');
}

function setupCopyInviteListeners() {
  const copyInviteBtn = document.getElementById('copyInviteBtn');
  const copyToast = document.getElementById('copyToast');
  const inviteInput = document.getElementById('inviteLink');

  if (!copyInviteBtn || !copyToast || !inviteInput) {
    // Elements don't exist on this route, skip setup
    return;
  }

  copyInviteBtn.addEventListener('click', () => {
    navigator.clipboard.writeText(inviteInput.value)
      .then(() => {
        copyToast.style.display = 'block';
        copyInviteBtn.disabled = true; // Disable to prevent spamming

        // Hide toast after 2 seconds
        setTimeout(() => {
          copyToast.style.display = 'none';
          copyInviteBtn.disabled = false; // Re-enable button
        }, 2000);
      })
      .catch(err => {
        alert('Failed to copy link. Please copy it manually.');
        console.error('Clipboard copy failed:', err);
      });
  });
}




async function handleAuthSuccess() {
  const { data: { user }, error } = await supabase.auth.getUser();
  if (error || !user) {
    console.error('No user signed in');
    navigateTo('/signup');
    return;
  }

  const username = user.user_metadata?.username || null;

  if (!username) {
    console.error('No username found in user_metadata!');
    navigateTo('/signup');
    return;
  }

  // Try updating profiles row, but don‚Äôt block navigation if it fails
  const { error: updateError } = await supabase
    .from('profiles')
    .update({ username })
    .eq('id', user.id);

  if (updateError) {
    console.warn('Warning: Error updating profile:', updateError.message);
  } else {
    console.log('‚úÖ Username saved to profiles:', username);
  }

  myUsername = username;
  localStorage.setItem('username', myUsername);

  // Clear URL hash to remove confirmation tokens
  history.replaceState(null, '', window.location.pathname);

  navigateTo('/home');
}


async function signOut() {
  const { error } = await window.supabase.auth.signOut();
  if (error) {
    alert('Sign out error: ' + error.message);
    return;
  }
  alert('Signed out!');
  showUser();
}


async function updateNavUserState(session) {
  const usernameDiv = document.getElementById('nav-username');
  const signinBtn = document.getElementById('nav-signin-btn');
  const signoutBtn = document.getElementById('nav-signout-btn');
  const homeLink = document.getElementById('nav-home-link');

  if (!usernameDiv || !signinBtn || !signoutBtn || !homeLink) return;

  if (!session || !session.user) {
    // Not logged in
    usernameDiv.style.display = 'none';
    signoutBtn.style.display = 'none';
    homeLink.style.display = 'none';
    
    // Only show sign in button if NOT on signup/signin pages
    if (currentRoute === '/signup' || window.location.pathname === '/signup' || 
        currentRoute === '/signin' || window.location.pathname === '/signin' ||
        currentRoute === '/reset' || currentRoute === '/verify' || 
        currentRoute === '/confirmed' || currentRoute === '/reset-confirmed' ||
        currentRoute === '/update-password') {
      signinBtn.style.display = 'none';
    } else {
      signinBtn.style.display = 'inline-block';
    }
  } else {
    // Logged in
    const user = session.user;
    usernameDiv.textContent = `Hello, ${user.user_metadata?.username || user.email}`;
    usernameDiv.style.display = 'inline-block';
    signinBtn.style.display = 'none';
    signoutBtn.style.display = 'inline-block';
    homeLink.style.display = 'inline-block';
  }
}


async function resetPassword() {
  const emailInput = document.getElementById('reset-email');
  const email = emailInput.value.trim();

  if (!email) {
    alert('Please enter your email address.');
    return;
  }

  try {
    const { data, error } = await supabase.auth.resetPasswordForEmail(email, {
      redirectTo: `${window.location.origin}/update-password`
    });

    if (error) {
      console.error('[ERROR] Supabase reset error:', error.message);
      alert('Error sending reset email: ' + error.message);
      return;
    }

    console.log('[INFO] Password reset email sent:', data);
    navigateTo('/reset-confirmed'); // Switch to your "Check your email" screen!
  } catch (err) {
    console.error('[ERROR] Unexpected:', err);
    alert('An unexpected error occurred.');
  }
}

async function updatePassword() {
  const newPasswordInput = document.getElementById('new-password');
  const newPassword = newPasswordInput.value.trim();

  if (!newPassword) {
    alert('Please enter a new password.');
    return;
  }

  const { data, error } = await supabase.auth.updateUser({
    password: newPassword
  });

  if (error) {
    console.error('[ERROR] Failed to update password:', error.message);
    alert('Error updating password: ' + error.message);
    return;
  }

  console.log('[INFO] Password updated:', data);

  // ‚úÖ Redirect the user back to sign in, or show success
  alert('Password updated successfully! Please sign in with your new password.');
  navigateTo('/signup');
}





function setupAutocompleteListeners() {
  const guessInput = document.getElementById('guessInput');
  const submitGuessBtn = document.getElementById('submitGuessBtn');
  
  if (!guessInput || !submitGuessBtn) {
    console.warn('Autocomplete elements not found');
    return;
  }

  guessInput.addEventListener('input', function() {
    const val = this.value.trim();
    clearAutocomplete();
    selectedPlayer = null;
    submitGuessBtn.disabled = true;

    if (!val) {
      showAutocompleteSuggestions([]);
      return;
    }

    if (fetchTimeout) clearTimeout(fetchTimeout);

    fetchTimeout = setTimeout(async () => {
      try {
        const res = await fetch(`/players?q=${encodeURIComponent(val)}`);
        if (!res.ok) throw new Error('Network response not ok');

        const results = await res.json();
        if (results.length === 0) {
          showAutocompleteSuggestions([]);
          return;
        }

        const suggestions = results.map(player => {
          const wrapper = document.createElement('div');
          wrapper.className = 'autocomplete-item';

          const nameSpan = document.createElement('span');
          nameSpan.textContent = player.player_name;

          const yearsSpan = document.createElement('span');
          yearsSpan.className = 'career-years';
          yearsSpan.textContent = ` ${player.first_year || '?'}‚Äì${player.last_year || '?'}`;
          yearsSpan.style.fontSize = '0.8em';
          yearsSpan.style.color = 'gray';
          yearsSpan.style.marginLeft = '5px';

          wrapper.appendChild(nameSpan);
          wrapper.appendChild(yearsSpan);

          wrapper.addEventListener('click', () => {
            guessInput.value = player.player_name;
            selectedPlayer = player.player_name;
            submitGuessBtn.disabled = false;
            clearAutocomplete();
          });

          return wrapper;
        });

        showAutocompleteSuggestions(suggestions);

      } catch (err) {
        console.error('Autocomplete fetch error:', err);
        showAutocompleteSuggestions([]);
      }
    }, 300);
  });

  guessInput.addEventListener('change', () => {
    if (guessInput.value !== selectedPlayer) {
      selectedPlayer = null;
      submitGuessBtn.disabled = true;
    }
  });
}


function initializeAuthStateListener() {
  if (window.supabase && window.supabase.auth) {
    window.supabase.auth.onAuthStateChange((event, session) => {
      updateNavUserState(session);
    });
  }
}


async function loadPlayerStats() {
  const el = document.getElementById('player-history');
  if (!el) return;

  const { data: sessionData, error: sessionError } = await supabase.auth.getSession();
  if (sessionError || !sessionData?.session?.user) {
    el.textContent = 'Games Played: 0 | Wins: 0 | Losses: 0';
    return;
  }

  const userId = sessionData.session.user.id;

  // ‚úÖ First, try to get existing stats
  let { data, error } = await supabase
    .from('user_stats')
    .select('games_played, wins, losses')
    .eq('user_id', userId)
    .single();

  // ‚úÖ If no row exists, create one
  if (error && error.code === 'PGRST116') { // No rows returned
    console.log('[loadPlayerStats] Creating new stats row for user:', userId);
    
    const { data: newData, error: insertError } = await supabase
      .from('user_stats')
      .insert({ 
        user_id: userId, 
        games_played: 0, 
        wins: 0, 
        losses: 0 
      })
      .select('games_played, wins, losses')
      .single();

    if (insertError) {
      console.error('[loadPlayerStats] Failed to create stats row:', insertError);
      el.textContent = 'Games Played: 0 | Wins: 0 | Losses: 0';
      return;
    }
    
    data = newData;
  } else if (error) {
    console.error('[loadPlayerStats] Unexpected error:', error);
    el.textContent = 'Games Played: 0 | Wins: 0 | Losses: 0';
    return;
  }

  el.textContent = `Games Played: ${data.games_played || 0} | Wins: ${data.wins || 0} | Losses: ${data.losses || 0}`;
}




///////////////////////////////////////////////
// 3. Socket handlers (outside DOMContentLoaded)
function setupSocketHandlers() {
  socket.removeAllListeners();

socket.on('connect', () => {
  console.log('[safeEmit] Socket connected ‚Äî flushing emitQueue');

  if (myUserId && myUsername) {
    socket.emit('userSignedIn', { userId: myUserId, username: myUsername });
  }


  flushEmitQueue();
});


socket.on('disconnect', (reason) => {
  console.log('[DEBUG] Socket disconnected:', reason);
  
  // If this was an intentional sign-out, handle it immediately
  if (isLeavingGame || localStorage.getItem('isLeavingGame') === 'true') {
    // ‚úÖ FIXED: Replace the missing handlePlayerLeaving function
    if (gameStarted && !gameOver && myRoomId && myUsername) {
      socket.emit('playerSignedOut', { 
        roomId: myRoomId,
        username: myUsername,
        reason: 'signed_out'
      });
    }
  } else {
    // For accidental disconnects, give a grace period
    setTimeout(() => {
      if (!socket.connected) {
        // ‚úÖ FIXED: Replace the missing handlePlayerLeaving function
        if (gameStarted && !gameOver && myRoomId && myUsername) {
          socket.emit('playerSignedOut', { 
            roomId: myRoomId,
            username: myUsername,
            reason: 'disconnected'
          });
        }
      }
    }, 10000); // 10 second grace period
  }
});


socket.on('gameStarted', async (data) => {
    if (isLeavingGame) {
      console.log('[DEBUG] Ignoring gameStarted because isLeavingGame === true');
      return;
    }

    // ‚úÖ Prevent processing if game is already started
  if (gameStarted && !gameOver) {
    console.log('[DEBUG] Game already started, ignoring duplicate gameStarted event');
    return;
  }

  // ‚úÖ Add a timestamp check to prevent rapid duplicates
  const now = Date.now();
  if (window.lastGameStartTime && (now - window.lastGameStartTime) < 1000) {
    console.log('[DEBUG] Ignoring rapid duplicate gameStarted event');
    return;
  }
  window.lastGameStartTime = now;

    console.log('[CLIENT] Received gameStarted event:', data);
  });


socket.on('playersUpdate', (count) => {
  console.log('[DEBUG] playersUpdate received:', count);

  if (isLeavingGame) {
    console.log('[DEBUG] playersUpdate skipped: isLeavingGame is true');
    return;
  }

  const statusDiv = document.getElementById('statusDiv');
  const rematchBtn = document.getElementById('rematchBtn');

  if (statusDiv) {
    statusDiv.textContent = `Players in room: ${count}`;
  } else {
    console.warn('statusDiv not found in DOM');
  }

  if (rematchBtn) {
    if (count < 2) {
      rematchBtn.style.display = 'none';
      navigateTo('/waiting');
    } else {
      navigateTo('/play');
    }
  } else {
    console.warn('rematchBtn not found in DOM');
  }
});





socket.on('matched', ({ roomId, opponent }) => {
  if (isLeavingGame || localStorage.getItem('isLeavingGame') === 'true') {
    console.log('[DEBUG] Ignoring matched event because isLeavingGame is true');
    return;
  }

  if (gameStarted && !gameOver) return;

  // ‚úÖ Once matched, clear stale flags
  isLeavingGame = false;
  localStorage.removeItem('isLeavingGame');

  myRoomId = roomId;
  opponentName = opponent;

  statusDiv.textContent = `Matched with ${opponent}! Joining game...`;

  navigateTo('/waiting');

  // ‚úÖ Include userId!
  socket.emit('joinGame', { 
    roomId: myRoomId, 
    username: myUsername,
    userId: myUserId   // <-- this part is critical now
  });
});





// 2. Game Lifecycle
socket.on('gameStarted', async (data) => {
  if (isLeavingGame) {
    console.log('[DEBUG] Ignoring gameStarted because isLeavingGame === true');
    return;
  }

  console.log('[CLIENT] Received gameStarted event:', data);

  resetCardSpread();

  gameStarted = true;
  gameOver = false;

  // Clear previous headshot storage for new game
  storedHeadshots.clear();

  const leadoffPlayer = data.leadoffPlayer || null;
  leadoffPlayerName = leadoffPlayer?.player_name || null;

  if (window.timerInterval) {
    clearInterval(window.timerInterval);
    window.timerInterval = null;
    console.warn('[CLIENT] Cleared leftover timer before starting new one.');
  }

  guessInput.disabled = true;
  submitGuessBtn.disabled = true;
  guessInput.value = '';
  clearGuessError();
  clearAutocomplete();

  rematchBtn.style.display = 'none';
  rematchBtn.disabled = false;
  rematchBtn.textContent = 'Rematch';

  messagesEl.innerHTML = '';
  messagesEl.style.display = 'block';

  // ‚úÖ Initialize successfulGuesses with leadoff player immediately
  successfulGuesses = [];
  if (leadoffPlayer && leadoffPlayer.player_name) {
    // Store leadoff headshot
    if (leadoffPlayer.headshot_url) {
      storedHeadshots.set(leadoffPlayer.player_name, leadoffPlayer.headshot_url);
    }
    
    const leadoffGuess = {
      guesser: 'Leadoff',
      name: leadoffPlayer.player_name,
      isLeadoff: true,
      headshot_url: leadoffPlayer.headshot_url || DEFAULT_PLAYER_IMAGE
    };
    
    successfulGuesses.push(leadoffGuess);
    
    // Store leadoff data globally for preservation
    window.leadoffPlayerData = {
      name: leadoffPlayer.player_name,
      headshot_url: leadoffPlayer.headshot_url || DEFAULT_PLAYER_IMAGE
    };
  }

  console.log('[CLIENT] successfulGuesses after reset:', successfulGuesses);
  renderSuccessfulGuesses();

  // ‚úÖ Update current player name (NBA player)
  currentPlayerNameEl.textContent = data.currentPlayerName || '???';

  // ‚úÖ Update current player headshot
  if (currentPlayerHeadshotEl) {
    currentPlayerHeadshotEl.src = data.currentPlayerHeadshotUrl || DEFAULT_PLAYER_IMAGE;
    currentPlayerHeadshotEl.alt = (data.currentPlayerName || 'Unknown') + ' Headshot';
  }

  // ‚úÖ Update player labels
  const playerYouEl = document.getElementById('playerYou');
  const playerOpponentEl = document.getElementById('playerOpponent');
  if (playerOpponentEl && data.opponentName) {
    playerOpponentEl.textContent = data.opponentName;
    opponentName = data.opponentName;
  }
  if (playerYouEl) playerYouEl.textContent = myUsername || 'You';

  // ‚úÖ Correct: use currentPlayerUsername, not currentPlayerName!
  const isYourTurn = data.currentPlayerUsername === myUsername;

  if (playerYouEl && playerOpponentEl) {
    playerYouEl.classList.toggle('active-turn', isYourTurn);
    playerOpponentEl.classList.toggle('active-turn', !isYourTurn);
  }

  timerEl.textContent = data.timeLeft || 15;
  console.log('[CLIENT] Timer initialized at:', data.timeLeft || 15);

  console.log('[DEBUG] Navigating to /play...');
  await navigateTo('/play');
  console.debug('[DEBUG] Waiting for scoreboard readiness...');
  await waitForScoreboard();
  socket.emit('getMatchStats');
});





socket.on('matchStats', (stats) => {
  console.log('[CLIENT] Updated matchStats:', stats);
  updateSplitScoreboard(stats, myUsername, opponentName);
});



socket.on('gameOver', (data) => {
  console.log('[DEBUG] gameOver received:', data);

  // ‚úÖ If I intentionally left, skip handling
  if (isLeavingGame) {
    console.debug('[DEBUG] Ignoring gameOver because isLeavingGame === true');
    isLeavingGame = false; // reset for next time
    return; // skip all the rest
  }

  gameOver = true;

  // Stop input & timer
  guessInput.disabled = true;
  submitGuessBtn.disabled = true;

  if (window.timerInterval) {
    clearInterval(window.timerInterval);
    window.timerInterval = null;
  }
  timerEl.textContent = '';

  // Ensure myUsername & opponentName
  if (!myUsername && data.winnerName && data.loserName) {
    if (data.role === 'winner') {
      myUsername = data.winnerName;
      opponentName = data.loserName;
    } else {
      myUsername = data.loserName;
      opponentName = data.winnerName;
    }
  } else if (!opponentName && data.winnerName && data.loserName) {
    opponentName = (myUsername === data.winnerName) ? data.loserName : data.winnerName;
  }

  // Show game over container
  const container = document.getElementById('gameOverContainer');
  container.style.display = 'flex';
  container.innerHTML = '';

  const gameOverMsg = document.createElement('div');
  gameOverMsg.style.fontSize = '1.5rem';
  gameOverMsg.style.textAlign = 'center';
  gameOverMsg.style.fontWeight = 'bold';
  gameOverMsg.style.marginTop = '1rem';

  if (data.message) {
    gameOverMsg.textContent = data.message;
  } else if (data.reason === 'opponent_left') {
    const opponent = opponentName || 'Your opponent';
    gameOverMsg.textContent = `${opponent} left the game.`;
  } else {
    gameOverMsg.textContent = 'Game Over!';
  }

  if (data.role === 'winner') {
    gameOverMsg.style.color = 'green';
  } else if (data.role === 'loser') {
    gameOverMsg.style.color = 'darkred';
  } else {
    gameOverMsg.style.color = 'gray';
  }

  container.appendChild(gameOverMsg);

  const resultsDiv = document.getElementById('gameOverResults');
  if (resultsDiv) {
    if (data.winnerName && data.loserName) {
      resultsDiv.innerHTML = `
        <p><strong>Winner:</strong> ${data.winnerName}</p>
        <p><strong>Loser:</strong> ${data.loserName}</p>
      `;
    } else {
      resultsDiv.innerHTML = '';
    }
  }

  if (data.canRematch === false || data.reason === 'opponent_left') {
    rematchBtn.style.display = 'none';
  } else {
    rematchBtn.style.display = 'block';
    rematchBtn.disabled = false;
    rematchBtn.textContent = 'Rematch';
  }

  // Let server 'matchStats' handle scoreboard update
  navigateTo('/gameover');

  triggerGameEndCardSpread();
});




// 3. Turn Management
socket.on('yourTurn', (data) => {
  navigateTo('/play');

  const turnSection = document.getElementById('turnSection');

  turnSection.classList.add('your-turn');
  turnSection.classList.remove('opponent-turn');

  document.getElementById('guessControls').style.display = 'block';
  guessInput.disabled = false;
  submitGuessBtn.disabled = !guessInput.value.trim();

  // ‚úÖ NBA player to guess:
  currentPlayerNameEl.textContent = data.currentPlayerName || 'Your Turn';

  // ‚úÖ Update headshot too:
  if (currentPlayerHeadshotEl) {
    currentPlayerHeadshotEl.src = data.currentPlayerHeadshotUrl || DEFAULT_PLAYER_IMAGE;
    currentPlayerHeadshotEl.alt = `${data.currentPlayerName || 'Player'} Headshot`;
  }

  // ‚úÖ Store current player headshot for when they get guessed
  if (data.currentPlayerName && data.currentPlayerHeadshotUrl) {
  storedHeadshots.set(data.currentPlayerName, data.currentPlayerHeadshotUrl);
  console.log('Stored headshot for:', data.currentPlayerName, data.currentPlayerHeadshotUrl);
}

  timerEl.textContent = data.timeLeft || 15;

  turnSection.style.display = 'block';
  messagesEl.style.display = 'block';

  showMessage(data.message || "It's your turn to guess!", 'info');


 const turnPromptText = document.getElementById('turnPromptText');
if (turnPromptText) {
  turnPromptText.innerHTML = `
  <div>Name any teammate of:</div>
  <div class="player-info">
    <img id="currentPlayerHeadshot" src="${data.currentPlayerHeadshotUrl || DEFAULT_PLAYER_IMAGE}" alt="${data.currentPlayerName || 'Player'} Headshot" width="60" height="60" style="border-radius: 50%; object-fit: cover;"/>
    <strong class="turn-player-name" id="currentPlayerName">${data.currentPlayerName}</strong>
  </div>
`;
}

  // ‚úÖ Highlight the current player in playersDisplay
  const playerYouEl = document.getElementById('playerYou');
  const playerOpponentEl = document.getElementById('playerOpponent');

  if (playerYouEl && playerOpponentEl) {
    playerYouEl.classList.add('active-turn');
    playerOpponentEl.classList.remove('active-turn');
  }
});

socket.on('opponentTurn', (data) => {
  navigateTo('/play');

  const turnSection = document.getElementById('turnSection');

  turnSection.classList.remove('your-turn');
  turnSection.classList.add('opponent-turn');

  document.getElementById('guessControls').style.display = 'none';
  guessInput.disabled = true;
  submitGuessBtn.disabled = true;

  // ‚úÖ NBA player to guess:
  currentPlayerNameEl.textContent = data.currentPlayerName || "Opponent's Turn";

  // ‚úÖ Update headshot too:
  if (currentPlayerHeadshotEl) {
    currentPlayerHeadshotEl.src = data.currentPlayerHeadshotUrl || DEFAULT_PLAYER_IMAGE;
    currentPlayerHeadshotEl.alt = `${data.currentPlayerName || 'Player'} Headshot`;
  }

  // ‚úÖ Store current player headshot for when they get guessed
  if (data.currentPlayerName && data.currentPlayerHeadshotUrl) {
  storedHeadshots.set(data.currentPlayerName, data.currentPlayerHeadshotUrl);
  console.log('Stored headshot for:', data.currentPlayerName, data.currentPlayerHeadshotUrl);
}


  const turnPromptText = document.getElementById('turnPromptText');
if (turnPromptText) {
  turnPromptText.innerHTML = `
  <div>${opponentName || 'Your opponent'} is naming a teammate of:</div>
  <div class="player-info">
    <img id="currentPlayerHeadshot" src="${data.currentPlayerHeadshotUrl || DEFAULT_PLAYER_IMAGE}" alt="${data.currentPlayerName || 'Player'} Headshot" width="60" height="60" style="border-radius: 50%; object-fit: cover;"/>
    <strong class="turn-player-name" id="currentPlayerName">${data.currentPlayerName}</strong>
  </div>
`;
}

  timerEl.textContent = data.timeLeft || '';

  turnSection.style.display = 'block';
  messagesEl.style.display = 'block';

  showMessage(data.message || "Waiting for your opponent to guess...", 'info');

  // Update only the player name text
  const playerNameEl = document.getElementById('currentPlayerName');
  if (playerNameEl) {
    playerNameEl.textContent = data.currentPlayerName;
  }

  // ‚úÖ Highlight the opponent in playersDisplay
  const playerYouEl = document.getElementById('playerYou');
  const playerOpponentEl = document.getElementById('playerOpponent');

  if (playerYouEl && playerOpponentEl) {
    playerYouEl.classList.remove('active-turn');
    playerOpponentEl.classList.add('active-turn');
  }
});





socket.on('message', (msg) => {
  navigateTo('/play'); // Ensure user is on the gameplay page
  showMessage(msg, 'error');
});

socket.on('turnEnded', (data) => {
  console.log('turnEnded currentPlayerHeadshotUrl:', data.currentPlayerHeadshotUrl);
  
  // ‚úÖ CRITICAL: Store the NEW current player's headshot FIRST
  // This is the player who was just guessed and will be on the new card
  if (data.currentPlayerName && data.currentPlayerHeadshotUrl) {
    storedHeadshots.set(data.currentPlayerName, data.currentPlayerHeadshotUrl);
    console.log('Storing NEW current player headshot BEFORE processing:', data.currentPlayerName, data.currentPlayerHeadshotUrl);
  }
  
  navigateTo('/play');

  if (Array.isArray(data.successfulGuesses)) {
    // Now the headshot will be available for the newly added card
    successfulGuesses = data.successfulGuesses.map(guess => {
      const storedHeadshot = storedHeadshots.get(guess.name);
      const updatedGuess = {
        ...guess,
        headshot_url: storedHeadshot || guess.headshot_url || DEFAULT_PLAYER_IMAGE
      };
      
      if (guess.name === leadoffPlayerName || guess.isLeadoff) {
        updatedGuess.isLeadoff = true;
        if (guess.name === leadoffPlayerName && window.leadoffPlayerData) {
          updatedGuess.headshot_url = storedHeadshots.get(guess.name) || window.leadoffPlayerData.headshot_url || DEFAULT_PLAYER_IMAGE;
        }
      }
      
      console.log(`Final headshot for ${guess.name}:`, updatedGuess.headshot_url);
      return updatedGuess;
    });
    
    successfulGuesses = markLeadoffInGuesses(successfulGuesses, leadoffPlayerName);
    renderSuccessfulGuesses();
  }

  if (data.message) {
    showMessage(data.message, data.message.startsWith('Incorrect guess') ? 'error' : 'info');
  }

  // ‚úÖ Save turn state for next turn rendering
  currentPlayerName = data.currentPlayerName || '???';
  currentPlayerHeadshotUrl = data.currentPlayerHeadshotUrl || DEFAULT_PLAYER_IMAGE;
  timeLeft = data.timeLeft || 15;

  renderPlayScreen();
});





function renderPlayScreen() {
  if (currentPlayerNameEl) {
    currentPlayerNameEl.textContent = currentPlayerName;
  }
  if (currentPlayerHeadshotEl) {
    currentPlayerHeadshotEl.src = currentPlayerHeadshotUrl;
    currentPlayerHeadshotEl.alt = `${currentPlayerName} Headshot`;
  }
  if (timerEl) {
    timerEl.textContent = timeLeft;
  }
}





socket.on('timerTick', (data) => {
  timerEl.textContent = data.timeLeft;
});





// When another player requests a rematch
socket.on('rematchRequested', ({ username }) => {
  showMessage(`${username} wants a rematch! Click your Rematch button to accept.`, 'info', true);

 
});

// When rematch actually starts
socket.on('rematchStarted', () => {
  resetGameUI();

  // Clear any rematch prompt message
  const rematchInfo = document.getElementById('rematch-info');
  if (rematchInfo) rematchInfo.remove();

  // Reset rematch button styles
  rematchBtn.disabled = false;
  rematchBtn.style.backgroundColor = ''; // Reset highlight
  rematchBtn.textContent = 'Rematch';

  // ‚úÖ Re-join the same room to trigger new game start
  if (myRoomId && myUsername) {
    console.log('[CLIENT] Rejoining room for rematch:', myRoomId);
    socket.emit('joinGame', {
      roomId: myRoomId,
      username: myUsername,
      userId: myUserId
    });
    socket.emit('getMatchStats');
  } else {
    console.error('[CLIENT] Missing roomId or username for rematch.');
  }
});

  }




// 4. DOMContentLoaded (minimal, focused)
  document.addEventListener('DOMContentLoaded', async () => {
  console.log('[DEBUG] DOMContentLoaded');

  let justConfirmed = false;

  // Initialize all event listeners
  setupAutocompleteListeners();
  setupFormListeners();
  setupAuthTabs();
  initializeAuthStateListener();
  updateNavUserState();
  setupGlobalNavListeners();

  // Cache DOM element references
  statusDiv = document.getElementById('status');
  guessInput = document.getElementById('guessInput');
  submitGuessBtn = document.getElementById('submitGuessBtn');
  rematchBtn = document.getElementById('rematchBtn');
  messagesEl = document.getElementById('messageContainer');
  currentPlayerNameEl = document.getElementById('currentPlayerName');
  currentPlayerHeadshotEl = document.getElementById('currentPlayerHeadshot');
  timerEl = document.getElementById('timer');
  autocompleteList = document.getElementById('autocomplete-list');
  waitingRoom = document.getElementById('waitingRoom');
  gameArea = document.getElementById('gameArea');
  inviteLinkContainer = document.getElementById('inviteLinkContainer');
    // Set initial default image
    if (currentPlayerHeadshotEl) {
      currentPlayerHeadshotEl.src = DEFAULT_PLAYER_IMAGE;
    }
  

  supabase.auth.onAuthStateChange((_event, session) => {
    updateNavUserState(session);
  });

  const urlHash = window.location.hash;
  const searchParams = new URLSearchParams(window.location.search);
  const typeParam = searchParams.get('type');

  console.log('[DEBUG] On load: urlHash:', urlHash, 'typeParam:', typeParam);

  // Handle password recovery separately
if (
  (urlHash.includes('access_token') && urlHash.includes('type=recovery'))
  || (typeParam === 'recovery')
) {
  console.log('[DEBUG] Found password recovery in URL');
  try {
    const { data: { user }, error } = await supabase.auth.getUser();
    if (error) {
      console.error('[ERROR] Password recovery failed:', error.message);
      navigateTo('/signup');
    } else {
      console.log('[DEBUG] Password recovery successful for:', user?.email);
      // Go directly to update password page
      await navigateTo('/update-password');
    }
  } catch (e) {
    console.error('[ERROR] Exception during password recovery:', e);
    navigateTo('/signup');
  }
  if (!socket) {
    socket = io();
    setupSocketHandlers();
  }
  return;
}

// Handle email confirmation (signup/email_confirm only)
if (
  (urlHash.includes('access_token') &&
    (urlHash.includes('type=signup') || urlHash.includes('type=email_confirm')))
  || (typeParam === 'signup' || typeParam === 'email_confirm')
) {
  console.log('[DEBUG] Found email confirmation in URL');
  try {
    const { data: { user }, error } = await supabase.auth.getUser();
    if (error) {
      console.error('[ERROR] Email confirmation failed:', error.message);
    } else {
      console.log('[DEBUG] Email confirmed for:', user?.email);

      myUsername = user.user_metadata?.username || user.email;
      myUserId = user.id;
      localStorage.setItem('username', myUsername);
      localStorage.setItem('userId', myUserId);

      const { data: { session } } = await supabase.auth.getSession();

      await navigateTo('/confirmed');
      await updateNavUserState(session);
    }
  } catch (e) {
    console.error('[ERROR] Exception during email confirmation:', e);
  }
  if (!socket) {
    socket = io();
    setupSocketHandlers();
  }
  return;
}


  // --- 3Ô∏è‚É£ Get current Supabase session ---
  const { data } = await supabase.auth.getSession();
  await updateNavUserState(data.session);

  if (data.session?.user) {
    const user = data.session.user;
    myUsername = user.user_metadata?.username || user.email;
    myUserId = user.id;  // ‚úÖ Save userId
    localStorage.setItem('username', myUsername);
    localStorage.setItem('userId', myUserId);
    console.log('[DEBUG] Username set from session:', myUsername);
    console.log('[DEBUG] User ID set from session:', myUserId);
  } else {
    myUsername = localStorage.getItem('username') || null;
    myUserId = localStorage.getItem('userId') || null;  // ‚úÖ Fallback
    console.log('[DEBUG] Username from localStorage:', myUsername);
    console.log('[DEBUG] User ID from localStorage:', myUserId);
  }

  // --- 4Ô∏è‚É£ Load room info ---
  const params = new URLSearchParams(window.location.search);
  const roomFromUrl = params.get('room');
  if (roomFromUrl) {
    console.log('[DEBUG] Found invite link for room:', roomFromUrl);
    myRoomId = roomFromUrl;
    roomId = roomFromUrl;
    isPrivateGame = true;
    localStorage.setItem('privateRoomId', roomFromUrl);
  } else {
    const savedRoom = localStorage.getItem('privateRoomId');
    if (savedRoom) {
      console.log('[DEBUG] Found saved private room:', savedRoom);
      myRoomId = savedRoom;
      roomId = savedRoom;
      isPrivateGame = true;
    }
  }

  console.log('[DEBUG] Final state before routing:', {
    myUsername,
    myUserId,  // ‚úÖ Add to debug
    myRoomId,
    isPrivateGame,
    isLeavingGame,
  });

  window.addEventListener('popstate', () => {
    navigateTo(window.location.pathname, { skipPush: true });
  });

  window.addEventListener('beforeunload', (e) => {
    if (gameStarted && !gameOver && socket && socket.connected) {
      isLeavingGame = true;
      socket.emit('playerSignedOut', {
        roomId: myRoomId || roomId,
        username: myUsername,
        userId: myUserId,  // ‚úÖ Include if helpful
        reason: 'page_closed'
      });
    }
  });

  // --- 5Ô∏è‚É£ Determine initial route ---
  if (!myUsername) {
    navigateTo('/signup');
  } else if (isLeavingGame) {
    console.log('[DEBUG] Routing to /home because isLeavingGame=true');
    navigateTo('/home');
  } else if (myRoomId && !isLeavingGame && localStorage.getItem('isLeavingGame') !== 'true') {
    socket.emit('joinGame', {
      roomId: myRoomId,
      username: myUsername,
      userId: myUserId   // ‚úÖ Always emit userId
    });
    navigateTo('/waiting');
  } else {
    navigateTo('/home');
  }
});

</script>


















</body>
</html>