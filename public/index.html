<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>NBA Teammate Game</title>
  <script src="https://cdn.socket.io/4.6.1/socket.io.min.js" crossorigin="anonymous"></script>
  <script type="module">
  import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm'

  const SUPABASE_URL = 'https://rbjdlzgptvpfsnkakasj.supabase.co'
  const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJiamRsemdwdHZwZnNua2FrYXNqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg5ODYxMzksImV4cCI6MjA2NDU2MjEzOX0.U0EhIpOaKrHQmAJHcCBVJLKDGEW-m91eNj2bWRejYpk'
  const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY)

  window.supabase = supabase // Expose for later use
</script>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

 <style>
/* Revert to original site-wide styling */
  body {
    font-family: Arial, sans-serif;
    max-width: 600px;
    margin: auto;
    padding: 1rem;
    line-height: 1.5;
    background-color: #f9f9f9;
    color: #222;
  }

  h1, h2, h3 {
    text-align: center;
    margin-bottom: 1rem;
  }

  input[type="text"] {
    width: 100%;
    padding: 0.5rem;
    font-size: 1rem;
    margin-top: 0.25rem;
    box-sizing: border-box;
  }

  button {
    padding: 0.5rem 1rem;
    font-size: 1rem;
    margin-top: 0.5rem;
    cursor: pointer;
  }

  #status {
    text-align: center;
    margin-top: 1rem;
    font-style: italic;
    color: #555;
  }

  #waitingRoom {
    text-align: center;
    margin-top: 2rem;
  }

  #displayRoomCode {
    font-size: 1.5rem;
    font-weight: bold;
    display: inline-block;
    margin-top: 0.5rem;
  }

  #gameArea {
    margin-top: 2rem;
    position: relative;
  }

  @keyframes pulse-border {
  0% {
    box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.5);
  }
  70% {
    box-shadow: 0 0 0 10px rgba(40, 167, 69, 0);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(40, 167, 69, 0);
  }
}

  #turnSection {
    margin-bottom: 1.5rem;
  }

  #turnSection.your-turn {
  border: 3px solid #28a745;
  background-color: #e8f5e9;
  padding: 1rem;
  border-radius: 8px;
  box-shadow: 0 0 12px rgba(40, 167, 69, 0.3);
  transition: all 0.3s ease;
  animation: pulse-border 1.5s infinite;
}

#turnSection.opponent-turn {
  opacity: 0.6;
}


  #timer {
    font-size: 2rem;
    font-weight: bold;
    text-align: center;
    color: #333;
    margin: 1rem 0;
  }

  #guessControls {
  display: flex;
  gap: 0.75rem; /* a bit more gap */
  margin-bottom: 1rem;
  align-items: center; /* vertical center */
  justify-content: center; /* center horizontally */
}

 #guessControls input {
  flex: 1 1 auto;
  min-width: 0; /* helps prevent overflow */
  padding: 0.75rem 1rem; /* more padding for easier touch */
  font-size: 1.1rem;
  border-radius: 4px;
  border: 1px solid #ccc;
  box-sizing: border-box;
}

#submitGuessBtn {
  padding: 0.85rem 1.75rem;
  font-size: 1.1rem;
  min-width: 130px;
  min-height: 56px; /* ‚Üê Ensures at least 56px tall */
  border-radius: 6px;
  cursor: pointer;
  background-color: #007bff;
  color: white;
  border: none;
  transition: background-color 0.25s ease;
}

#submitGuessBtn:disabled {
  background-color: #aaa;
  cursor: not-allowed;
}

#submitGuessBtn:hover:not(:disabled) {
  background-color: #0056b3;
}

#autocomplete-list {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  z-index: 9999;
  background-color: white;
  border: 1px solid #ccc;
  max-height: 200px;
  overflow-y: auto;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
}

.autocomplete-item {
  display: flex;
  justify-content: space-between;
  padding: 6px 10px;
  cursor: pointer;
}

.autocomplete-item:hover {
  background-color: #f0f0f0;
}

.career-years {
  font-size: 0.8em;
  color: gray;
}



  #autocomplete-list div {
    padding: 0.5rem;
    cursor: pointer;
  }

  #autocomplete-list div:hover {
    background: #f0f0f0;
  }

  #successful-guesses-container {
    margin-top: 1rem;
    text-align: center;
  }

  #successful-guesses-list {
    list-style: none;
    padding-left: 0;
    margin-top: 0.5rem;
    text-align: center;
  }

  #successful-guesses-list li {
    margin: 0.5rem 0;
  }

  .hidden {
    display: none !important;
  }

  /* Unified message styling */
  .message {
    margin-top: 0.5rem;
    font-size: 1rem;
    text-align: center;
    color: #333;
    transition: opacity 1s ease;
    opacity: 1;
  }

  .message.error {
    color: red;
    font-weight: bold;
  }

  .message.fade-out {
    opacity: 0;
  }

 .turn-prompt {
  font-size: 1.3rem;
  color: #222;
  margin-bottom: 1rem;
  text-align: center;
  line-height: 1.6;
}

.turn-prompt .turn-player-name {
  display: block;
  font-size: 1.6rem;
  margin-top: 0.5rem;
  color: #007bff;
}

#playersDisplay {
  text-align: center;
  margin-top: 1rem;
  font-size: 1.3rem;
  font-weight: bold;
  color: #222;
}

.player-name {
  padding: 0 0.5rem;
}

.player-name.you {
  color: #28a745; /* green */
}

.player-name.opponent {
  color: #007bff; /* blue */
}

.vs-separator {
  color: #555;
  padding: 0 0.5rem;
}

#welcome-message {
  font-size: 1.5rem;
  margin-bottom: 1rem;
  text-align: center;
  color: #333;
}


  #gameOverContainer {
    display: none;
    text-align: center;
    margin-top: 2rem;
  }

  #rematchBtn {
  display: block; /* ‚Üê Change this from "none" or "inline-block" to block */
  margin: 1.5rem auto 0; /* auto left/right centers it */
  padding: 0.5rem 1.5rem;
  font-weight: bold;
  border: none;
  border-radius: 4px;
  background-color: #007bff;
  color: white;
  transition: background-color 0.3s ease;
}


  #rematchBtn:hover {
    background-color: #0056b3;
  }

 #scoreboardSection {
  position: fixed;
  top: 1rem;
  right: 1rem;
  z-index: 1000;
}

#jumbotronScoreboard {
   background: #fff !important;
  color: #111 !important;
  border: 2px solid #111 !important;
  width: 180px !important;
  min-width: 120px !important;
  max-width: 95vw;
  font-family: Arial, sans-serif;
  box-shadow: none;
}

.scoreboard-box {
  background: #fff !important;
  border: 2px solid #111 !important;
  color: #111 !important;
  min-width: 120px !important;
  border-radius: 6px;
}

.scoreboard-header,
.scoreboard-scores {
  display: flex;
  flex-direction: row;
  width: 100%;
  height: 100%;
}

.scoreboard-header span,
.scoreboard-scores span {
  flex: 1 1 0;
  width: 50%;
  box-sizing: border-box;
  text-align: center;
  padding: 0.5rem;
}

.scoreboard-header .divider,
.scoreboard-scores .divider {
  background: #111 !important;
}

.scoreboard-header {
   background: #fff !important;
  color: #111 !important;
  border-bottom: 1px solid #111 !important;
}

.scoreboard-scores {
  background: #fff !important;
  color: #111 !important;
}

.divider {
  border-left: 1px solid #333;
  flex: 0 0 1px;
  padding: 0;
}


@media (max-width: 480px) {
  #guessControls {
    flex-direction: column;
    gap: 0.6rem;
  }

  #guessControls input, 
  #submitGuessBtn {
    width: 100%;
    min-width: auto;
  }

  #submitGuessBtn {
    font-size: 1.2rem;
    padding: 1rem;          /* visually balances a bigger tap target */
    min-height: 56px;       /* reaffirm minimum height */
  }

  #jumbotronScoreboard {
    width: 98vw !important;
    min-width: 0 !important;
    font-size: 0.95rem;
    padding: 0.2rem 0.1rem;
  }
  .scoreboard-box {
    min-width: 0 !important;
    font-size: 0.95rem;
  }
}

.auth-tabs-container {
  width: 100%;
  max-width: 600px;
  margin: 2rem auto;
}
.auth-tabs {
  display: flex;
  justify-content: center;
  margin-bottom: 1.5rem;
}
.auth-tab {
  flex: 1;
  padding: 1rem 2rem;
  background: #f0f0f0;
  border: none;
  border-bottom: 3px solid transparent;
  color: #333;
  font-size: 1.1rem;
  font-weight: bold;
  cursor: pointer;
  transition: background 0.2s, border-bottom 0.2s, color 0.2s;
}
.auth-tab.active {
  background: #fff;
  border-bottom: 3px solid #007bff;
  color: #007bff;
  z-index: 2;
}
.auth-forms-row {
  display: flex;
  gap: 2rem;
  justify-content: center;
  align-items: flex-start;
}
.auth-form {
  background: #fff;
  border: 1.5px solid #e0e4ea;
  border-radius: 18px;
  box-shadow: 0 6px 24px rgba(0,0,0,0.10), 0 1.5px 4px rgba(0,0,0,0.04);
  padding: 2.2rem 2rem 1.7rem 2rem;
  min-width: 260px;
  width: 100%;
  max-width: 340px;
  display: none;
  flex-direction: column;
  gap: 1.2rem;
  align-items: stretch;
  transition: box-shadow 0.2s, border 0.2s;
}
.auth-form.active {
  display: flex;
  z-index: 1;
  border: 2.5px solid #007bff;
  box-shadow: 0 10px 32px rgba(0,123,255,0.10), 0 2px 8px rgba(0,0,0,0.06);
}
.auth-form input {
  border-radius: 8px;
  border: 1.2px solid #d1d5db;
  padding: 0.85rem 1rem;
  font-size: 1.05rem;
  background: #f8fafc;
  color: #222;
  transition: border 0.2s;
}
.auth-form input:focus {
  border: 1.5px solid #007bff;
  outline: none;
  background: #fff;
}
.auth-form button {
  border-radius: 8px;
  background: linear-gradient(90deg, #007bff 60%, #0056b3 100%);
  color: #fff;
  font-weight: 600;
  font-size: 1.08rem;
  border: none;
  padding: 0.85rem 0;
  margin-top: 0.5rem;
  box-shadow: 0 2px 8px rgba(0,123,255,0.08);
  transition: background 0.2s, box-shadow 0.2s;
  cursor: pointer;
}
.auth-form button:hover {
  background: linear-gradient(90deg, #0056b3 60%, #007bff 100%);
  box-shadow: 0 4px 16px rgba(0,123,255,0.13);
}
.auth-form h2 {
  margin-bottom: 0.5rem;
  color: #007bff;
  font-size: 1.35rem;
  font-weight: 700;
  letter-spacing: 0.01em;
  text-align: center;
}
.auth-form p, .auth-form a {
  font-size: 0.97rem;
  color: #555;
  text-align: center;
}
.auth-form a {
  color: #007bff;
  text-decoration: underline;
  cursor: pointer;
}
.auth-form a:hover {
  color: #0056b3;
}
</style>


</head>
<body>
<nav>
  <span id="nav-username" style="display: none;"></span>
  <a href="#" id="nav-home-link" style="display: none;">üè† Home</a>
  <button id="nav-signin-btn">Sign In</button>
  <button id="nav-signout-btn" style="display: none;">Sign Out</button>
</nav>



<h1>NBA Teammate Game</h1>


<!-- üîë Sign Up / Sign In -->
  <section data-route="/signup">
    <div class="auth-tabs-container">
      <div class="auth-tabs">
        <button id="tab-signup" class="auth-tab active" type="button">Sign Up</button>
        <button id="tab-signin" class="auth-tab" type="button">Sign In</button>
      </div>
      <div class="auth-forms-row">
        <form id="signupForm" class="auth-form active" autocomplete="off">
          <h2>Sign Up</h2>
          <input type="email" id="signup-email" placeholder="Email" required>
          <input type="password" id="signup-password" placeholder="Password" required>
          <input id="signup-username" placeholder="Username" required>
          <button id="signupBtn" type="submit">Sign Up</button>
        </form>
        <form id="signinForm" class="auth-form" autocomplete="off">
          <h2>Sign In</h2>
          <input type="email" id="signin-email" placeholder="Email" required>
          <input type="password" id="signin-password" placeholder="Password" required>
          <button id="signinBtn" type="submit">Sign In</button>
          <p><a href="#" id="forgotPasswordLink">Forgot password?</a></p>
        </form>
      </div>
    </div>
  </section>


 <!-- üîó Check your email after sign up -->
  <section data-route="/verify" class="hidden">
    <h2>Check your email!</h2>
    <p>We've sent you a confirmation link. Click it to verify your account.</p>
  </section>


   <!-- ‚úÖ Confirmation success -->
  <section data-route="/confirmed" class="hidden">
    <h2>Account Confirmed</h2>
    <p>Your email is verified! You can now continue.</p>
    <button id="confirmedContinueBtn">Continue</button>
  </section>

  <!-- üîë Reset password -->
  <section data-route="/reset" class="hidden">
    <h2>Reset Password</h2>
    <input type="email" id="reset-email" placeholder="Email">
    <button id="resetBtn">Send Reset Link</button>
  </section>

  <!-- ‚úÖ Reset success -->
  <section data-route="/reset-confirmed" class="hidden">
    <h2>Password Reset</h2>
    <p>Check your email for a link to set a new password.</p>
  </section>

<!-- Set password -->
  <section data-route="/update-password" class="hidden">
  <h2>Set a New Password</h2>
  <input type="password" id="new-password" placeholder="New password" />
  <button id="updatePasswordBtn">Update Password</button>
</section>


  <!-- ‚úèÔ∏è Create username/profile
  <section data-route="/username" class="hidden">
    <h2>Create Profile</h2>
    <input id="create-username" placeholder="Choose a username">
    <button id="saveUsernameBtn">Save</button>
  </section> -->


<!-- Home Screen -->
<section id="homeSelection" data-route="/home" class="hidden" style="text-align: center; margin-top: 2rem;">
  <h2 id="home-welcome"></h2>
  <h2>üè† Home</h2>

  <div id="gameModeSelection" style="margin-top: 1rem;">
    <button id="privateGameBtn">üîí Start Private Game</button>
    <button id="findGameBtn">üåê Join Public Game</button>
  </div>

  <div id="playerStats" style="margin-top: 2rem;">
    <h3>Your Stats</h3>
    <p id="player-history">Games played, wins, and other stats will appear here.</p>
  </div>
</section>


<!-- Invite link container (used only in private games) -->
<section id="inviteLinkContainer" data-route="/invite" class="hidden" style="text-align: center; margin-top: 1rem;"></section>

<!-- Status message -->
<section id="status" data-route="/status" style="text-align: center; margin-top: 1rem;"></section>

<!-- Waiting Room View -->
<section id="waitingRoom" data-route="/waiting" class="hidden" style="text-align: center; margin-top: 2rem;">
  <h2>Waiting Room</h2>
  <p>Waiting for another player to join...</p>
  <code id="displayRoomCode" style="font-size: 1.5rem; font-weight: bold;"></code>
  <div id="inviteLinkWrapper" style="margin-top: 1rem;">
    <p>Invite a friend to join using this link:</p>
    <input id="inviteLink" type="text" readonly style="width: 80%; max-width: 400px; padding: 0.5rem;" />
    <button id="copyInviteBtn">Copy Link</button>
  <div id="copyToast" style="display:none; color: green; margin-top: 0.5rem;">Link copied!</div>
  </div>
</section>

<!-- Scoreboard UI -->
<!-- <section id="scoreboardSection">
  <div id="jumbotronScoreboard" class="scoreboard-box">
    <div class="scoreboard-header">
      <span id="player1Name">Player 1</span>
      <span id="player2Name">Player 2</span>
    </div>
    <div class="scoreboard-scores">
      <span id="player1Score" class="scoreDigits">0</span>
      <span id="player2Score" class="scoreDigits">0</span>
    </div>
  </div>
</section> -->


<!-- In-Game UI -->
<section id="gameArea" data-route="/play" class="hidden" style="position: relative;">
 <div id="playersDisplay">
  <span class="player-name you" id="playerYou">You</span>
  <span class="vs-separator">vs</span>
  <span class="player-name opponent" id="playerOpponent">Opponent</span>
</div>

  <div id="turnSection">
  <p class="turn-prompt" id="turnPromptText">
  üéØ Name any teammate of:<br>
  <strong class="turn-player-name" id="currentPlayerName">LeBron James</strong>
</p>


   <p>Time left: <span id="timer">15</span> seconds</p>
    <div id="guessControls" style="position: relative;">
      <input
        type="text"
        id="guessInput"
        placeholder="Type a teammate's name..."
        autocomplete="off"
        autocorrect="off"
        autocapitalize="off"
        spellcheck="false"
      />
      <button id="submitGuessBtn" disabled>Submit Guess</button>
      <div id="autocomplete-list"></div>
    </div>
  </div>

  <div id="messageContainer"></div>
</section>



<!-- Game Over UI -->
<section data-route="/gameover" class="hidden" style="text-align: center; margin-top: 2rem;">
  <div id="gameOverContainer" style="display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 1rem;">
    <!-- Game over message will be dynamically added here -->

    <!-- Add this container for winner/loser details -->
    <div id="gameOverResults" style="font-size: 1.2rem; margin-top: 1rem;"></div>
  </div>
  <button id="rematchBtn" style="margin-top: 1rem;">Request Rematch</button>
</section>


<!-- Shared Turn History List -->
<div id="successful-guesses-container" style="text-align: center; margin-top: 2rem;">
  <h3 style="margin-bottom: 0.5rem;">Turn History</h3>
  <ul id="successful-guesses-list" style="list-style: none; padding: 0;"></ul>
</div>


<script>
    // ============================================
  // 1Ô∏è‚É£ Global variables
  // ============================================
  let roomId = null;
  let myRoomId = null;
  let selectedPlayer = null;
  let fetchTimeout = null;
  let gameStarted = false;
  let gameOver = false;
  let leadoffPlayerName = null;
  let myUsername = null;
  let opponentName = null;
  let successfulGuesses = [];
  let isPrivateGame = false;
  let socket = null;
  let isLeavingGame = false;
// ‚úÖ Global route tracker
  let currentRoute = '';
  let statusDiv = null;
  let socketConnected = false;
  let emitQueue = [];


   

  // ============================================
  // 2Ô∏è‚É£ initSocket ‚Äî only attaches once
  // ============================================

  function initSocket() {
    if (socket && socket.connected) {
      console.log('[initSocket] Socket already connected');
      return;
    }

    socket = io(); 

    socket.on('connect', () => {
      console.log('[initSocket] Socket connected!');
      flushEmitQueue();
    });

    socket.on('playersUpdate', (count) => {
      console.log('[DEBUG] playersUpdate received:', count);
      if (statusDiv) {
        statusDiv.textContent = `Players in room: ${count}`;
      } else {
        console.warn('[WARN] statusDiv not found!');
      }
    });



    socket.on('matched', ({ roomId, opponent }) => {
      if (isLeavingGame || localStorage.getItem('isLeavingGame') === 'true') {
        console.log('[DEBUG] Ignoring matched event because isLeavingGame is true');
        return;
      }

      if (gameStarted && !gameOver) return;

      isLeavingGame = false;
      localStorage.removeItem('isLeavingGame');

      myRoomId = roomId;
      opponentName = opponent;

      if (statusDiv) {
        statusDiv.textContent = `Matched with ${opponent}! Joining game...`;
      }

      navigateTo('/waiting');
      safeEmit('joinGame', { roomId: myRoomId, username: myUsername });
    });



    socket.on('gameStarted', async (data) => {
      if (isLeavingGame) {
        console.log('[DEBUG] Ignoring gameStarted because isLeavingGame === true');
        return;
      }

      console.log('[CLIENT] Received gameStarted event:', data);

      gameStarted = true;
      gameOver = false;

      leadoffPlayerName = data.leadoffPlayer || null;

      if (window.timerInterval) {
        clearInterval(window.timerInterval);
        window.timerInterval = null;
        console.warn('[CLIENT] Cleared leftover timer before starting new one.');
      }

      guessInput.disabled = true;
      submitGuessBtn.disabled = true;
      guessInput.value = '';
      clearGuessError();
      clearAutocomplete();

      rematchBtn.style.display = 'none';
      rematchBtn.disabled = false;
      rematchBtn.textContent = 'Rematch';

      messagesEl.innerHTML = '';
      messagesEl.style.display = 'block';

      successfulGuesses = [];
      if (data.leadoffPlayer && data.leadoffPlayer.trim() !== '') {
        leadoffPlayerName = data.leadoffPlayer;
        successfulGuesses.push({
          guesser: 'Leadoff',
          name: leadoffPlayerName,
          isLeadoff: true
        });
      }

      console.log('[CLIENT] successfulGuesses after reset:', successfulGuesses);
      renderSuccessfulGuesses();

      currentPlayerNameEl.textContent = data.currentPlayerName;

      const playerYouEl = document.getElementById('playerYou');
      const playerOpponentEl = document.getElementById('playerOpponent');
      if (playerOpponentEl && data.opponentName) {
        playerOpponentEl.textContent = data.opponentName;
        opponentName = data.opponentName;
      }
      if (playerYouEl) playerYouEl.textContent = myUsername || 'You';

      const isYourTurn = data.currentPlayerName === myUsername;
      if (playerYouEl && playerOpponentEl) {
        playerYouEl.classList.toggle('active-turn', isYourTurn);
        playerOpponentEl.classList.toggle('active-turn', !isYourTurn);
      }

      timerEl.textContent = data.timeLeft || 15;
      console.log('[CLIENT] Timer initialized at:', data.timeLeft || 15);

      // ‚úÖ ‚úÖ ‚úÖ NEW: Navigate to /play FIRST and wait!
      console.log('[DEBUG] Navigating to /play...');
      await navigateTo('/play');
      console.debug('[DEBUG] Waiting for scoreboard readiness...');
      await waitForScoreboard();
      safeEmit('getMatchStats');

    });


    socket.on('matchStats', (stats) => {
      console.log('[CLIENT] Updated matchStats:', stats);
      updateSplitScoreboard(stats, myUsername, opponentName);
    });

    socket.on('gameOver', (data) => {
      console.log('[DEBUG] gameOver received:', data);

      // ‚úÖ If I intentionally left, skip handling
      if (isLeavingGame) {
        console.debug('[DEBUG] Ignoring gameOver because isLeavingGame === true');
        isLeavingGame = false; // reset for next time
        return; // skip all the rest
      }

      gameOver = true;

      // Stop input & timer
      guessInput.disabled = true;
      submitGuessBtn.disabled = true;

      if (window.timerInterval) {
        clearInterval(window.timerInterval);
        window.timerInterval = null;
      }
      timerEl.textContent = '';

      // Ensure myUsername & opponentName
      if (!myUsername && data.winnerName && data.loserName) {
        if (data.role === 'winner') {
          myUsername = data.winnerName;
          opponentName = data.loserName;
        } else {
          myUsername = data.loserName;
          opponentName = data.winnerName;
        }
      } else if (!opponentName && data.winnerName && data.loserName) {
        opponentName = (myUsername === data.winnerName) ? data.loserName : data.winnerName;
      }

      // Show game over container
      const container = document.getElementById('gameOverContainer');
      container.style.display = 'flex';
      container.innerHTML = '';

      const gameOverMsg = document.createElement('div');
      gameOverMsg.style.fontSize = '1.5rem';
      gameOverMsg.style.textAlign = 'center';
      gameOverMsg.style.fontWeight = 'bold';
      gameOverMsg.style.marginTop = '1rem';

      if (data.message) {
        gameOverMsg.textContent = data.message;
      } else if (data.reason === 'opponent_left') {
        const opponent = opponentName || 'Your opponent';
        gameOverMsg.textContent = `${opponent} left the game.`;
      } else {
        gameOverMsg.textContent = 'Game Over!';
      }

      if (data.role === 'winner') {
        gameOverMsg.style.color = 'green';
      } else if (data.role === 'loser') {
        gameOverMsg.style.color = 'darkred';
      } else {
        gameOverMsg.style.color = 'gray';
      }

      container.appendChild(gameOverMsg);

      const resultsDiv = document.getElementById('gameOverResults');
      if (resultsDiv) {
        if (data.winnerName && data.loserName) {
          resultsDiv.innerHTML = `
        <p><strong>Winner:</strong> ${data.winnerName}</p>
        <p><strong>Loser:</strong> ${data.loserName}</p>
      `;
        } else {
          resultsDiv.innerHTML = '';
        }
      }

      if (data.canRematch === false || data.reason === 'opponent_left') {
        rematchBtn.style.display = 'none';
      } else {
        rematchBtn.style.display = 'block';
        rematchBtn.disabled = false;
        rematchBtn.textContent = 'Rematch';
      }

      // Let server 'matchStats' handle scoreboard update
      navigateTo('/gameover');
    });


    socket.on('yourTurn', (data) => {
      navigateTo('/play');

      const turnSection = document.getElementById('turnSection');

      turnSection.classList.add('your-turn');
      turnSection.classList.remove('opponent-turn');

      document.getElementById('guessControls').style.display = 'block';
      guessInput.disabled = false;
      submitGuessBtn.disabled = !guessInput.value.trim();

      currentPlayerNameEl.textContent = data.currentPlayerName || 'Your Turn';
      timerEl.textContent = data.timeLeft || 15;

      turnSection.style.display = 'block';
      messagesEl.style.display = 'block';

      showMessage(data.message || "It's your turn to guess!", 'info');

      const turnPromptEl = document.getElementById('turnPromptText');
      if (turnPromptEl) {
        turnPromptEl.innerHTML = `üéØ Name any teammate of:<br><strong class="turn-player-name">${data.currentPlayerName}</strong>`;
      }



      // ‚úÖ Highlight the current player in playersDisplay
      const playerYouEl = document.getElementById('playerYou');
      const playerOpponentEl = document.getElementById('playerOpponent');

      if (playerYouEl && playerOpponentEl) {
        playerYouEl.classList.add('active-turn');
        playerOpponentEl.classList.remove('active-turn');
      }
    });


    socket.on('opponentTurn', (data) => {
      navigateTo('/play');

      const turnSection = document.getElementById('turnSection');

      turnSection.classList.remove('your-turn');
      turnSection.classList.add('opponent-turn');

      document.getElementById('guessControls').style.display = 'none';
      guessInput.disabled = true;
      submitGuessBtn.disabled = true;

      currentPlayerNameEl.textContent = data.currentPlayerName || "Opponent's Turn";
      timerEl.textContent = '';

      turnSection.style.display = 'block';
      messagesEl.style.display = 'block';

      showMessage(data.message || "Waiting for your opponent to guess...", 'info');

      const turnPromptEl = document.getElementById('turnPromptText');
      if (turnPromptEl) {
        turnPromptEl.innerHTML = `üïí Waiting for opponent to name a teammate of:<br><strong class="turn-player-name">${data.currentPlayerName}</strong>`;
      }


      // ‚úÖ Highlight the opponent in playersDisplay
      const playerYouEl = document.getElementById('playerYou');
      const playerOpponentEl = document.getElementById('playerOpponent');

      if (playerYouEl && playerOpponentEl) {
        playerYouEl.classList.remove('active-turn');
        playerOpponentEl.classList.add('active-turn');
      }
    });


    socket.on('message', (msg) => {
      navigateTo('/play'); // Ensure user is on the gameplay page
      showMessage(msg, 'error');
    });


    socket.on('turnEnded', (data) => {
      navigateTo('/play');

      if (Array.isArray(data.successfulGuesses)) {
        successfulGuesses = markLeadoffInGuesses(data.successfulGuesses, leadoffPlayerName);
        renderSuccessfulGuesses();
      }

      if (data.message) {
        showMessage(data.message, data.message.startsWith('Incorrect guess') ? 'error' : 'info');
      }

      updateTurn(data);
    });



    socket.on('timerTick', (data) => {
      timerEl.textContent = data.timeLeft;
    });


    socket.on('disconnect', (reason) => {
      console.log('[DEBUG] Socket disconnected:', reason);
      socketConnected = false;
    });

    // When another player requests a rematch
    socket.on('rematchRequested', ({ username }) => {
      showMessage(`${username} wants a rematch! Click your Rematch button to accept.`, 'info', true);
    });

    // When rematch actually starts
    socket.on('rematchStarted', () => {
      resetGameUI();

      // Clear any rematch prompt message
      const rematchInfo = document.getElementById('rematch-info');
      if (rematchInfo) rematchInfo.remove();

      // Reset rematch button styles
      rematchBtn.disabled = false;
      rematchBtn.style.backgroundColor = ''; // Reset highlight
      rematchBtn.textContent = 'Rematch';

      // ‚úÖ Re-join the same room to trigger new game start
      if (myRoomId && myUsername) {
        console.log('[CLIENT] Rejoining room for rematch:', myRoomId);
        safeEmit('joinGame', { roomId: myRoomId, username: myUsername });
        safeEmit('getMatchStats');
      } else {
        console.error('[CLIENT] Missing roomId or username for rematch.');
      }
    });



    // ‚úÖ Add more listeners as needed
  }


  // ============================================
  // 3Ô∏è‚É£ Safe emit pattern
  // ============================================
function safeEmit(event, data) {
  if (!socket) {
    console.warn(`[safeEmit] Socket is null ‚Äî initializing socket`);
    initSocket();  // Or however you handle (re)connecting
  }

  emitQueue.push({ event, data });

  if (socket && socket.connected) {
    console.log(`[safeEmit] Socket connected ‚Äî emitting "${event}" immediately`);
    flushEmitQueue();
  } else {
    console.log(`[safeEmit] Socket not connected ‚Äî queued "${event}"`);
  }
}

function flushEmitQueue() {
  if (!socket) {
    console.warn(`[flushEmitQueue] Socket is null ‚Äî cannot flush`);
    return;
  }

  while (socket.connected && emitQueue.length > 0) {
    const { event, data } = emitQueue.shift();
    console.log(`[safeEmit] Flushing queued "${event}"`);
    safeEmit(event, data);
  }
}



   // ============================================
  // 4Ô∏è‚É£ App Helpers
  // ============================================
async function joinPublicGame() {
  console.log('[DEBUG] joinPublicGame called');

  isLeavingGame = false;
  localStorage.removeItem('isLeavingGame');

  if (!myUsername) {
    alert('Missing username');
    return;
  }

  if (gameStarted && !gameOver) {
    alert('Finish your current game first.');
    return;
  }

  myRoomId = null;
  roomId = null;
  isPrivateGame = false;

  selectedPlayer = null;
  successfulGuesses = [];
  gameOver = false;

  // ‚úÖ Ensure socket is initialized
  if (!socket) {
    console.log('[joinPublicGame] Socket is null ‚Äî initializing');
    initSocket();
  }

  console.log('[DEBUG] Navigating to /waiting...');
  await navigateTo('/waiting');

  console.log('[DEBUG] Using safeEmit to find match:', myUsername);
  safeEmit('findMatch', myUsername);
}

function startPrivateGame() {
  console.log('[DEBUG] startPrivateGame called');

  if (isLeavingGame) {
    console.log('[DEBUG] startPrivateGame aborted: isLeavingGame is true');
    return;
  }

  if (!myUsername) {
    alert('Missing username');
    return;
  }

  if (gameStarted && !gameOver) {
    alert('Finish your current game first.');
    return;
  }

  isPrivateGame = true;
  isLeavingGame = false;

  const generatedRoomId = `room-${Math.random().toString(36).substring(2, 8)}`;
  roomId = generatedRoomId;
  myRoomId = generatedRoomId;

  safeEmit('joinGame', { roomId: myRoomId, username: myUsername });

  if (statusDiv) {
    statusDiv.textContent = `Started private room: ${myRoomId}`;
  }

  document.getElementById('displayRoomCode').textContent = myRoomId;

  inviteLinkContainer.innerHTML = `
    Share this link to invite a friend:<br>
    <a href="${window.location.origin}?room=${myRoomId}" target="_blank">
      ${window.location.origin}?room=${myRoomId}
    </a>
  `;

  navigateTo('/waiting');
}



function requestRematch() {
  if (!myRoomId) {
    console.error('No roomId defined. Cannot request rematch.');
    return;
  }
  rematchBtn.disabled = true;
  rematchBtn.textContent = 'Waiting for opponent...';
  safeEmit('requestRematch', { roomId: myRoomId });
}


function resetGameUI() {
  gameStarted = true;
  gameOver = false;

  // Clear old timers
  if (window.timerInterval) {
    clearInterval(window.timerInterval);
    window.timerInterval = null;
  }

  guessInput.disabled = true;
  submitGuessBtn.disabled = true;
  guessInput.value = '';
  clearGuessError();
  clearAutocomplete();

  // Reset rematch button visibility and style
  rematchBtn.style.display = 'none';  // Or 'inline-block' if you want it visible immediately
  rematchBtn.disabled = false;
  rematchBtn.textContent = 'Rematch';
  rematchBtn.style.backgroundColor = ''; // Clear any highlight

  // Reset UI parts
  messagesEl.innerHTML = '';
  messagesEl.style.display = 'block';

  successfulGuesses.length = 0;
  document.getElementById('successful-guesses-list').innerHTML = '';
  renderSuccessfulGuesses();

  currentPlayerNameEl.textContent = '';
  timerEl.textContent = '';

  // Show/hide game areas as needed
  waitingRoom.style.display = 'none';
  gameArea.style.display = 'block';
  document.getElementById('turnSection').style.display = 'block';

  // Hide game over container
  const gameOverContainer = document.getElementById('gameOverContainer');
  gameOverContainer.innerHTML = '';
  gameOverContainer.style.display = 'none';

  // Clear persistent rematch message
  const messageContainer = document.getElementById('messageContainer');
  if (messageContainer) {
    messageContainer.innerHTML = '';
  }
}

  function submitGuess() {
  const guess = guessInput.value.trim();
  clearGuessError();

  if (!guess) {
    showGuessError('Enter a guess');
    return;
  }
  if (guess !== selectedPlayer) {
    showGuessError('Please select a player from the dropdown list.');
    return;
  }

  safeEmit('playerGuess', { roomId, guess });
  guessInput.value = '';
  selectedPlayer = null;
  submitGuessBtn.disabled = true;
  clearAutocomplete();
}





  // ‚úÖ Sign In handler
  async function signIn(e) {
    e.preventDefault(); // üõë Stop default form submit

    const email = document.getElementById('signin-email').value.trim();
    const password = document.getElementById('signin-password').value.trim();

    if (!email || !password) {
      alert('Please fill in all fields.');
      return;
    }

    console.log('[DEBUG] SignIn data =>', email);

    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password
    });

    if (error) {
      console.error('SignIn error:', error.message);
      alert(error.message);
      return;
    }

    console.log('‚úÖ Sign In successful:', data);
    navigateTo('/home'); // üëà Take them to home or wherever
  }


  // ‚úÖ Sign Up handler
async function signUp(e) {
  e.preventDefault();

  const email = document.getElementById('signup-email').value.trim();
  const password = document.getElementById('signup-password').value.trim();

  if (!email || !password) {
    alert('Please fill in all fields.');
    return;
  }

  console.log('[DEBUG] SignUp data =>', email);

  const { data, error } = await supabase.auth.signUp({
    email,
    password
  });

  if (error) {
    console.error('SignUp error:', error.message);
    alert(error.message);
    return;
  }

  console.log('‚úÖ Sign Up successful:', data);

  // ‚úÖ Navigate to your verify page
  navigateTo('/verify');
}


function attachCopyInviteListener() {
  const copyInviteBtn = document.getElementById('copyInviteBtn');
  const copyToast = document.getElementById('copyToast');
  const inviteInput = document.getElementById('inviteLink');

  if (copyInviteBtn && copyToast && inviteInput) {
    copyInviteBtn.onclick = () => {
      navigator.clipboard.writeText(inviteInput.value)
        .then(() => {
          copyToast.style.display = 'block';
          setTimeout(() => {
            copyToast.style.display = 'none';
          }, 2000);
        })
        .catch(err => {
          alert('Failed to copy link. Please copy it manually.');
          console.error('Clipboard copy failed:', err);
        });
    };
    console.log('[DEBUG] copyInviteBtn listener attached');
  } else {
    console.warn('[WARN] Copy invite elements not found!');
  }
}


function updateSplitScoreboard(stats, player1, player2) {
  const p1NameEl = document.getElementById('player1Name');
  const p2NameEl = document.getElementById('player2Name');

  if (!p1NameEl || !p2NameEl) {
    console.warn('[DEBUG] Scoreboard elements not found. Skipping updateSplitScoreboard.');
    return; // Or: queue the update!
  }

  const p1Name = player1 || 'Player 1';
  const p2Name = player2 || 'Player 2';

  p1NameEl.textContent = p1Name;
  p2NameEl.textContent = p2Name;

  const safeStats = stats || {};
  const player1Stats = safeStats[p1Name];
  const player2Stats = safeStats[p2Name];
  const p1Wins = (player1Stats && typeof player1Stats.wins === 'number') ? player1Stats.wins : 0;
  const p2Wins = (player2Stats && typeof player2Stats.wins === 'number') ? player2Stats.wins : 0;

  document.getElementById('player1Score').textContent = p1Wins;
  document.getElementById('player2Score').textContent = p2Wins;
}

function waitForScoreboard() {
  return new Promise((resolve) => {
    const check = () => {
      if (
        document.getElementById('player1Name') &&
        document.getElementById('player1Score')
      ) {
        resolve();
      } else {
        requestAnimationFrame(check);
      }
    };
    check();
  });
}

function markLeadoffInGuesses(guesses, leadoffName) {
  return guesses.map(g => ({
    ...g,
    isLeadoff: g.name === leadoffName
  }));
}

 function clearGuessError() {
  const container = document.getElementById('messageContainer');
  container.innerHTML = '';
}

function showMessage(message, type = 'info', persist = false) {
  const container = document.getElementById('messageContainer');
  container.innerHTML = '';

  const div = document.createElement('div');
  div.textContent = message;
  div.classList.add('message');

  if (type === 'error') div.classList.add('error');

  container.appendChild(div);

  if (!persist) {
    setTimeout(() => {
      div.classList.add('fade-out');
      setTimeout(() => container.innerHTML = '', 1000);
    }, 3000);
  }
}



  function updateTurn(data) {
    currentPlayerNameEl.textContent = data.currentPlayerName || '???';
    timerEl.textContent = data.timeLeft || 15;
  }



 function clearAutocomplete() {
  autocompleteList.innerHTML = '';
  autocompleteList.style.display = 'none';
}


function showAutocompleteSuggestions(suggestions) {
  const list = document.getElementById('autocomplete-list');
  list.innerHTML = '';

  if (suggestions.length === 0) {
    list.style.display = 'none';  // Hide when empty
    return;
  }

  list.style.display = 'block'; // Show when populated

  suggestions.forEach(suggestionEl => {
    // suggestionEl is an element, append it directly
    list.appendChild(suggestionEl);
  });
}


function renderSuccessfulGuesses() {
  const listEl = document.getElementById('successful-guesses-list');
  if (!listEl || !Array.isArray(successfulGuesses)) return;

  listEl.innerHTML = '';

  const displayList = [...successfulGuesses].reverse();

  displayList.forEach((guessObj, index) => {
    const name = guessObj.name || '';
    const isLeadoff = guessObj.isLeadoff || false;
    const guesser = guessObj.guesser || '';
    const sharedTeams = guessObj.sharedTeams || [];

    if (!name.trim()) return;

    // Guess box
    const box = document.createElement('div');
    box.style.border = '1px solid #ccc';
    box.style.borderRadius = '8px';
    box.style.padding = '0.75rem';
    box.style.margin = '0.5rem auto';
    box.style.maxWidth = '300px';
    box.style.textAlign = 'center';
    box.style.backgroundColor = isLeadoff
      ? '#e6f0ff'
      : (guesser === myUsername ? '#d4edda' : '#f1f1f1');
    box.style.boxShadow = '0 2px 6px rgba(0,0,0,0.05)';

    const nameEl = document.createElement('div');
    nameEl.textContent = name;
    nameEl.style.fontSize = '1.1rem';
    nameEl.style.fontWeight = 'bold';
    box.appendChild(nameEl);

    listEl.appendChild(box);

    // Shared stints above arrow, only if NOT leadoff
    if (!isLeadoff && sharedTeams.length > 0 && index < displayList.length - 1) {
      const sharedInfo = document.createElement('div');
      sharedInfo.style.textAlign = 'center';
      sharedInfo.style.fontSize = '0.85rem';
      sharedInfo.style.color = '#444';
      sharedInfo.style.marginBottom = '0.25rem';

      const teamStrings = sharedTeams.map(t => `${t.team} (${t.years})`);
      sharedInfo.textContent = teamStrings.join(' ‚Ä¢ ');

      listEl.appendChild(sharedInfo);
    }

    // Up arrow (except for last guess)
    if (index < displayList.length - 1) {
      const arrow = document.createElement('div');
      arrow.textContent = '‚Üë';
      arrow.style.fontSize = '1.2rem';
      arrow.style.color = '#888';
      arrow.style.textAlign = 'center';
      arrow.style.margin = '0.25rem 0 0 0';
      listEl.appendChild(arrow);
    }
  });
}


function handleGoHome() {
  console.debug('[CLIENT] handleGoHome called');

  // ‚úÖ Mark that you‚Äôre intentionally leaving ‚Äî and persist it!
  isLeavingGame = true;
  localStorage.setItem('isLeavingGame', 'true');

  // ‚úÖ Tell server if in an active game
  if (socket && socket.connected && gameStarted && !gameOver) {
    safeEmit('leaveGame');
  }

  // ‚úÖ Always clear local game state
  myRoomId = null;
  roomId = null;
  isPrivateGame = false;
  gameStarted = false;
  gameOver = true;
  selectedPlayer = null;
  successfulGuesses = [];

  localStorage.removeItem('privateRoomId');

  navigateTo('/home');
}


async function handleAuthSuccess() {
  const { data: { user }, error } = await supabase.auth.getUser();
  if (error || !user) {
    console.error('No user signed in');
    navigateTo('/signup');
    return;
  }

  const username = user.user_metadata?.username || null;

  if (!username) {
    console.error('No username found in user_metadata!');
    navigateTo('/signup');
    return;
  }

  // Try updating profiles row, but don‚Äôt block navigation if it fails
  const { error: updateError } = await supabase
    .from('profiles')
    .update({ username })
    .eq('id', user.id);

  if (updateError) {
    console.warn('Warning: Error updating profile:', updateError.message);
  } else {
    console.log('‚úÖ Username saved to profiles:', username);
  }

  myUsername = username;
  localStorage.setItem('username', myUsername);

  // Clear URL hash to remove confirmation tokens
  history.replaceState(null, '', window.location.pathname);

  navigateTo('/home');
}


async function signOut() {
  const { error } = await window.supabase.auth.signOut();
  if (error) {
    alert('Sign out error: ' + error.message);
    return;
  }
  alert('Signed out!');
  showUser();
}


async function updateNavUserState(session) {
  const usernameDiv = document.getElementById('nav-username');
  const signinBtn = document.getElementById('nav-signin-btn');
  const signoutBtn = document.getElementById('nav-signout-btn');
  const homeLink = document.getElementById('nav-home-link'); // ‚úÖ Add this

  if (!usernameDiv || !signinBtn || !signoutBtn || !homeLink) return;

  if (!session || !session.user) {
    // Not logged in
    usernameDiv.style.display = 'none';
    signinBtn.style.display = 'inline-block';
    signoutBtn.style.display = 'none';
    homeLink.style.display = 'none'; // ‚úÖ Hide Home link
  } else {
    // Logged in
    const user = session.user;
    usernameDiv.textContent = `Hello, ${user.user_metadata?.username || user.email}`;
    usernameDiv.style.display = 'inline-block';
    signinBtn.style.display = 'none';
    signoutBtn.style.display = 'inline-block';
    homeLink.style.display = 'inline-block'; // ‚úÖ Show Home link
  }
}


async function resetPassword() {
  const emailInput = document.getElementById('reset-email');
  const email = emailInput.value.trim();

  if (!email) {
    alert('Please enter your email address.');
    return;
  }

  try {
    const { data, error } = await supabase.auth.resetPasswordForEmail(email, {
      redirectTo: `${window.location.origin}/update-password`
    });

    if (error) {
      console.error('[ERROR] Supabase reset error:', error.message);
      alert('Error sending reset email: ' + error.message);
      return;
    }

    console.log('[INFO] Password reset email sent:', data);
    navigateTo('/reset-confirmed'); // Switch to your "Check your email" screen!
  } catch (err) {
    console.error('[ERROR] Unexpected:', err);
    alert('An unexpected error occurred.');
  }
}

async function updatePassword() {
  const newPasswordInput = document.getElementById('new-password');
  const newPassword = newPasswordInput.value.trim();

  if (!newPassword) {
    alert('Please enter a new password.');
    return;
  }

  const { data, error } = await supabase.auth.updateUser({
    password: newPassword
  });

  if (error) {
    console.error('[ERROR] Failed to update password:', error.message);
    alert('Error updating password: ' + error.message);
    return;
  }

  console.log('[INFO] Password updated:', data);

  // ‚úÖ Redirect the user back to sign in, or show success
  alert('Password updated successfully! Please sign in with your new password.');
  navigateTo('/signup');
}



// ============================================
  // 5Ô∏è‚É£ Router/navigation helpers
  // ============================================
function navigateTo(path, options = {}) {
  return new Promise((resolve) => {
    console.debug(`[navigateTo] Navigating to ${path}`);

    currentRoute = path;

    if (!options.skipPush) {
      history.pushState({}, '', path);
    }

    showRouteSection(path);

    if (currentRoute === path) {
      console.debug(`[navigateTo] Updating UI for ${path}`);
      updateUIForRoute(path);
      attachRouteListeners(path);
    } else {
      console.debug(`[navigateTo] Skipped updateUIForRoute ‚Äî stale path`, path);
    }

    requestAnimationFrame(resolve);
  });
}

function attachRouteListeners(route) {
  console.debug(`[attachRouteListeners] Attaching listeners for ${route}`);

  switch (route) {
    case '/signup': {
      const signupBtn = document.getElementById('signupBtn');
      const signinBtn = document.getElementById('signinBtn');
      const forgotPasswordLink = document.getElementById('forgotPasswordLink');

      if (signupBtn) {
        signupBtn.removeEventListener('click', signUp);
        signupBtn.addEventListener('click', signUp);
      }

      if (signinBtn) {
        signinBtn.removeEventListener('click', signIn);
        signinBtn.addEventListener('click', signIn);
      }

      if (forgotPasswordLink) {
        const goReset = (e) => {
          e.preventDefault();
          navigateTo('/reset');
        };
        forgotPasswordLink.removeEventListener('click', goReset);
        forgotPasswordLink.addEventListener('click', goReset);
      }

      break;
    }

    case '/confirmed': {
      const continueBtn = document.getElementById('confirmedContinueBtn');
      if (continueBtn) {
        continueBtn.removeEventListener('click', handleAuthSuccess);
        continueBtn.addEventListener('click', handleAuthSuccess);
      }
      updateNavUserState();
      break;
    }

    case '/reset': {
      const resetBtn = document.getElementById('resetBtn');
      if (resetBtn) {
        resetBtn.removeEventListener('click', resetPassword);
        resetBtn.addEventListener('click', resetPassword);
      }
      break;
    }

    case '/update-password': {
      const updatePasswordBtn = document.getElementById('updatePasswordBtn');
      if (updatePasswordBtn) {
        updatePasswordBtn.removeEventListener('click', updatePassword);
        updatePasswordBtn.addEventListener('click', updatePassword);
      }
      break;
    }

    case '/home': {
      const privateGameBtn = document.getElementById('privateGameBtn');
      const findGameBtn = document.getElementById('findGameBtn');

      const handlePrivate = () => {
        isLeavingGame = false;
        startPrivateGame();
      };

      const handleFind = () => {
        isLeavingGame = false;
        joinPublicGame();
      };

      if (privateGameBtn) {
        privateGameBtn.removeEventListener('click', handlePrivate);
        privateGameBtn.addEventListener('click', handlePrivate);
      }

      if (findGameBtn) {
        findGameBtn.removeEventListener('click', handleFind);
        findGameBtn.addEventListener('click', handleFind);
      }
      break;
    }

    case '/play': {
      const submitGuessBtn = document.getElementById('submitGuessBtn');
      const rematchBtn = document.getElementById('rematchBtn');

      if (submitGuessBtn) {
        submitGuessBtn.removeEventListener('click', submitGuess);
        submitGuessBtn.addEventListener('click', submitGuess);
      }

      if (rematchBtn) {
        rematchBtn.removeEventListener('click', requestRematch);
        rematchBtn.addEventListener('click', requestRematch);
      }
      break;
    }
  }
}


function showRouteSection(path) {
  const allSections = document.querySelectorAll('section[data-route]');
  let matched = false;

  allSections.forEach(section => {
    const route = section.getAttribute('data-route');
    if (route === path) {
      section.classList.remove('hidden');
      matched = true;
    } else {
      section.classList.add('hidden');
    }
  });

  // Fallback if no matching route found
  if (!matched) {
    const defaultSection = document.querySelector('section[data-route="/signup"]');
    if (defaultSection) {
      defaultSection.classList.remove('hidden');
    }
  }
}

// 3. Update UI elements specific to certain routes
function updateUIForRoute(path) {
  if (path !== currentRoute) {
    console.debug('[updateUIForRoute] Skipped because stale:', path, 'Expected:', currentRoute);
    return;
  }

  console.debug('[updateUIForRoute] Handling:', path);

  if (path === '/home') {
    console.log('[DEBUG] updateUIForRoute: Handling /home');

    // ‚úÖ Mark that you are intentionally leaving
    if (socket && socket.connected && myRoomId) {
      console.debug('[updateUIForRoute] Emitting leaveGame');
      isLeavingGame = true;
      safeEmit('leaveGame');
    }

    // üßπ Clear local game state
    gameStarted = false;
    gameOver = true;
    roomId = null;
    myRoomId = null;
    isPrivateGame = false;
    selectedPlayer = null;
    successfulGuesses = [];

    // ‚úÖ DO NOT reset isLeavingGame here!
    // Let it stay true until you explicitly join or navigate away.

    // Update welcome
    const welcomeEl = document.getElementById('home-welcome');
    if (welcomeEl && myUsername) {
      welcomeEl.textContent = `Welcome, ${myUsername}! Choose your game mode below.`;
    }
  }

  if (path === '/waiting') {
    if (isLeavingGame) {
      console.log('[DEBUG] updateUIForRoute: Skipping /waiting because isLeavingGame is true');
      return;  // üõë Prevent accidental waiting room navigation
    }

    // ‚úÖ Use the shared statusDiv declared once near top
    if (statusDiv) {
      statusDiv.textContent = 'Waiting for an opponent...';
    } else {
      console.warn('[WARN] statusDiv not found when trying to update!');
    }

    const codeEl = document.getElementById('displayRoomCode');
    const inviteWrapper = document.getElementById('inviteLinkWrapper');
    const inviteInput = document.getElementById('inviteLink');

    if (codeEl && myRoomId) {
      codeEl.textContent = myRoomId;
    }

    if (inviteWrapper && inviteInput) {
      if (isPrivateGame && myRoomId) {
        const inviteUrl = `${window.location.origin}?room=${myRoomId}`;
        inviteInput.value = inviteUrl;
        inviteWrapper.style.display = 'block';
        inviteInput.focus();
        inviteInput.select();

        // Attach copy invite button listener here
        attachCopyInviteListener();
      } else {
        inviteInput.value = '';
        inviteWrapper.style.display = 'none';
      }
    }
  }

  // Guess container visibility
  const guessContainer = document.getElementById('successful-guesses-container');
  if (guessContainer) {
    guessContainer.style.display = (path === '/play' || path === '/gameover') ? 'block' : 'none';
  }

  // Scoreboard visibility
  const scoreboard = document.getElementById('scoreboardSection');
  if (scoreboard) {
    if (path === '/play' || path === '/gameover') {
      scoreboard.classList.remove('hidden');
    } else {
      scoreboard.classList.add('hidden');
    }
  }
}


function renderRoute(path, addToHistory = true) {
  console.debug('[renderRoute]', { path, addToHistory });

  currentRoute = path; // ‚úÖ important for stale guards
  showRouteSection(path);
  attachRouteListeners(path);
  updateUIForRoute(path);

  if (addToHistory && window.location.pathname !== path) {
    window.history.pushState({}, '', path);
  }
}

window.addEventListener('popstate', () => {
  const path = window.location.pathname;
  console.debug('[popstate] Navigating to:', path);
  renderRoute(path, false); // never push state when going back/forward
});

document.getElementById('guessInput')?.addEventListener('focus', () => {
  if (window.innerWidth <= 480) {
    const guessControls = document.getElementById('guessControls');
    const topOffset = guessControls.getBoundingClientRect().top + window.scrollY;
    const padding = parseFloat(getComputedStyle(document.body).paddingTop) || 16;

    window.scrollTo({
      top: topOffset - padding,
      behavior: 'smooth'
    });
  }
});



document.addEventListener('DOMContentLoaded', async () => {
  console.log('[DEBUG] DOMContentLoaded');

  // Grab your elements
  const signupForm = document.getElementById('signupForm');
  const signinForm = document.getElementById('signinForm');
  const tabSignup = document.getElementById('tab-signup');
  const tabSignin = document.getElementById('tab-signin');
  const guessInput = document.getElementById('guessInput');
  const submitGuessBtn = document.getElementById('submitGuessBtn');
  const navSignoutBtn = document.getElementById('nav-signout-btn');
  const navSigninBtn = document.getElementById('nav-signin-btn');
  const navHomeLink = document.getElementById('nav-home-link');

  statusDiv = document.getElementById('statusDiv');
  if (!statusDiv) console.warn('[WARN] statusDiv not found!');

  let justConfirmed = false;

  const urlHash = window.location.hash;
  const searchParams = new URLSearchParams(window.location.search);
  const typeParam = searchParams.get('type');

  // üü¢ 1Ô∏è‚É£ --- Handle email confirmation ---
  if (
    urlHash.includes('access_token') &&
    (urlHash.includes('type=signup') || urlHash.includes('type=recovery') || urlHash.includes('type=email_confirm'))
  ) {
    console.log('[DEBUG] Detected confirmation link.');
    try {
      const { data: { user }, error } = await supabase.auth.getUser();
      if (error) {
        console.error('[ERROR] Email confirmation failed:', error.message);
      } else if (user && user.email_confirmed_at) {
        console.log('[DEBUG] Email confirmed for:', user.email);
        myUsername = user.user_metadata?.username || user.email;
        localStorage.setItem('username', myUsername);

        const { data: { session } } = await supabase.auth.getSession();
        await updateNavUserState(session);

        justConfirmed = true;
        navigateTo('/confirmed');
        return; // ‚úÖ Stop further logic
      } else {
        console.log('[DEBUG] Email NOT confirmed yet, staying on /verify.');
        navigateTo('/verify');
        return; // ‚úÖ Stay here
      }
    } catch (err) {
      console.error('[ERROR] Exception in confirmation:', err);
    }
  }

  // üü¢ 2Ô∏è‚É£ --- Auth tab switching ---
  if (tabSignup && tabSignin && signupForm && signinForm) {
    tabSignup.addEventListener('click', () => {
      tabSignup.classList.add('active');
      tabSignin.classList.remove('active');
      signupForm.classList.add('active');
      signinForm.classList.remove('active');
    });

    tabSignin.addEventListener('click', () => {
      tabSignin.classList.add('active');
      tabSignup.classList.remove('active');
      signinForm.classList.add('active');
      signupForm.classList.remove('active');
    });
  }

  // üü¢ 3Ô∏è‚É£ --- Attach signup & signin form handlers ---
  if (signupForm) {
    signupForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      await signUp(e);
    });
  }

  if (signinForm) {
    signinForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      await signIn(e);
    });
  }

  // üü¢ 4Ô∏è‚É£ --- Autocomplete logic ---
  if (guessInput) {
    guessInput.addEventListener('input', function () {
      // your autocomplete logic
    });
    guessInput.addEventListener('change', () => {
      if (guessInput.value !== selectedPlayer) {
        selectedPlayer = null;
        submitGuessBtn.disabled = true;
      }
    });
  }

  // üü¢ 5Ô∏è‚É£ --- Nav handlers ---
  if (navHomeLink) {
    navHomeLink.addEventListener('click', (e) => {
      e.preventDefault();
      isLeavingGame = true;
      if (socket && socket.connected) safeEmit('leaveGame');
      navigateTo('/home');
    });
  }

  if (navSignoutBtn) {
    navSignoutBtn.addEventListener('click', async () => {
      await supabase.auth.signOut();
      updateNavUserState();
      navigateTo('/signup');
    });
  }

  if (navSigninBtn) {
    navSigninBtn.addEventListener('click', () => {
      navigateTo('/signin');
    });
  }

  // üü¢ 6Ô∏è‚É£ --- Auth state listener ---
  supabase.auth.onAuthStateChange((_event, session) => {
    updateNavUserState(session);
  });

  // üü¢ 7Ô∏è‚É£ --- Get session + update user ---
  const { data } = await supabase.auth.getSession();
  await updateNavUserState(data.session);

  if (data.session?.user) {
    myUsername = data.session.user.user_metadata?.username || data.session.user.email;
  } else {
    myUsername = localStorage.getItem('username') || null;
  }

  // üü¢ 8Ô∏è‚É£ --- Final routing logic ---
  if (justConfirmed) {
    navigateTo('/confirmed');
  } else if (!myUsername) {
    navigateTo('/signup');
  } else {
    navigateTo('/home');
  }
});




</script>
</body>
</html>