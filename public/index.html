<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NBA Teammate Game</title>

  <!-- External CSS -->
  <link rel="stylesheet" href="style.css" />

  <!-- Socket.IO -->
  <script src="https://cdn.socket.io/4.6.1/socket.io.min.js" crossorigin="anonymous"></script>

  <!-- Supabase (ES Module) -->
  <script type="module">
    import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm'

    const SUPABASE_URL = 'https://rbjdlzgptvpfsnkakasj.supabase.co'
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJiamRsemdwdHZwZnNua2FrYXNqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg5ODYxMzksImV4cCI6MjA2NDU2MjEzOX0.U0EhIpOaKrHQmAJHcCBVJLKDGEW-m91eNj2bWRejYpk'
    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY)

    window.supabase = supabase // Expose for later use
  </script>
</head>

<body>
<nav>
  <a href="#" id="nav-title-link" style="text-decoration: none; color: inherit;">
    <span id="nav-title">üèÄ Who He Played With</span>
  </a>
  
  <div class="nav-dropdown" id="nav-dropdown" style="display: none;">
    <button class="nav-dropdown-btn" id="nav-dropdown-btn">
      <span id="nav-username">Menu</span>
      <span class="dropdown-arrow">‚ñº</span>
    </button>
   <div class="nav-dropdown-content" id="nav-dropdown-content">
  <a href="#" id="nav-dropdown-profile">Profile</a>
  <a href="#" id="nav-dropdown-signout">Sign Out</a>
</div>
  </div>
</nav>





<!-- üîë Sign Up / Sign In -->
<section data-route="/signup">
  <!-- Game Title and Subtitle -->
  <div class="game-intro">
    <h1>Who He Played With</h1>
    <p class="game-subtitle">Test your NBA knowledge by connecting players through their teammates</p>
  </div>

  <!-- How to Play Section -->
 <div class="how-to-play">
  <h3>How to Play</h3>
  <div class="rules-grid">
    <div class="rule-item">
      <span class="rule-number">1</span>
      <p>A random NBA player is chosen as the starting point</p>
    </div>
    <div class="rule-item">
      <span class="rule-number">2</span>
      <p>Take turns naming a <strong>regular season teammate</strong> of the current player</p>
    </div>
    <div class="rule-item">
      <span class="rule-number">3</span>
      <p>Players must have been active on the same team for at least one regular season game at any point in their career (they don't need to have played together on court)</p>
    </div>
    <div class="rule-item">
      <span class="rule-number">4</span>
      <p>Each correct guess becomes the new current player</p>
    </div>
    <div class="rule-item">
      <span class="rule-number">5</span>
      <p>You have <strong>30 seconds per turn</strong> and can guess as many times as you want within the time limit</p>
    </div>
    <div class="rule-item">
      <span class="rule-number">6</span>
      <p>Don't run out of time - keep the chain going!</p>
    </div>
  </div>
</div>

  <div class="auth-tabs-container">
    <div class="auth-tabs">
      <button id="tab-signup" class="auth-tab active" type="button">Sign Up</button>
      <button id="tab-signin" class="auth-tab" type="button">Sign In</button>
    </div>
    <div class="auth-forms-row">
      <form id="signupForm" class="auth-form active" autocomplete="off">
        <h2>Sign Up</h2>
        <input type="email" id="signup-email" placeholder="Email" required>
        <input type="password" id="signup-password" placeholder="Password" required>
        <input id="signup-username" placeholder="Username" required>
        <button id="signupBtn" type="submit">Sign Up</button>
      </form>
      <form id="signinForm" class="auth-form" autocomplete="off">
        <h2>Sign In</h2>
        <input type="email" id="signin-email" placeholder="Email" required>
        <input type="password" id="signin-password" placeholder="Password" required>
        <button id="signinBtn" type="submit">Sign In</button>
        <p><a href="#" id="forgotPasswordLink">Forgot password?</a></p>
      </form>
    </div>
  </div>
</section>



 <!-- üîó Check your email after sign up -->
  <section data-route="/verify" class="hidden">
    <h2>Check your email!</h2>
    <p>We've sent you a confirmation link. Click it to verify your account.</p>
  </section>


   <!-- ‚úÖ Confirmation success -->
  <section data-route="/confirmed" class="hidden">
    <h2>Account Confirmed</h2>
    <p>Your email is verified! You can now continue.</p>
    <button id="confirmedContinueBtn">Continue</button>
  </section>

  <!-- üîë Reset password -->
  <section data-route="/reset" class="hidden">
    <h2>Reset Password</h2>
    <input type="email" id="reset-email" placeholder="Email">
    <button id="resetBtn">Send Reset Link</button>
  </section>

  <!-- ‚úÖ Reset success -->
  <section data-route="/reset-confirmed" class="hidden">
    <h2>Password Reset</h2>
    <p>Check your email for a link to set a new password.</p>
  </section>

<!-- Set password -->
  <section data-route="/update-password" class="hidden">
  <h2>Set a New Password</h2>
  <input type="password" id="new-password" placeholder="New password" />
  <button id="updatePasswordBtn">Update Password</button>
</section>


  <!-- ‚úèÔ∏è Create username/profile
  <section data-route="/username" class="hidden">
    <h2>Create Profile</h2>
    <input id="create-username" placeholder="Choose a username">
    <button id="saveUsernameBtn">Save</button>
  </section> -->


<!-- Home Screen -->
<section id="homeSelection" data-route="/home" class="hidden" style="text-align: center; margin-top: 2rem; position: relative;">
  
  <h2 id="home-welcome"></h2>

  <div id="gameModeSelection" style="margin-top: 1rem;">
    <button id="privateGameBtn">Start Private Game</button>
    <button id="findGameBtn">Join Public Game</button>
  </div>

  <div id="playerStats" style="margin-top: 2rem;">
    <h3>Your Stats</h3>
    <p id="player-history">Games played, wins, and other stats will appear here.</p>
  </div>
</section>


<!-- Profile Section -->
<section id="profileSection" data-route="/profile">
  <h1>Your Profile</h1>
  
  <div class="profile-container">
    <!-- User Info Card -->
    <div class="profile-info-card">
      <h2>Account Information</h2>
      <div class="profile-field">
        <label>Username:</label>
        <span id="profile-username">Loading...</span>
      </div>
      <div class="profile-field">
        <label>Email:</label>
        <span id="profile-email">Loading...</span>
      </div>
      <div class="profile-field">
        <label>Member Since:</label>
        <span id="profile-member-since">Loading...</span>
      </div>
    </div>

    <!-- Stats Card -->
    <div class="profile-stats-card">
      <h2>Game Statistics</h2>
      <div class="profile-stats">
        <div class="stat-card">
          <div class="stat-number" id="profile-total-games">0</div>
          <div class="stat-label">Games Played</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="profile-games-won">0</div>
          <div class="stat-label">Games Won</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="profile-win-rate">0%</div>
          <div class="stat-label">Win Rate</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="profile-avg-guesses">0</div>
          <div class="stat-label">Avg Guesses</div>
        </div>
      </div>
    </div>

    <!-- Actions -->
    <div class="profile-actions">
      <button id="profile-signout-btn" class="signout-button">Sign Out</button>
    </div>
  </div>
</section>



<!-- Invite link container (used only in private games) -->
<section id="inviteLinkContainer" data-route="/invite" class="hidden" style="text-align: center; margin-top: 1rem;"></section>

<!-- Status message -->
<section id="status" data-route="/status" style="text-align: center; margin-top: 1rem;"></section>

<!-- Waiting Room View -->
<section id="waitingRoom" data-route="/waiting" class="hidden" style="text-align: center; margin-top: 2rem;">
  <h2>Waiting Room</h2>
  <p id="waitingStatus">Waiting for another player to join...</p>
  <code id="displayRoomCode" style="font-size: 1.5rem; font-weight: bold;"></code>
  <div id="inviteLinkWrapper" style="margin-top: 1rem;">
  <p>Invite a friend to join using this link:</p>
  <input id="inviteLink" type="text" readonly style="width: 80%; max-width: 400px; padding: 0.5rem;" />
  <div style="display: flex; gap: 0.5rem; margin-top: 0.75rem; justify-content: center;">
    <button id="copyInviteBtn">Copy Link</button>
    <button id="shareInviteBtn">Share</button>
  </div>
  <div id="copyToast" style="display:none; color: green; margin-top: 0.5rem;">Link copied!</div>
</div>
</section>

<!-- Scoreboard UI -->
<!-- <section id="scoreboardSection">
  <div id="jumbotronScoreboard" class="scoreboard-box">
    <div class="scoreboard-header">
      <span id="player1Name">Player 1</span>
      <span id="player2Name">Player 2</span>
    </div>
    <div class="scoreboard-scores">
      <span id="player1Score" class="scoreDigits">0</span>
      <span id="player2Score" class="scoreDigits">0</span>
    </div>
  </div>
</section> -->


<!-- In-Game UI -->

<section id="gameArea" data-route="/play" class="hidden" style="position: relative;">
 <div id="playersDisplay">
  <span class="player-name you" id="playerYou">You</span>
  <span class="vs-separator">vs</span>
  <span class="player-name opponent" id="playerOpponent">Opponent</span>
</div>

  <div id="turnSection">
 <p class="turn-prompt" id="turnPromptText" style="display: flex; align-items: center; gap: 12px;">
  <!-- Dynamic content will be inserted here by JavaScript -->
  <img id="currentPlayerHeadshot" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAAvklEQVRoge3XsQ2AIBBF0ZLpDoBuwHFHqK8cQvMrIo3FLPHom/b2mX9rcNqZmZmZmZmZmZmdFz5ec3m6F3+v4PYs3PmR7JbiDD1N9g5IuT16CWYExozP7G9Czzxq/cE8ksYbFxExk2RcMUfYHNk0RMYPhk0QcMbJHUYyNsi9h5YDyYFSNqLD6c+5h3tGn+MO9ZftHJz5nz/rq3ZTzRzqkIxuYwAAAABJRU5ErkJggg==" alt="Current Player Headshot" width="60" height="60" style="border-radius: 50%; object-fit: cover;"/>
  <strong class="turn-player-name" id="currentPlayerName">Loading...</strong>
</p>



<div id="timer-container">
  <svg class="progress-ring" width="100" height="100" viewBox="0 0 100 100">
    <circle class="progress-ring-track" 
            cx="50" cy="50" r="45" 
            stroke="#e5e7eb" 
            stroke-width="6" 
            fill="transparent"/>
    <circle class="progress-ring-circle" 
            cx="50" cy="50" r="45" 
            stroke="#fbbf24" 
            stroke-width="6" 
            fill="transparent"
            stroke-dasharray="283"
            stroke-dashoffset="0"/>
  </svg>
  <div id="timer">30</div>
</div>


    <div id="guessControls" style="position: relative;">
      <input
        type="text"
        id="guessInput"
        placeholder="Type a teammate's name..."
        autocomplete="off"
        autocorrect="off"
        autocapitalize="off"
        spellcheck="false"
      />
      <button id="submitGuessBtn" disabled>Submit Guess</button>
      <div id="autocomplete-list"></div>
    </div>
  </div>

  <div id="messageContainer"></div>
</section>

<div id="successful-guesses-container" style="text-align: center; margin-top: 2rem;">
  
  <div id="card-deck" class="card-deck-container"></div>
</div>




<!-- Game Over UI -->
<section data-route="/gameover" class="hidden" style="text-align: center; margin-top: 2rem;">
  <div id="gameOverContainer" style="display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 1rem;">
    <!-- Game over message will be dynamically added here -->

    <!-- Add this container for winner/loser details -->
    <div id="gameOverResults" style="font-size: 1.2rem; margin-top: 1rem;"></div>
  </div>
  <button id="rematchBtn" style="margin-top: 1rem;">Request Rematch</button>
</section>




<script>
// 1. Global variables and state (outside DOMContentLoaded)
// Core state
  let roomId = null;
  let myRoomId = null;
  let selectedPlayer = null;
  let fetchTimeout = null;
  let gameStarted = false;
  let gameOver = false;
  let leadoffPlayerName = null;
  let myUsername = null;
  let opponentName = null;
  let successfulGuesses = [];
  let isPrivateGame = false;
  let socket = null;
  let isLeavingGame = false;
// ‚úÖ Global route tracker
  let currentRoute = '';
  let statusDiv = null;
  let socketConnected = false;
  let emitQueue = [];

  // DOM element references (assigned in DOMContentLoaded)
let guessInput = null;
let submitGuessBtn = null;
let rematchBtn = null;
let messagesEl = null;
let currentPlayerNameEl = null;
let currentPlayerHeadshotEl = null;
let currentPlayerHeadshotUrl = null;
let timerEl = null;
let autocompleteList = null;
let waitingRoom = null;
let gameArea = null;
let inviteLinkContainer = null;
let myUserId = null;
let storedHeadshots = new Map();
const DEFAULT_PLAYER_IMAGE = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAAvklEQVRoge3XsQ2AIBBF0ZLpDoBuwHFHqK8cQvMrIo3FLPHom/b2mX9rcNqZmZmZmZmZmZmdFz5ec3m6F3+v4PYs3PmR7JbiDD1N9g5IuT16CWYExozP7G9Czzxq/cE8ksYbFxExk2RcMUfYHNk0RMYPhk0QcMbJHUYyNsi9h5YDyYFSNqLD6c+5h3tGn+MO9ZftHJz5nz/rq3ZTzRzqkIxuYwAAAABJRU5ErkJggg==';




// 2. Function definitions (outside DOMContentLoaded)

async function validateAndCleanupSession() {
  const { data: { session } } = await supabase.auth.getSession();
  const storedUsername = localStorage.getItem('username');
  const storedUserId = localStorage.getItem('userId');
  
  // The key insight: session is either valid or null
  // There's no "invalid session object"
  
  if (!session) {
    // No session = definitely not authenticated
    if (storedUsername || storedUserId) {
      // Clean up stale localStorage
      console.log('Cleaning up stale localStorage data');
      localStorage.removeItem('username');
      localStorage.removeItem('userId');
      myUsername = null;
      myUserId = null;
    }
    return false; // Not authenticated
  }
  
  // Session exists and is valid
  // Ensure localStorage matches
  const expectedUsername = session.user.user_metadata?.username || session.user.email;
  const expectedUserId = session.user.id;
  
  if (storedUsername !== expectedUsername || storedUserId !== expectedUserId) {
    // Fix localStorage to match session
    localStorage.setItem('username', expectedUsername);
    localStorage.setItem('userId', expectedUserId);
    myUsername = expectedUsername;
    myUserId = expectedUserId;
  }
  
  return true; // Valid and consistent
}



 // ‚úÖ Sign Up handler
  async function signUp(e) {
    e.preventDefault(); // üõë Stop default form submit

    const email = document.getElementById('signup-email').value.trim();
    const password = document.getElementById('signup-password').value.trim();
    const username = document.getElementById('signup-username').value.trim();

    if (!email || !password || !username) {
      alert('Please fill in all fields.');
      return;
    }

    if (password.length < 6) {
      alert('Password must be at least 6 characters.');
      return;
    }

    console.log('[DEBUG] SignUp data =>', email, username);

    const { data, error } = await supabase.auth.signUp({
      email,
      password,
      options: {
        data: { username }
      }
    });

    if (error) {
      console.error('SignUp error:', error.message);
      return;
    }

    console.log('‚úÖ Sign Up successful:', data);
    navigateTo('/verify'); // üëà Show verification screen
  }

  // ‚úÖ Sign In handler
  async function signIn(e) {
    e.preventDefault(); // üõë Stop default form submit

    const email = document.getElementById('signin-email').value.trim();
    const password = document.getElementById('signin-password').value.trim();

    if (!email || !password) {
      alert('Please fill in all fields.');
      return;
    }

    console.log('[DEBUG] SignIn data =>', email);

    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password
    });

    if (error) {
      console.error('SignIn error:', error.message);
      alert(error.message);
      return;
    }

    console.log('‚úÖ Sign In successful:', data);
    const user = data.user;
    myUsername = user.user_metadata?.username || user.email;
    myUserId = user.id;
    localStorage.setItem('username', myUsername);
    localStorage.setItem('userId', myUserId);

    console.log('[DEBUG] Username set to:', myUsername);
    console.log('[DEBUG] UserId set to:', myUserId);

    if (socket && socket.connected) {
      socket.emit('userSignedIn', { userId: myUserId, username: myUsername });
    }

    const pendingRoomInvite = localStorage.getItem('pendingRoomInvite');
    if (pendingRoomInvite) {
      console.log('[DEBUG] Found pending room invite after sign in:', pendingRoomInvite);

      // Clear the pending invite and set up the room
      localStorage.removeItem('pendingRoomInvite');
      myRoomId = pendingRoomInvite;
      roomId = pendingRoomInvite;
      isPrivateGame = true;
      localStorage.setItem('privateRoomId', pendingRoomInvite);

      // Join the private room
      safeEmit('joinGame', {
        roomId: myRoomId,
        username: myUsername,
        userId: myUserId
      });
      navigateTo('/waiting');
      return;
    }
    
    navigateTo('/home'); 
  }


  function setupNavDropdown() {
  const dropdown = document.getElementById('nav-dropdown');
  const dropdownBtn = document.getElementById('nav-dropdown-btn');
  const dropdownContent = document.getElementById('nav-dropdown-content');
  const navTitleLink = document.getElementById('nav-title-link');
  const navDropdownProfile = document.getElementById('nav-dropdown-profile');
  const navDropdownSignout = document.getElementById('nav-dropdown-signout');

  if (!dropdown || !dropdownBtn) return;

  // Toggle dropdown on button click
  dropdownBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    dropdown.classList.toggle('open');
  });

  // Close dropdown when clicking outside
  document.addEventListener('click', (e) => {
    if (!dropdown.contains(e.target)) {
      dropdown.classList.remove('open');
    }
  });

  // Title link navigation
  if (navTitleLink) {
    navTitleLink.addEventListener('click', (e) => {
      e.preventDefault();
      dropdown.classList.remove('open');
      
      // Navigate based on auth state
      if (myUsername && myUserId) {
        navigateTo('/home');
      } else {
        navigateTo('/signup');
      }
    });
  }

  // Dropdown home link
  if (navDropdownProfile) {
  navDropdownProfile.addEventListener('click', (e) => {
    e.preventDefault();
    dropdown.classList.remove('open');
    
    if (myUsername && myUserId) {
      navigateTo('/profile');
    } else {
      navigateTo('/signup');
    }
  });
}

  // Dropdown signout link
  if (navDropdownSignout) {
    navDropdownSignout.addEventListener('click', async (e) => {
      e.preventDefault();
      dropdown.classList.remove('open');
      await signOut();
    });
  }
}

async function signOut() {
  try {
    // Check if user is in an active game
    if (gameStarted && !gameOver && socket && socket.connected) {
      // Emit a specific sign-out event to give opponent the win
      socket.emit('playerSignedOut', { 
        roomId: myRoomId || roomId,
        username: myUsername,
        reason: 'signed_out'
      });
    }
    
    // Set leaving game flag to prevent reconnection attempts
    isLeavingGame = true;
    localStorage.setItem('isLeavingGame', 'true');
    
    // Sign out from Supabase
    const { error } = await supabase.auth.signOut();
    if (error) {
      console.error('Sign out error:', error.message);
      alert('Sign out error: ' + error.message);
      return;
    }
    
    // Clear all game state and localStorage
    resetAllGameState();
    localStorage.clear();
    
    // Reset global variables
    myUsername = null;
    myUserId = null;
    myRoomId = null;
    roomId = null;
    gameStarted = false;
    gameOver = true;
    
    // Update UI and navigate
    updateNavUserState(null);
    navigateTo('/signup');
    
    console.log('Successfully signed out');
  } catch (error) {
    console.error('Unexpected sign out error:', error);
    alert('An unexpected error occurred during sign out.');
  }
}

async function loadProfileData() {
  // Update profile information
  const profileUsername = document.getElementById('profile-username');
  const profileEmail = document.getElementById('profile-email');
  const profileMemberSince = document.getElementById('profile-member-since');
  
  if (profileUsername) {
    profileUsername.textContent = myUsername || 'Guest';
  }
  
  // Get user session for email
  const { data: { session } } = await supabase.auth.getSession();
  if (profileEmail && session?.user?.email) {
    profileEmail.textContent = session.user.email;
  }
  
  if (profileMemberSince) {
    if (session?.user?.created_at) {
      const createdDate = new Date(session.user.created_at);
      profileMemberSince.textContent = createdDate.toLocaleDateString();
    } else {
      profileMemberSince.textContent = new Date().toLocaleDateString();
    }
  }
  
  // Load real stats from database
  await loadRealProfileStats();
}

async function loadRealProfileStats() {
  if (!myUserId) {
    // Set default values if no user
    document.getElementById('profile-total-games').textContent = '0';
    document.getElementById('profile-games-won').textContent = '0';
    document.getElementById('profile-win-rate').textContent = '0%';
    document.getElementById('profile-avg-guesses').textContent = '0';
    return;
  }
  
  try {
    const { data, error } = await supabase
      .from('user_stats')
      .select('games_played, wins, losses')
      .eq('user_id', myUserId)
      .single();
      
    if (data) {
      document.getElementById('profile-total-games').textContent = data.games_played || 0;
      document.getElementById('profile-games-won').textContent = data.wins || 0;
      
      const winRate = data.games_played > 0 
        ? Math.round((data.wins / data.games_played) * 100) 
        : 0;
      document.getElementById('profile-win-rate').textContent = `${winRate}%`;
      
      // Calculate average guesses (you may need to add this to your database)
      document.getElementById('profile-avg-guesses').textContent = '0'; // Placeholder
    }
  } catch (error) {
    console.error('Error loading profile stats:', error);
    // Set default values on error
    document.getElementById('profile-total-games').textContent = '0';
    document.getElementById('profile-games-won').textContent = '0';
    document.getElementById('profile-win-rate').textContent = '0%';
    document.getElementById('profile-avg-guesses').textContent = '0';
  }
}




function updateSplitScoreboard(stats, player1, player2) {
  const p1NameEl = document.getElementById('player1Name');
  const p2NameEl = document.getElementById('player2Name');

  if (!p1NameEl || !p2NameEl) {
    console.warn('[DEBUG] Scoreboard elements not found. Skipping updateSplitScoreboard.');
    return; // Or: queue the update!
  }

  const p1Name = player1 || 'Player 1';
  const p2Name = player2 || 'Player 2';

  p1NameEl.textContent = p1Name;
  p2NameEl.textContent = p2Name;

  const safeStats = stats || {};
  const player1Stats = safeStats[p1Name];
  const player2Stats = safeStats[p2Name];
  const p1Wins = (player1Stats && typeof player1Stats.wins === 'number') ? player1Stats.wins : 0;
  const p2Wins = (player2Stats && typeof player2Stats.wins === 'number') ? player2Stats.wins : 0;

  document.getElementById('player1Score').textContent = p1Wins;
  document.getElementById('player2Score').textContent = p2Wins;
}



function waitForScoreboard() {
  return new Promise((resolve) => {
    const check = () => {
      if (
        document.getElementById('player1Name') &&
        document.getElementById('player1Score')
      ) {
        resolve();
      } else {
        requestAnimationFrame(check);
      }
    };
    check();
  });
}



function markLeadoffInGuesses(guesses, leadoffName) {
  return guesses.map(g => ({
    ...g,
    isLeadoff: g.name === leadoffName
  }));
}





async function startPrivateGame() {
   // Validate session before starting
  const { data: { session } } = await supabase.auth.getSession();
  if (!session?.user?.id) {
    console.log('[startPrivateGame] No valid session, redirecting');
    navigateTo('/signup');
    return;
  }

  console.log('[DEBUG] startPrivateGame called');
  resetAllGameState();

  isPrivateGame = true;
  isLeavingGame = false;
  console.log('[DEBUG] Reset isLeavingGame to false for private game');

  if (!myUsername) {
    alert('Missing username');
    return;
  }

  if (gameStarted && !gameOver) {
    alert('Finish your current game first.');
    return;
  }

  // Generate new room and clear stale room data
  myRoomId = `room-${Math.random().toString(36).substring(2, 8)}`;
  console.log(`[DEBUG] Generated new private room: ${myRoomId}`);

  const { data } = await window.supabase.auth.getUser();
  const userId = data?.user?.id;
  if (!userId) {
    alert('Could not get your user ID. Please sign in again.');
    return;
  }
  
  myUserId = userId;
  localStorage.setItem('userId', myUserId);
  
  // ‚úÖ Set up waiting room UI BEFORE navigation
  const statusDiv = document.getElementById('status');
  if (statusDiv) {
    statusDiv.textContent = `Started private room: ${myRoomId}`;
  }
  
  const displayRoomCode = document.getElementById('displayRoomCode');
  if (displayRoomCode) {
    displayRoomCode.textContent = myRoomId;
  }

  const inviteInput = document.getElementById('inviteLink');
  if (inviteInput) {
    inviteInput.value = `${window.location.origin}?room=${myRoomId}`;
  }

  // Ensure waiting room is visible
  const waitingRoom = document.getElementById('waitingRoom');
  if (waitingRoom) {
    waitingRoom.classList.remove('hidden');
  }

  // Setup copy button listeners
  setupCopyInviteListeners();

  // ‚úÖ Navigate and then emit
  await navigateTo('/waiting');
  safeEmit('joinGame', { roomId: myRoomId, username: myUsername, userId });
}



async function joinPublicGame() {
  // Validate session before joining
  const { data: { session } } = await supabase.auth.getSession();
  if (!session?.user?.id) {
    console.log('[joinPublicGame] No valid session, redirecting');
    navigateTo('/signup');
    return;
  }

  console.log('[DEBUG] joinPublicGame called');
  resetAllGameState();


  if (socket && socket.connected && session.user) {
    socket.emit('userSignedIn', { 
      userId: session.user.id, 
      username: session.user.user_metadata?.username || session.user.email 
    });
  }

  isLeavingGame = false;
  localStorage.removeItem('isLeavingGame');

  if (!myUsername) {
    console.warn('[DEBUG] myUsername is null, attempting to recover from session');
    // Try to get username from current session
    const { data: { user } } = await supabase.auth.getUser();
    if (user) {
      myUsername = user.user_metadata?.username || user.email;
      localStorage.setItem('username', myUsername);
      console.log('[DEBUG] Recovered username:', myUsername);
    }

    // If still no username, show error
    if (!myUsername) {
      alert('Missing username. Please sign out and sign in again.');
      return;
    }
  }

  if (gameStarted && !gameOver) {
    alert('Finish your current game first.');
    return;
  }

  myRoomId = null;
  roomId = null;
  isPrivateGame = false;
  selectedPlayer = null;
  successfulGuesses = [];
  gameOver = false;
  gameStarted = false;
  leadoffPlayerName = null;
  opponentName = null;

  // Clear UI elements
  if (currentPlayerNameEl) currentPlayerNameEl.textContent = '';
  if (timerEl) timerEl.textContent = '';
  if (currentPlayerHeadshotEl) currentPlayerHeadshotEl.src = DEFAULT_PLAYER_IMAGE;

  // Clear turn history
  const cardDeck = document.getElementById('card-deck');
  if (cardDeck) cardDeck.innerHTML = '';

  // Clear any persistent localStorage
  localStorage.removeItem('privateRoomId');
  localStorage.removeItem('isLeavingGame');

  // ‚úÖ Ensure socket is connected (don't re-initialize)
  if (!socket || !socket.connected) {
    console.log('[joinPublicGame] Socket not ready, waiting for connection...');
    // Socket should already be initialized in DOMContentLoaded
  }

  // Fetch user_id from Supabase and emit findMatch with userId
  const { data: { user } } = await supabase.auth.getUser();
  const userId = user?.id;
  if (!userId) {
    alert('Could not get your user ID. Please sign in again.');
    return;
  }

  myUserId = userId;
  localStorage.setItem('userId', myUserId);

  console.log('[DEBUG] Navigating to /waiting...');
  await navigateTo('/waiting');

  // ‚úÖ Add this: Ensure status message is set for public games
  if (statusDiv) {
    statusDiv.textContent = 'Looking for an opponent...';
  }

  console.log('[DEBUG] Using safeEmit to find match:', myUsername, userId);
  safeEmit('findMatch', { username: myUsername, userId });
}



  function safeEmit(event, data) {
    if (!socket) {
      console.warn(`[safeEmit] Socket is null ‚Äî this shouldn't happen after DOMContentLoaded`);
      return; // Don't emit if socket isn't ready
    }

  emitQueue.push({ event, data });

  if (socket && socket.connected) {
    console.log(`[safeEmit] Socket connected ‚Äî emitting "${event}" immediately`);
    flushEmitQueue();
  } else {
    console.log(`[safeEmit] Socket not connected ‚Äî queued "${event}"`);
  }
}

function flushEmitQueue() {
  if (!socket) {
    console.warn(`[flushEmitQueue] Socket is null ‚Äî cannot flush`);
    return;
  }

  while (socket.connected && emitQueue.length > 0) {
    const { event, data } = emitQueue.shift();
    console.log(`[safeEmit] Flushing queued "${event}"`);
    socket.emit(event, data);
  }
}

function updateTimerStyle(timeLeft, totalTime = 30) {
  const timerEl = document.getElementById('timer');
  const progressRing = document.querySelector('.progress-ring-circle');
  
  if (!timerEl || !progressRing) return;
  
  // Calculate progress (0 to 1, where 1 is full time remaining)
  const progress = timeLeft / totalTime;
  
  // Get the radius from the SVG element (responsive)
  const radius = parseFloat(progressRing.getAttribute('r'));
  const circumference = 2 * Math.PI * radius;
  const offset = circumference * (1 - progress);
  
  // Update the progress ring
  progressRing.style.strokeDasharray = circumference;
  progressRing.style.strokeDashoffset = offset;
  
  // Remove existing classes
  progressRing.classList.remove('critical-time', 'low-time');
  
  // Add appropriate class based on time remaining
  if (timeLeft <= 5) {
    progressRing.classList.add('critical-time');
  } else if (timeLeft <= 10) {
    progressRing.classList.add('low-time');
  }
  
  // Update the number display with colon
  timerEl.textContent = `:${timeLeft}`;
}






function updateHeadshot(player) {
  if (currentPlayerHeadshotEl) {
    currentPlayerHeadshotEl.src = player.headshot_url || DEFAULT_PLAYER_IMAGE;
    currentPlayerHeadshotEl.alt = `${player.player_name || 'Unknown'} Headshot`;
  }
}

function triggerGameEndCardSpread() {
  const deckContainer = document.getElementById('card-deck');
  if (!deckContainer) return;
  
  // Add a small delay to let the game over UI settle
  setTimeout(() => {
    deckContainer.classList.add('game-ended');  // ‚úÖ Add to the container itself
    
    // Optional: Add a subtle sound effect or visual feedback
    console.log('üé¥ Cards spreading out to show the full game sequence!');
  }, 1000); // 1 second delay after game ends
}

function resetCardSpread() {
  const deckContainer = document.getElementById('card-deck');
  if (!deckContainer) return;
  
  // Remove the game-ended class
  deckContainer.classList.remove('game-ended');
  
  // ‚úÖ Also force remove any lingering transform styles
  deckContainer.style.transform = '';
  
  // ‚úÖ Reset any individual card transforms
  const cards = deckContainer.querySelectorAll('.player-card');
  cards.forEach(card => {
    card.style.transform = '';
    card.style.left = '';
    card.style.zIndex = '';
  });
  
  console.log('üé¥ Card spread animation reset for new game');
}



function attachRouteListeners(route) {
  supabase.auth.getSession().then(({ data }) => {
    updateNavUserState(data.session);
  });

  switch (route) {
    case '/signup':
      // Setup auth tab switching
      setupAuthTabs();
      // Only non-form button listeners (forms handled by setupFormListeners)
      const forgotPasswordLink = document.getElementById('forgotPasswordLink');
      if (forgotPasswordLink) {
        forgotPasswordLink.addEventListener('click', (e) => {
          e.preventDefault();
          navigateTo('/reset');
        });
      }
      break;

    case '/confirmed':
      const confirmedContinueBtn = document.getElementById('confirmedContinueBtn');
      if (confirmedContinueBtn) {
        confirmedContinueBtn.addEventListener('click', () => {
          handleAuthSuccess();
        });
      }
      // Update nav state for confirmed page
      updateNavUserState();
      break;

    case '/home':
      const privateGameBtn = document.getElementById('privateGameBtn');
      const findGameBtn = document.getElementById('findGameBtn');
      const signoutBtn = document.getElementById('signoutBtn');
      
      if (privateGameBtn) {
        privateGameBtn.addEventListener('click', () => {
          if (privateGameBtn.disabled) return; // Prevent multiple clicks
          privateGameBtn.disabled = true;
          setTimeout(() => privateGameBtn.disabled = false, 2000); // Re-enable after 2s

          isLeavingGame = false;
          startPrivateGame();
        });
      }

      if (findGameBtn) {
        findGameBtn.addEventListener('click', () => {
          if (findGameBtn.disabled) return; // Prevent multiple clicks
          findGameBtn.disabled = true;
          setTimeout(() => findGameBtn.disabled = false, 2000); // Re-enable after 2s

          isLeavingGame = false;
          joinPublicGame();
        });
      }

      if (signoutBtn) {
        signoutBtn.addEventListener('click', signOut);
      }

      loadPlayerStats();
      break;

      case '/profile':
  loadProfileData();
  
  const profileSignoutBtn = document.getElementById('profile-signout-btn');
  if (profileSignoutBtn) {
    profileSignoutBtn.addEventListener('click', signOut);
  }
  break;

    case '/play':
      // Game-specific listeners
      const submitGuessBtn = document.getElementById('submitGuessBtn');
      const rematchBtn = document.getElementById('rematchBtn');
      
      if (submitGuessBtn) {
        submitGuessBtn.addEventListener('click', submitGuess);
      }
      
      if (rematchBtn) {
        rematchBtn.addEventListener('click', requestRematch);
      }
      
      // Setup autocomplete for gameplay
      setupAutocompleteListeners();
      setupMobileInputFocus();
      break;

    case '/waiting':
      if (isPrivateGame && myRoomId) {
        const inviteInput = document.getElementById('inviteLink');
        if (inviteInput) {
          inviteInput.value = `${window.location.origin}?room=${myRoomId}`;
        }

        const roomCodeEl = document.getElementById('displayRoomCode');
        if (roomCodeEl) {
          roomCodeEl.textContent = myRoomId;
        }

        waitingRoom.classList.remove('hidden');
      }
      // Setup copy invite button listener anyway
      setupCopyInviteListeners();
      break;


    // Add other route handlers as needed
  }
}

function navigateTo(path, options = {}) {
  return new Promise((resolve) => {
    // ‚úÖ Don't reset leaving game flag when navigating to waiting room
    if (path === '/home') {
      isLeavingGame = false;
      localStorage.removeItem('isLeavingGame');
    } else if (path === '/waiting' && isPrivateGame && myRoomId) {
      // Preserve room state when going to waiting room
      isLeavingGame = false;
      localStorage.removeItem('isLeavingGame');
      console.log('[DEBUG] Preserving room state for waiting room navigation');
    }

    currentRoute = path;

    if (!options.skipPush) {
      history.pushState({}, '', path);
    }

    showRouteSection(path);
    updateUIForRoute(path);
    attachRouteListeners(path);

    requestAnimationFrame(() => {
      resolve();
    });
  });
}



function setupMobileInputFocus() {
  const guessInput = document.getElementById('guessInput');
  if (guessInput) {
    guessInput.addEventListener('focus', () => {
      // Only apply if screen width is <= 480px (mobile)
      if (window.innerWidth <= 480) {
        const guessControls = document.getElementById('guessControls');
        const topOffset = guessControls.getBoundingClientRect().top + window.scrollY;
        const padding = parseFloat(getComputedStyle(document.body).paddingTop) || 16;

        window.scrollTo({
          top: topOffset - padding,
          behavior: 'smooth'
        });
      }
    });
  }
}

function setupAuthTabs() {
  const tabSignup = document.getElementById('tab-signup');
  const tabSignin = document.getElementById('tab-signin');
  const signupForm = document.getElementById('signupForm');
  const signinForm = document.getElementById('signinForm');
  
  if (tabSignup && tabSignin && signupForm && signinForm) {
    tabSignup.addEventListener('click', function() {
      tabSignup.classList.add('active');
      tabSignin.classList.remove('active');
      signupForm.classList.add('active');
      signinForm.classList.remove('active');
    });
    
    tabSignin.addEventListener('click', function() {
      tabSignin.classList.add('active');
      tabSignup.classList.remove('active');
      signinForm.classList.add('active');
      signupForm.classList.remove('active');
    });
  }
}



  function submitGuess() {
  const guess = guessInput.value.trim();
  clearGuessError();

  if (!guess) {
    showGuessError('Enter a guess');
    return;
  }
  if (guess !== selectedPlayer) {
    showGuessError('Please select a player from the dropdown list.');
    return;
  }

  socket.emit('playerGuess', { roomId, guess });
  guessInput.value = '';
  selectedPlayer = null;
  submitGuessBtn.disabled = true;
  clearAutocomplete();
}


function requestRematch() {
  if (!myRoomId) {
    console.error('No roomId defined. Cannot request rematch.');
    return;
  }
  rematchBtn.disabled = true;
  rematchBtn.textContent = 'Waiting for opponent...';
  socket.emit('requestRematch', { roomId: myRoomId });
}


function resetGameUI() {
  gameStarted = true;
  gameOver = false;

  // Clear old timers
  if (window.timerInterval) {
    clearInterval(window.timerInterval);
    window.timerInterval = null;
  }

  guessInput.disabled = true;
  submitGuessBtn.disabled = true;
  guessInput.value = '';
  clearGuessError();
  clearAutocomplete();

  // Reset rematch button visibility and style
  rematchBtn.style.display = 'none';
  rematchBtn.disabled = false;
  rematchBtn.textContent = 'Rematch';
  rematchBtn.style.backgroundColor = '';

  // Reset UI parts
  messagesEl.innerHTML = '';
  messagesEl.style.display = 'block';

  // ‚úÖ CRITICAL: Reset card spread animation BEFORE clearing cards
  resetCardSpread();

  // Clear stored headshots for new game
  storedHeadshots.clear();

  successfulGuesses.length = 0;
  document.getElementById('card-deck').innerHTML = '';
  renderSuccessfulGuesses();

  currentPlayerNameEl.textContent = 'Loading...';
  timerEl.textContent = ':30';

  // ‚úÖ Use CSS classes instead of inline styles
  waitingRoom.classList.add('hidden');     // Instead of style.display = 'none'
  gameArea.classList.remove('hidden');     // Instead of style.display = 'block'
  document.getElementById('turnSection').style.display = 'block';

  // Hide game over container
  const gameOverContainer = document.getElementById('gameOverContainer');
  gameOverContainer.innerHTML = '';
  gameOverContainer.style.display = 'none';

  // Clear persistent rematch message
  const messageContainer = document.getElementById('messageContainer');
  if (messageContainer) {
    messageContainer.innerHTML = '';
  }
}



function showGuessError(message) {
  showMessage(message, 'error');
}


 function clearGuessError() {
    const container = document.getElementById('messageContainer');
    container.innerHTML = '';
  }

  function showMessage(message, type = 'info', persist = false) {
    const container = document.getElementById('messageContainer');
    container.innerHTML = '';

    const div = document.createElement('div');
    div.textContent = message;
    div.classList.add('message');

    if (type === 'error') div.classList.add('error');

    container.appendChild(div);

    if (!persist) {
      setTimeout(() => {
        div.classList.add('fade-out');
        setTimeout(() => container.innerHTML = '', 1000);
      }, 3000);
    }
  }




  function clearAutocomplete() {
    autocompleteList.innerHTML = '';
    autocompleteList.style.display = 'none';
  }


function showAutocompleteSuggestions(suggestions) {
  const list = document.getElementById('autocomplete-list');
  list.innerHTML = '';

  if (suggestions.length === 0) {
    list.style.display = 'none';  // Hide when empty
    return;
  }

  list.style.display = 'block'; // Show when populated

  suggestions.forEach(suggestionEl => {
    // suggestionEl is an element, append it directly
    list.appendChild(suggestionEl);
  });
}

async function ensureUserSession() {
  const { data: { session }, error } = await supabase.auth.getSession();
  
  if (error || !session?.user) {
    console.warn('[ensureUserSession] No valid session!');
    myUsername = null;
    myUserId = null;
    return false;
  }
  
  const user = session.user;
  myUserId = user.id;
  myUsername = user.user_metadata?.username || user.email;
  
  // Sync localStorage
  localStorage.setItem('username', myUsername);
  localStorage.setItem('userId', myUserId);
  
  console.debug('[ensureUserSession] Session validated:', myUsername, myUserId);
  return true;
}


function resetAllGameState() {
  roomId = null;
  myRoomId = null;
  selectedPlayer = null;
  gameStarted = false;
  gameOver = true;
  leadoffPlayerName = null;
  opponentName = null;
  successfulGuesses = [];
  isPrivateGame = false;
  isLeavingGame = false;
  
  localStorage.removeItem('privateRoomId');
  localStorage.removeItem('isLeavingGame');
  
  // Reset UI elements
  if (currentPlayerNameEl) currentPlayerNameEl.textContent = '';
  if (timerEl) timerEl.textContent = '';
  if (currentPlayerHeadshotEl) currentPlayerHeadshotEl.src = DEFAULT_PLAYER_IMAGE;
  
  const cardDeck = document.getElementById('card-deck');
  if (cardDeck) cardDeck.innerHTML = '';
  
  resetCardSpread();
}



function renderSuccessfulGuesses() {
  const deckContainer = document.getElementById('card-deck');
  if (!deckContainer || !Array.isArray(successfulGuesses)) return;

  deckContainer.innerHTML = '';
  const reversedGuesses = [...successfulGuesses].reverse();

  reversedGuesses.forEach((guessObj, index) => {
    const name = guessObj?.name || '';
    const isLeadoff = !!guessObj?.isLeadoff;
    const guesser = guessObj?.guesser || '';
    const sharedTeams = Array.isArray(guessObj?.sharedTeams) ? guessObj.sharedTeams : [];
    const headshotUrl = guessObj?.headshot_url || DEFAULT_PLAYER_IMAGE;

    console.log(`Card ${index}: ${name}, headshot: ${headshotUrl}`);

    if (!name) return;

    const card = document.createElement('div');
    card.className = 'player-card';
    
    // Set the headshot URL as a CSS custom property
    card.style.setProperty('--headshot-url', `url("${headshotUrl}")`);
    card.setAttribute('data-headshot', headshotUrl);
    
    if (index === 0 && successfulGuesses.length > 1) {
      card.classList.add('new-card');
    }
    
    if (isLeadoff) {
      card.classList.add('leadoff');
    } else if (guesser === myUsername) {
      card.classList.add('your-guess');
    } else {
      card.classList.add('opponent-guess');
    }

    // Rest of the card creation code remains the same...
    const headerEl = document.createElement('div');
    headerEl.className = 'card-header';
    headerEl.textContent = isLeadoff ? 'Leadoff Player' : 'Teammate';
    card.appendChild(headerEl);

    const nameEl = document.createElement('div');
    nameEl.className = 'card-player-name';
    nameEl.textContent = name;
    card.appendChild(nameEl);

    const connectionEl = document.createElement('div');
    connectionEl.className = 'card-connection';
    
    if (!isLeadoff && sharedTeams.length > 0) {
      const teamStrings = sharedTeams.map(team => {
        if (typeof team === 'object' && team.team && team.years) {
          return `${team.team} (${team.years})`;
        }
        return team;
      });
      
      connectionEl.innerHTML = `<strong>Connected via:</strong><br>${teamStrings.join('<br>')}`;
    } else if (isLeadoff) {
      connectionEl.innerHTML = '<strong>Starting Player</strong><br>Begin the chain!';
    }
    card.appendChild(connectionEl);

    const footerEl = document.createElement('div');
    footerEl.className = 'card-footer';
    if (isLeadoff) {
      footerEl.textContent = 'Game Start';
    } else if (guesser === myUsername) {
      footerEl.textContent = 'Guessed by You';
    } else {
      footerEl.innerHTML = `Guessed by<br>${guesser}`;
    }
    card.appendChild(footerEl);

    deckContainer.appendChild(card);
  });
}






function showRouteSection(path) {
  const allSections = document.querySelectorAll('section[data-route]');
  let matched = false;

  allSections.forEach(section => {
    const route = section.getAttribute('data-route');
    if (route === path) {
      section.classList.remove('hidden');
      matched = true;
    } else {
      section.classList.add('hidden');
    }
  });

  // Fallback if no matching route found
  if (!matched) {
    const defaultSection = document.querySelector('section[data-route="/signup"]');
    if (defaultSection) {
      defaultSection.classList.remove('hidden');
    }
  }
}

function updateUIForRoute(path) {
  if (path !== currentRoute) {
    console.debug('[updateUIForRoute] Skipped because stale:', path, 'Expected:', currentRoute);
    return;
  }

  console.debug('[updateUIForRoute] Handling:', path);

  if (path === '/home') {
    console.log('[DEBUG] updateUIForRoute: Handling /home');

    updateNavUserState();

    if (socket && socket.connected) {
      isLeavingGame = true;
      socket.emit('leaveGame');
    }

    gameStarted = false;
    gameOver = true;
    roomId = null;
    myRoomId = null;
    isPrivateGame = false;
    selectedPlayer = null;
    successfulGuesses = [];

    const welcomeEl = document.getElementById('home-welcome');
    if (welcomeEl && myUsername) {
      welcomeEl.textContent = `Welcome, ${myUsername}! Choose your game mode below.`;
    }
  }

 if (path === '/waiting') {
  if (isLeavingGame && !isPrivateGame) {
    console.log('[DEBUG] updateUIForRoute: Skipping /waiting because isLeavingGame is true');
    return;
  }
  
  // ‚úÖ Ensure isLeavingGame is false for waiting room
    if (isPrivateGame && myRoomId) {
    isLeavingGame = false;
    localStorage.removeItem('isLeavingGame');
    console.log('[DEBUG] Cleared isLeavingGame flag for private room:', myRoomId);
  }

  // Fix: Use correct element ID
  const waitingStatus = document.getElementById('waitingStatus');
  if (waitingStatus) {
    waitingStatus.textContent = isPrivateGame
      ? 'Waiting for a friend to join...'
      : 'Looking for an opponent...';
  }

  // Fix: Ensure status div is updated
  const statusDiv = document.getElementById('status');
  if (statusDiv && isPrivateGame && myRoomId) {
    statusDiv.textContent = `Started private room: ${myRoomId}`;
  }

  const codeEl = document.getElementById('displayRoomCode');
  const inviteWrapper = document.getElementById('inviteLinkWrapper');
  const inviteInput = document.getElementById('inviteLink');

  if (codeEl) {
    if (isPrivateGame && myRoomId) {
      const displayCode = myRoomId.replace('room-', '').substring(0, 8);
      codeEl.textContent = displayCode;
      codeEl.style.display = 'block';
    } else {
      codeEl.style.display = 'none';
    }
  }

  if (inviteWrapper && inviteInput) {
    if (isPrivateGame && myRoomId) {
      const inviteUrl = `${window.location.origin}?room=${myRoomId}`;
      inviteInput.type = 'text';
      inviteInput.value = inviteUrl;
      inviteWrapper.style.display = 'block';
    } else {
      inviteWrapper.style.display = 'none';
    }
  }

  // Fix: Ensure waiting room is visible
  const waitingRoom = document.getElementById('waitingRoom');
  if (waitingRoom) {
    waitingRoom.classList.remove('hidden');
  }
}


  const guessContainer = document.getElementById('successful-guesses-container');
  if (guessContainer) {
    guessContainer.style.display = (path === '/play' || path === '/gameover') ? 'block' : 'none';
  }

  const scoreboard = document.getElementById('scoreboardSection');
  if (scoreboard) {
    if (path === '/play' || path === '/gameover') {
      scoreboard.classList.remove('hidden');
    } else {
      scoreboard.classList.add('hidden');
    }
  }
}




function setupFormListeners() {
  // Signup form
  const signupForm = document.getElementById('signupForm');
  if (signupForm) {
    signupForm.addEventListener('submit', signUp);
    console.log('[DEBUG] signupForm listener attached');
  } else {
    console.warn('[WARN] signupForm not found - may not be on signup route');
  }

  // Signin form
  const signinForm = document.getElementById('signinForm');
  if (signinForm) {
    signinForm.addEventListener('submit', signIn);
    console.log('[DEBUG] signinForm listener attached');
  } else {
    console.warn('[WARN] signinForm not found - may not be on signin route');
  }

  // Reset password form
  const resetForm = document.getElementById('resetForm');
  if (resetForm) {
    resetForm.addEventListener('submit', resetPassword);
    console.log('[DEBUG] resetForm listener attached');
  } else {
    console.warn('[WARN] resetForm not found - may not be on reset route');
  }

  // Reset password button (not a form)
  const resetBtn = document.getElementById('resetBtn');
if (resetBtn) {
  resetBtn.addEventListener('click', resetPassword);
  console.log('[DEBUG] resetBtn listener attached');
} else {
  console.warn('[WARN] resetBtn not found - may not be on reset route');
}

// Update password button (not a form)
const updatePasswordBtn = document.getElementById('updatePasswordBtn');
if (updatePasswordBtn) {
  updatePasswordBtn.addEventListener('click', updatePassword);
  console.log('[DEBUG] updatePasswordBtn listener attached');
} else {
  console.warn('[WARN] updatePasswordBtn not found - may not be on update-password route');
}

  // Update password form
  const updatePasswordForm = document.getElementById('updatePasswordForm');
  if (updatePasswordForm) {
    updatePasswordForm.addEventListener('submit', updatePassword);
    console.log('[DEBUG] updatePasswordForm listener attached');
  } else {
    console.warn('[WARN] updatePasswordForm not found - may not be on update-password route');
  }

  // Username form (if you have one for setting username)
  const usernameForm = document.getElementById('usernameForm');
  if (usernameForm) {
    usernameForm.addEventListener('submit', setUsername);
    console.log('[DEBUG] usernameForm listener attached');
  } else {
    console.warn('[WARN] usernameForm not found - may not be on username route');
  }
}



function handleGoHome() {
  console.debug('[CLIENT] handleGoHome called');

  resetAllGameState();

  // ‚úÖ Mark that you‚Äôre intentionally leaving ‚Äî and persist it!
  isLeavingGame = true;
  localStorage.setItem('isLeavingGame', 'true');

  // ‚úÖ Tell server if in an active game
  if (socket && socket.connected && gameStarted && !gameOver) {
    socket.emit('leaveGame');
  }

  // ‚úÖ Always clear local game state
  myRoomId = null;
  roomId = null;
  isPrivateGame = false;
  gameStarted = false;
  gameOver = true;
  selectedPlayer = null;
  successfulGuesses = [];

  localStorage.removeItem('privateRoomId');

  navigateTo('/home');
}

function setupCopyInviteListeners() {
  const copyInviteBtn = document.getElementById('copyInviteBtn');
  const shareInviteBtn = document.getElementById('shareInviteBtn');
  const copyToast = document.getElementById('copyToast');
  const inviteInput = document.getElementById('inviteLink');

  if (!copyInviteBtn || !copyToast || !inviteInput) {
    return;
  }

  // Enhanced mobile/tablet detection
  function isMobileOrTablet() {
    // Check for touch capability
    const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    
    // Check screen size (mobile/tablet range)
    const isMobileSize = window.innerWidth <= 1024; // Tablets typically ‚â§ 1024px
    
    // Check user agent for mobile/tablet indicators
    const userAgent = navigator.userAgent.toLowerCase();
    const mobileKeywords = [
      'mobile', 'android', 'iphone', 'ipad', 'ipod', 
      'blackberry', 'windows phone', 'tablet'
    ];
    const hasMobileUA = mobileKeywords.some(keyword => userAgent.includes(keyword));
    
    // Device must have touch AND (be mobile-sized OR have mobile user agent)
    return hasTouch && (isMobileSize || hasMobileUA);
  }

  // Show share button only on mobile/tablet with Web Share API support
  if (shareInviteBtn && navigator.share && isMobileOrTablet()) {
    shareInviteBtn.style.display = 'inline-block';
    console.log('[Share] Share button enabled for mobile/tablet device');
  } else {
    if (shareInviteBtn) {
      shareInviteBtn.style.display = 'none';
    }
    console.log('[Share] Share button hidden - desktop or no Web Share API');
  }

  // Copy functionality
  copyInviteBtn.addEventListener('click', () => {
    navigator.clipboard.writeText(inviteInput.value)
      .then(() => {
        copyToast.textContent = 'Link copied!';
        copyToast.style.display = 'block';
        copyInviteBtn.disabled = true;

        setTimeout(() => {
          copyToast.style.display = 'none';
          copyInviteBtn.disabled = false;
        }, 2000);
      })
      .catch(err => {
        // Fallback for older browsers
        inviteInput.select();
        inviteInput.setSelectionRange(0, 99999);
        document.execCommand('copy');
        
        copyToast.textContent = 'Link copied!';
        copyToast.style.display = 'block';
        setTimeout(() => copyToast.style.display = 'none', 2000);
      });
  });

  // Native share functionality
  if (shareInviteBtn) {
    shareInviteBtn.addEventListener('click', async () => {
      const shareData = {
        title: 'Join my NBA Teammate Game!',
        text: 'Can you guess NBA teammates? Join my private game!',
        url: inviteInput.value
      };

      try {
        if (navigator.share) {
          await navigator.share(shareData);
          copyToast.textContent = 'Shared successfully!';
          copyToast.style.display = 'block';
          setTimeout(() => copyToast.style.display = 'none', 2000);
        }
      } catch (err) {
        // User cancelled or error occurred
        if (err.name !== 'AbortError') {
          console.log('Share failed, falling back to copy');
          // Fallback to copy
          copyInviteBtn.click();
        }
      }
    });
  }

  // Re-check on window resize (for device rotation)
  window.addEventListener('resize', () => {
    if (shareInviteBtn && navigator.share) {
      if (isMobileOrTablet()) {
        shareInviteBtn.style.display = 'inline-block';
      } else {
        shareInviteBtn.style.display = 'none';
      }
    }
  });
}




async function handleAuthSuccess() {
  const { data: { user }, error } = await supabase.auth.getUser();
  if (error || !user) {
    console.error('No user signed in');
    navigateTo('/signup');
    return;
  }

  const username = user.user_metadata?.username || null;

  if (!username) {
    console.error('No username found in user_metadata!');
    navigateTo('/signup');
    return;
  }

  // Try updating profiles row, but don‚Äôt block navigation if it fails
  const { error: updateError } = await supabase
    .from('profiles')
    .update({ username })
    .eq('id', user.id);

  if (updateError) {
    console.warn('Warning: Error updating profile:', updateError.message);
  } else {
    console.log('‚úÖ Username saved to profiles:', username);
  }

  myUsername = username;
  localStorage.setItem('username', myUsername);

  // Clear URL hash to remove confirmation tokens
  history.replaceState(null, '', window.location.pathname);

  const pendingRoomInvite = localStorage.getItem('pendingRoomInvite');
  if (pendingRoomInvite) {
    console.log('[DEBUG] Found pending room invite after email confirmation:', pendingRoomInvite);

    // Clear the pending invite and set up the room
    localStorage.removeItem('pendingRoomInvite');
    myRoomId = pendingRoomInvite;
    roomId = pendingRoomInvite;
    isPrivateGame = true;
    localStorage.setItem('privateRoomId', pendingRoomInvite);

    // Join the private room
    safeEmit('joinGame', {
      roomId: myRoomId,
      username: myUsername,
      userId: myUserId
    });
    navigateTo('/waiting');
    return;
  }

  navigateTo('/home');
}

async function forceSignOut() {
  console.log('[forceSignOut] Cleaning up invalid session...');
  
  // ‚úÖ Preserve pending room invite
  const pendingRoomInvite = localStorage.getItem('pendingRoomInvite');
  
  try {
    await supabase.auth.signOut();
  } catch (error) {
    console.warn('[forceSignOut] Supabase signout error:', error);
  }
  
  // Clear everything
  localStorage.clear();
  
  // ‚úÖ Restore pending room invite if it existed
  if (pendingRoomInvite) {
    localStorage.setItem('pendingRoomInvite', pendingRoomInvite);
  }
  
  myUsername = null;
  myUserId = null;
  myRoomId = null;
  roomId = null;
  isPrivateGame = false;
  gameStarted = false;
  gameOver = true;
  
  resetAllGameState();
  await updateNavUserState(null);
  navigateTo('/signup');
}






async function updateNavUserState(session) {
  const navTitle = document.getElementById('nav-title');
  const navDropdown = document.getElementById('nav-dropdown');
  const navUsername = document.getElementById('nav-username');

  if (!navTitle || !navDropdown) return;

  // If no session provided, get current session
  if (!session) {
    const { data } = await supabase.auth.getSession();
    session = data.session;
  }

  const hasValidSession = session?.user && myUsername && myUserId;

  if (!hasValidSession) {
    // Not logged in - hide dropdown
    navTitle.style.display = 'inline-block';
    navDropdown.style.display = 'none';
  } else {
    // Logged in - show dropdown with username
    navTitle.style.display = 'inline-block';
    navDropdown.style.display = 'block';
    
    if (navUsername) {
      navUsername.textContent = myUsername || 'Menu';
    }
  }
}




async function resetPassword() {
  const emailInput = document.getElementById('reset-email');
  const email = emailInput.value.trim();

  if (!email) {
    alert('Please enter your email address.');
    return;
  }

  try {
    const { data, error } = await supabase.auth.resetPasswordForEmail(email, {
      redirectTo: `${window.location.origin}/update-password`
    });

    if (error) {
      console.error('[ERROR] Supabase reset error:', error.message);
      alert('Error sending reset email: ' + error.message);
      return;
    }

    console.log('[INFO] Password reset email sent:', data);
    navigateTo('/reset-confirmed'); // Switch to your "Check your email" screen!
  } catch (err) {
    console.error('[ERROR] Unexpected:', err);
    alert('An unexpected error occurred.');
  }
}

async function updatePassword() {
  const newPasswordInput = document.getElementById('new-password');
  const newPassword = newPasswordInput.value.trim();

  if (!newPassword) {
    alert('Please enter a new password.');
    return;
  }

  const { data, error } = await supabase.auth.updateUser({
    password: newPassword
  });

  if (error) {
    console.error('[ERROR] Failed to update password:', error.message);
    alert('Error updating password: ' + error.message);
    return;
  }

  console.log('[INFO] Password updated:', data);

  // ‚úÖ Redirect the user back to sign in, or show success
  alert('Password updated successfully! Please sign in with your new password.');
  navigateTo('/signup');
}





function setupAutocompleteListeners() {
  const guessInput = document.getElementById('guessInput');
  const submitGuessBtn = document.getElementById('submitGuessBtn');
  
  if (!guessInput || !submitGuessBtn) {
    console.warn('Autocomplete elements not found');
    return;
  }

  guessInput.addEventListener('input', function() {
    const val = this.value.trim();
    clearAutocomplete();
    selectedPlayer = null;
    submitGuessBtn.disabled = true;

    if (!val) {
      showAutocompleteSuggestions([]);
      return;
    }

    if (fetchTimeout) clearTimeout(fetchTimeout);

    fetchTimeout = setTimeout(async () => {
      try {
        const res = await fetch(`/players?q=${encodeURIComponent(val)}`);
        if (!res.ok) throw new Error('Network response not ok');

        const results = await res.json();
        if (results.length === 0) {
          showAutocompleteSuggestions([]);
          return;
        }

        const suggestions = results.map(player => {
          const wrapper = document.createElement('div');
          wrapper.className = 'autocomplete-item';

          const nameSpan = document.createElement('span');
          nameSpan.textContent = player.player_name;

          const yearsSpan = document.createElement('span');
          yearsSpan.className = 'career-years';
          yearsSpan.textContent = ` ${player.first_year || '?'}‚Äì${player.last_year || '?'}`;
          yearsSpan.style.fontSize = '0.8em';
          yearsSpan.style.color = 'gray';
          yearsSpan.style.marginLeft = '5px';

          wrapper.appendChild(nameSpan);
          wrapper.appendChild(yearsSpan);

          wrapper.addEventListener('click', () => {
            guessInput.value = player.player_name;
            selectedPlayer = player.player_name;
            submitGuessBtn.disabled = false;
            clearAutocomplete();
          });

          return wrapper;
        });

        showAutocompleteSuggestions(suggestions);

      } catch (err) {
        console.error('Autocomplete fetch error:', err);
        showAutocompleteSuggestions([]);
      }
    }, 300);
  });

  guessInput.addEventListener('change', () => {
    if (guessInput.value !== selectedPlayer) {
      selectedPlayer = null;
      submitGuessBtn.disabled = true;
    }
  });
}


function initializeAuthStateListener() {
  if (window.supabase && window.supabase.auth) {
    window.supabase.auth.onAuthStateChange((event, session) => {
      updateNavUserState(session);
    });
  }
}


async function loadPlayerStats() {
  const el = document.getElementById('player-history');
  if (!el) return;

  const { data: sessionData, error: sessionError } = await supabase.auth.getSession();
  if (sessionError || !sessionData?.session?.user) {
    el.textContent = 'Games Played: 0 | Wins: 0 | Losses: 0';
    return;
  }

  const userId = sessionData.session.user.id;

  // ‚úÖ First, try to get existing stats
  let { data, error } = await supabase
    .from('user_stats')
    .select('games_played, wins, losses')
    .eq('user_id', userId)
    .single();

  // ‚úÖ If no row exists, create one
  if (error && error.code === 'PGRST116') { // No rows returned
    console.log('[loadPlayerStats] Creating new stats row for user:', userId);
    
    const { data: newData, error: insertError } = await supabase
      .from('user_stats')
      .insert({ 
        user_id: userId, 
        games_played: 0, 
        wins: 0, 
        losses: 0 
      })
      .select('games_played, wins, losses')
      .single();

    if (insertError) {
      console.error('[loadPlayerStats] Failed to create stats row:', insertError);
      el.textContent = 'Games Played: 0 | Wins: 0 | Losses: 0';
      return;
    }
    
    data = newData;
  } else if (error) {
    console.error('[loadPlayerStats] Unexpected error:', error);
    el.textContent = 'Games Played: 0 | Wins: 0 | Losses: 0';
    return;
  }

  el.textContent = `Games Played: ${data.games_played || 0} | Wins: ${data.wins || 0} | Losses: ${data.losses || 0}`;
}




///////////////////////////////////////////////
// 3. Socket handlers (outside DOMContentLoaded)
function setupSocketHandlers() {
  socket.removeAllListeners();

socket.on('connect', () => {
  console.log('[safeEmit] Socket connected ‚Äî flushing emitQueue');

  if (myUserId && myUsername) {
    socket.emit('userSignedIn', { userId: myUserId, username: myUsername });
  }

  // ‚úÖ SAFE: Only auto-rejoin if game is actively in progress
  // This preserves rematch while preventing unwanted auto-starts
  if (myRoomId && !isLeavingGame && gameStarted && !gameOver && myUsername && myUserId) {
    console.log('[DEBUG] Reconnecting to active game after socket connect:', myRoomId);
    setTimeout(() => {
      safeEmit('joinGame', {
        roomId: myRoomId,
        username: myUsername,
        userId: myUserId
      });
    }, 100);
  } else if (gameOver || !gameStarted) {
    // ‚úÖ Clear localStorage persistence but keep myRoomId for rematch
    console.log('[DEBUG] Game not active - clearing localStorage persistence');
    localStorage.removeItem('privateRoomId');
    // Note: myRoomId is preserved for rematch functionality
  }

  flushEmitQueue();
});




socket.on('disconnect', (reason) => {
  console.log('[DEBUG] Socket disconnected:', reason);
  
  // If this was an intentional sign-out, handle it immediately
  if (isLeavingGame || localStorage.getItem('isLeavingGame') === 'true') {
    resetAllGameState();
    if (gameStarted && !gameOver && myRoomId && myUsername) {
      socket.emit('playerSignedOut', { 
        roomId: myRoomId,
        username: myUsername,
        reason: 'signed_out'
      });
    }
  } else {
    // For accidental disconnects, give a grace period
    setTimeout(() => {
      if (!socket.connected) {
        // ‚úÖ FIXED: Replace the missing handlePlayerLeaving function
        if (gameStarted && !gameOver && myRoomId && myUsername) {
          socket.emit('playerSignedOut', { 
            roomId: myRoomId,
            username: myUsername,
            reason: 'disconnected'
          });
        }
      }
    }, 10000); // 10 second grace period
  }
});



socket.on('playersUpdate', (count) => {
  console.log('[DEBUG] playersUpdate received:', count);

  if (isLeavingGame) {
    console.log('[DEBUG] playersUpdate skipped: isLeavingGame is true');
    return;
  }

  const statusDiv = document.getElementById('status');
  const rematchBtn = document.getElementById('rematchBtn');

  if (statusDiv) {
    statusDiv.textContent = `Players in room: ${count}`;
  } else {
    console.warn('statusDiv not found in DOM');
  }

  if (rematchBtn) {
    if (count < 2) {
      rematchBtn.style.display = 'none';
      navigateTo('/waiting');
    } else {
      navigateTo('/play');
    }
  } else {
    console.warn('rematchBtn not found in DOM');
  }
});





socket.on('matched', ({ roomId, opponent }) => {
  if (isLeavingGame || localStorage.getItem('isLeavingGame') === 'true') {
    console.log('[DEBUG] Ignoring matched event because isLeavingGame is true');
    return;
  }

  if (gameStarted && !gameOver) return;

  // ‚úÖ Once matched, clear stale flags
  isLeavingGame = false;
  localStorage.removeItem('isLeavingGame');

  myRoomId = roomId;
  opponentName = opponent;

  statusDiv.textContent = `Matched with ${opponent}! Joining game...`;

  navigateTo('/waiting');

  // ‚úÖ Include userId!
  socket.emit('joinGame', { 
    roomId: myRoomId, 
    username: myUsername,
    userId: myUserId   // <-- this part is critical now
  });
});





// 2. Game Lifecycle
socket.on('gameStarted', async (data) => {
  if (isLeavingGame) {
    console.log('[DEBUG] Ignoring gameStarted because isLeavingGame === true');
    return;
  }

  console.log('[CLIENT] Received gameStarted event:', data);

  resetCardSpread();

  gameStarted = true;
  gameOver = false;

  // Clear previous headshot storage for new game
  storedHeadshots.clear();

  const leadoffPlayer = data.leadoffPlayer || null;
  leadoffPlayerName = leadoffPlayer?.player_name || null;

  if (window.timerInterval) {
    clearInterval(window.timerInterval);
    window.timerInterval = null;
    console.warn('[CLIENT] Cleared leftover timer before starting new one.');
  }

  guessInput.disabled = true;
  submitGuessBtn.disabled = true;
  guessInput.value = '';
  clearGuessError();
  clearAutocomplete();

  rematchBtn.style.display = 'none';
  rematchBtn.disabled = false;
  rematchBtn.textContent = 'Rematch';

  messagesEl.innerHTML = '';
  messagesEl.style.display = 'block';

  // ‚úÖ Initialize successfulGuesses with leadoff player immediately
  successfulGuesses = [];
  if (leadoffPlayer && leadoffPlayer.player_name) {
    // Store leadoff headshot
    if (leadoffPlayer.headshot_url) {
      storedHeadshots.set(leadoffPlayer.player_name, leadoffPlayer.headshot_url);
    }
    
    const leadoffGuess = {
      guesser: 'Leadoff',
      name: leadoffPlayer.player_name,
      isLeadoff: true,
      headshot_url: leadoffPlayer.headshot_url || DEFAULT_PLAYER_IMAGE
    };
    
    successfulGuesses.push(leadoffGuess);
    
    // Store leadoff data globally for preservation
    window.leadoffPlayerData = {
      name: leadoffPlayer.player_name,
      headshot_url: leadoffPlayer.headshot_url || DEFAULT_PLAYER_IMAGE
    };
  }

  console.log('[CLIENT] successfulGuesses after reset:', successfulGuesses);
  renderSuccessfulGuesses();

  // ‚úÖ Update current player name (NBA player)
  currentPlayerNameEl.textContent = data.currentPlayerName || '???';

  // ‚úÖ Update current player headshot
  if (currentPlayerHeadshotEl) {
    currentPlayerHeadshotEl.src = data.currentPlayerHeadshotUrl || DEFAULT_PLAYER_IMAGE;
    currentPlayerHeadshotEl.alt = (data.currentPlayerName || 'Unknown') + ' Headshot';
  }

  // ‚úÖ Update player labels
  const playerYouEl = document.getElementById('playerYou');
  const playerOpponentEl = document.getElementById('playerOpponent');
  if (playerOpponentEl && data.opponentName) {
    playerOpponentEl.textContent = data.opponentName;
    opponentName = data.opponentName;
  }
  if (playerYouEl) playerYouEl.textContent = myUsername || 'You';

  // ‚úÖ Correct: use currentPlayerUsername, not currentPlayerName!
  const isYourTurn = data.currentPlayerUsername === myUsername;

  if (playerYouEl && playerOpponentEl) {
    playerYouEl.classList.toggle('active-turn', isYourTurn);
    playerOpponentEl.classList.toggle('active-turn', !isYourTurn);
  }

  timerEl.textContent = `:${data.timeLeft || 30}`;
  console.log('[CLIENT] Timer initialized at:', data.timeLeft || 15);

  console.log('[DEBUG] Navigating to /play...');
  await navigateTo('/play');
  console.debug('[DEBUG] Waiting for scoreboard readiness...');
  await waitForScoreboard();
  socket.emit('getMatchStats');
});





socket.on('matchStats', (stats) => {
  console.log('[CLIENT] Updated matchStats:', stats);
  updateSplitScoreboard(stats, myUsername, opponentName);
});



socket.on('gameOver', (data) => {
  console.log('[DEBUG] gameOver received:', data);

  // ‚úÖ If I intentionally left, skip handling
  if (isLeavingGame) {
    console.debug('[DEBUG] Ignoring gameOver because isLeavingGame === true');
    isLeavingGame = false; // reset for next time
    return; // skip all the rest
  }

  gameOver = true;

  // ‚úÖ PREVENT AUTO-REJOIN: Clear room persistence when game ends
  localStorage.removeItem('privateRoomId');

  // Stop input & timer
  guessInput.disabled = true;
  submitGuessBtn.disabled = true;

  if (window.timerInterval) {
    clearInterval(window.timerInterval);
    window.timerInterval = null;
  }
  timerEl.textContent = ':--';

  // Ensure myUsername & opponentName
  if (!myUsername && data.winnerName && data.loserName) {
    if (data.role === 'winner') {
      myUsername = data.winnerName;
      opponentName = data.loserName;
    } else {
      myUsername = data.loserName;
      opponentName = data.winnerName;
    }
  } else if (!opponentName && data.winnerName && data.loserName) {
    opponentName = (myUsername === data.winnerName) ? data.loserName : data.winnerName;
  }

  // Show game over container
  const container = document.getElementById('gameOverContainer');
  container.style.display = 'flex';
  container.innerHTML = '';

  const gameOverMsg = document.createElement('div');
  gameOverMsg.style.fontSize = '1.5rem';
  gameOverMsg.style.textAlign = 'center';
  gameOverMsg.style.fontWeight = 'bold';
  gameOverMsg.style.marginTop = '1rem';

  if (data.message) {
    gameOverMsg.textContent = data.message;
  } else if (data.reason === 'opponent_left') {
    const opponent = opponentName || 'Your opponent';
    gameOverMsg.textContent = `${opponent} left the game.`;
  } else {
    gameOverMsg.textContent = 'Game Over!';
  }

  if (data.role === 'winner') {
    gameOverMsg.style.color = 'green';
  } else if (data.role === 'loser') {
    gameOverMsg.style.color = 'darkred';
  } else {
    gameOverMsg.style.color = 'gray';
  }

  container.appendChild(gameOverMsg);

  const resultsDiv = document.getElementById('gameOverResults');
  if (resultsDiv) {
    if (data.winnerName && data.loserName) {
      resultsDiv.innerHTML = `
        <p><strong>Winner:</strong> ${data.winnerName}</p>
        <p><strong>Loser:</strong> ${data.loserName}</p>
      `;
    } else {
      resultsDiv.innerHTML = '';
    }
  }

  if (data.canRematch === false || data.reason === 'opponent_left') {
    rematchBtn.style.display = 'none';
  } else {
    rematchBtn.style.display = 'block';
    rematchBtn.disabled = false;
    rematchBtn.textContent = 'Rematch';
  }

  // Let server 'matchStats' handle scoreboard update
  navigateTo('/gameover');

  triggerGameEndCardSpread();
});




// 3. Turn Management
socket.on('yourTurn', (data) => {
  navigateTo('/play');

  const turnSection = document.getElementById('turnSection');

  turnSection.classList.add('your-turn');
  turnSection.classList.remove('opponent-turn');

  document.getElementById('guessControls').style.display = 'block';
  guessInput.disabled = false;
  submitGuessBtn.disabled = !guessInput.value.trim();

  // ‚úÖ NBA player to guess:
  currentPlayerNameEl.textContent = data.currentPlayerName || 'Your Turn';

  // ‚úÖ Update headshot too:
  if (currentPlayerHeadshotEl) {
    currentPlayerHeadshotEl.src = data.currentPlayerHeadshotUrl || DEFAULT_PLAYER_IMAGE;
    currentPlayerHeadshotEl.alt = `${data.currentPlayerName || 'Player'} Headshot`;
  }

  // ‚úÖ Store current player headshot for when they get guessed
  if (data.currentPlayerName && data.currentPlayerHeadshotUrl) {
  storedHeadshots.set(data.currentPlayerName, data.currentPlayerHeadshotUrl);
  console.log('Stored headshot for:', data.currentPlayerName, data.currentPlayerHeadshotUrl);
}

  timerEl.textContent = `:${data.timeLeft || 30}`;

  turnSection.style.display = 'block';
  messagesEl.style.display = 'block';

  showMessage(data.message || "It's your turn to guess!", 'info');


 const turnPromptText = document.getElementById('turnPromptText');
if (turnPromptText) {
  turnPromptText.innerHTML = `
  <div>Name any teammate of:</div>
  <div class="player-info">
    <img id="currentPlayerHeadshot" src="${data.currentPlayerHeadshotUrl || DEFAULT_PLAYER_IMAGE}" alt="${data.currentPlayerName || 'Player'} Headshot" width="60" height="60" style="border-radius: 50%; object-fit: cover;"/>
    <strong class="turn-player-name" id="currentPlayerName">${data.currentPlayerName}</strong>
  </div>
`;
}

  // ‚úÖ Highlight the current player in playersDisplay
  const playerYouEl = document.getElementById('playerYou');
  const playerOpponentEl = document.getElementById('playerOpponent');

  if (playerYouEl && playerOpponentEl) {
    playerYouEl.classList.add('active-turn');
    playerOpponentEl.classList.remove('active-turn');
  }
});

socket.on('opponentTurn', (data) => {
  navigateTo('/play');

  const turnSection = document.getElementById('turnSection');

  turnSection.classList.remove('your-turn');
  turnSection.classList.add('opponent-turn');

  document.getElementById('guessControls').style.display = 'none';
  guessInput.disabled = true;
  submitGuessBtn.disabled = true;

  // ‚úÖ NBA player to guess:
  currentPlayerNameEl.textContent = data.currentPlayerName || "Opponent's Turn";

  // ‚úÖ Update headshot too:
  if (currentPlayerHeadshotEl) {
    currentPlayerHeadshotEl.src = data.currentPlayerHeadshotUrl || DEFAULT_PLAYER_IMAGE;
    currentPlayerHeadshotEl.alt = `${data.currentPlayerName || 'Player'} Headshot`;
  }

  // ‚úÖ Store current player headshot for when they get guessed
  if (data.currentPlayerName && data.currentPlayerHeadshotUrl) {
  storedHeadshots.set(data.currentPlayerName, data.currentPlayerHeadshotUrl);
  console.log('Stored headshot for:', data.currentPlayerName, data.currentPlayerHeadshotUrl);
}


  const turnPromptText = document.getElementById('turnPromptText');
if (turnPromptText) {
  turnPromptText.innerHTML = `
  <div>${opponentName || 'Your opponent'} is naming a teammate of:</div>
  <div class="player-info">
    <img id="currentPlayerHeadshot" src="${data.currentPlayerHeadshotUrl || DEFAULT_PLAYER_IMAGE}" alt="${data.currentPlayerName || 'Player'} Headshot" width="60" height="60" style="border-radius: 50%; object-fit: cover;"/>
    <strong class="turn-player-name" id="currentPlayerName">${data.currentPlayerName}</strong>
  </div>
`;
}

  timerEl.textContent = data.timeLeft || '';

  turnSection.style.display = 'block';
  messagesEl.style.display = 'block';

  showMessage(data.message || "Waiting for your opponent to guess...", 'info');

  // Update only the player name text
  const playerNameEl = document.getElementById('currentPlayerName');
  if (playerNameEl) {
    playerNameEl.textContent = data.currentPlayerName;
  }

  // ‚úÖ Highlight the opponent in playersDisplay
  const playerYouEl = document.getElementById('playerYou');
  const playerOpponentEl = document.getElementById('playerOpponent');

  if (playerYouEl && playerOpponentEl) {
    playerYouEl.classList.remove('active-turn');
    playerOpponentEl.classList.add('active-turn');
  }
});





socket.on('message', (msg) => {
  navigateTo('/play'); // Ensure user is on the gameplay page
  showMessage(msg, 'error');
});

socket.on('turnEnded', (data) => {
  console.log('turnEnded currentPlayerHeadshotUrl:', data.currentPlayerHeadshotUrl);
  
  // ‚úÖ CRITICAL: Store the NEW current player's headshot FIRST
  // This is the player who was just guessed and will be on the new card
  if (data.currentPlayerName && data.currentPlayerHeadshotUrl) {
    storedHeadshots.set(data.currentPlayerName, data.currentPlayerHeadshotUrl);
    console.log('Storing NEW current player headshot BEFORE processing:', data.currentPlayerName, data.currentPlayerHeadshotUrl);
  }
  
  navigateTo('/play');

  if (Array.isArray(data.successfulGuesses)) {
    // Now the headshot will be available for the newly added card
    successfulGuesses = data.successfulGuesses.map(guess => {
      const storedHeadshot = storedHeadshots.get(guess.name);
      const updatedGuess = {
        ...guess,
        headshot_url: storedHeadshot || guess.headshot_url || DEFAULT_PLAYER_IMAGE
      };
      
      if (guess.name === leadoffPlayerName || guess.isLeadoff) {
        updatedGuess.isLeadoff = true;
        if (guess.name === leadoffPlayerName && window.leadoffPlayerData) {
          updatedGuess.headshot_url = storedHeadshots.get(guess.name) || window.leadoffPlayerData.headshot_url || DEFAULT_PLAYER_IMAGE;
        }
      }
      
      console.log(`Final headshot for ${guess.name}:`, updatedGuess.headshot_url);
      return updatedGuess;
    });
    
    successfulGuesses = markLeadoffInGuesses(successfulGuesses, leadoffPlayerName);
    renderSuccessfulGuesses();
  }

  if (data.message) {
    showMessage(data.message, data.message.startsWith('Incorrect guess') ? 'error' : 'info');
  }

  // ‚úÖ Save turn state for next turn rendering
  currentPlayerName = data.currentPlayerName || '???';
  currentPlayerHeadshotUrl = data.currentPlayerHeadshotUrl || DEFAULT_PLAYER_IMAGE;
  timeLeft = data.timeLeft || 15;

  renderPlayScreen();
});





function renderPlayScreen() {
  if (currentPlayerNameEl) {
    currentPlayerNameEl.textContent = currentPlayerName;
  }
  if (currentPlayerHeadshotEl) {
    currentPlayerHeadshotEl.src = currentPlayerHeadshotUrl;
    currentPlayerHeadshotEl.alt = `${currentPlayerName} Headshot`;
  }
  if (timerEl) {
  timerEl.textContent = `:${timeLeft}`;
}
}





socket.on('timerTick', (data) => {
  timerEl.textContent = `:${data.timeLeft}`;
  updateTimerStyle(data.timeLeft);
});





// When another player requests a rematch
socket.on('rematchRequested', ({ username }) => {
  showMessage(`${username} wants a rematch! Click your Rematch button to accept.`, 'info', true);

 
});

// When rematch actually starts
socket.on('rematchStarted', () => {
  resetGameUI();

  // Clear any rematch prompt message
  const rematchInfo = document.getElementById('rematch-info');
  if (rematchInfo) rematchInfo.remove();

  // Reset rematch button styles
  rematchBtn.disabled = false;
  rematchBtn.style.backgroundColor = ''; // Reset highlight
  rematchBtn.textContent = 'Rematch';

  // ‚úÖ Re-join the same room to trigger new game start
  if (myRoomId && myUsername) {
    console.log('[CLIENT] Rejoining room for rematch:', myRoomId);
    socket.emit('joinGame', {
      roomId: myRoomId,
      username: myUsername,
      userId: myUserId
    });
    socket.emit('getMatchStats');
  } else {
    console.error('[CLIENT] Missing roomId or username for rematch.');
  }
});

  }




// 4. DOMContentLoaded (minimal, focused)
document.addEventListener('DOMContentLoaded', async () => {
  console.log('[DEBUG] DOMContentLoaded');

  // ‚úÖ INITIALIZE SOCKET FIRST - Before any routing logic
  console.log('[DOMContentLoaded] Initializing socket connection...');
  socket = io();
  setupSocketHandlers();

  let justConfirmed = false;

  // Initialize all event listeners
  setupAutocompleteListeners();
  setupFormListeners();
  setupAuthTabs();
  initializeAuthStateListener();
  updateNavUserState();
  setupNavDropdown();

  // Cache DOM element references
  statusDiv = document.getElementById('status');
  guessInput = document.getElementById('guessInput');
  submitGuessBtn = document.getElementById('submitGuessBtn');
  rematchBtn = document.getElementById('rematchBtn');
  messagesEl = document.getElementById('messageContainer');
  currentPlayerNameEl = document.getElementById('currentPlayerName');
  currentPlayerHeadshotEl = document.getElementById('currentPlayerHeadshot');
  timerEl = document.getElementById('timer');
  autocompleteList = document.getElementById('autocomplete-list');
  waitingRoom = document.getElementById('waitingRoom');
  gameArea = document.getElementById('gameArea');
  inviteLinkContainer = document.getElementById('inviteLinkContainer');
  
  // Set initial default image
  if (currentPlayerHeadshotEl) {
    currentPlayerHeadshotEl.src = DEFAULT_PLAYER_IMAGE;
  }

  supabase.auth.onAuthStateChange((_event, session) => {
    updateNavUserState(session);
  });

  const urlHash = window.location.hash;
  const searchParams = new URLSearchParams(window.location.search);
  const typeParam = searchParams.get('type');

  console.log('[DEBUG] On load: urlHash:', urlHash, 'typeParam:', typeParam);

  // Handle password recovery separately
  if (
    (urlHash.includes('access_token') && urlHash.includes('type=recovery'))
    || (typeParam === 'recovery')
  ) {
    console.log('[DEBUG] Found password recovery in URL');
    try {
      const { data: { user }, error } = await supabase.auth.getUser();
      if (error) {
        console.error('[ERROR] Password recovery failed:', error.message);
        navigateTo('/signup');
      } else {
        console.log('[DEBUG] Password recovery successful for:', user?.email);
        // Go directly to update password page
        await navigateTo('/update-password');
      }
    } catch (e) {
      console.error('[ERROR] Exception during password recovery:', e);
      navigateTo('/signup');
    }
    return;
  }

  // Handle email confirmation (signup/email_confirm only)
  if (
    (urlHash.includes('access_token') &&
      (urlHash.includes('type=signup') || urlHash.includes('type=email_confirm')))
    || (typeParam === 'signup' || typeParam === 'email_confirm')
  ) {
    console.log('[DEBUG] Found email confirmation in URL');
    try {
      const { data: { user }, error } = await supabase.auth.getUser();
      if (error) {
        console.error('[ERROR] Email confirmation failed:', error.message);
      } else {
        console.log('[DEBUG] Email confirmed for:', user?.email);

        myUsername = user.user_metadata?.username || user.email;
        myUserId = user.id;
        localStorage.setItem('username', myUsername);
        localStorage.setItem('userId', myUserId);

        const { data: { session } } = await supabase.auth.getSession();

        await navigateTo('/confirmed');
        await updateNavUserState(session);
      }
    } catch (e) {
      console.error('[ERROR] Exception during email confirmation:', e);
    }
    return;
  }

  // --- 3Ô∏è‚É£ Validate session state FIRST ---
console.log('[DEBUG] Starting session validation...');

// ‚úÖ FIRST: Check for room invite in URL and preserve it
const params = new URLSearchParams(window.location.search);
const roomFromUrl = params.get('room');

if (roomFromUrl) {
  console.log('[DEBUG] Found room invite in URL:', roomFromUrl);
  localStorage.setItem('pendingRoomInvite', roomFromUrl);
}

try {
  const { data: { session }, error } = await supabase.auth.getSession();
  
  if (error) {
    console.error('[DEBUG] Session error:', error);
    await forceSignOut();
    return;
  }
  
  if (!session || !session.user) {
    console.log('[DEBUG] No valid session found');
    localStorage.removeItem('username');
    localStorage.removeItem('userId');
    localStorage.removeItem('privateRoomId');
    localStorage.removeItem('isLeavingGame');
    
    myUsername = null;
    myUserId = null;
    
    await updateNavUserState(null);
    navigateTo('/signup');
    return;
  }
  
  // Valid session exists - set up user data
  const user = session.user;
  myUsername = user.user_metadata?.username || user.email;
  myUserId = user.id;
  
  localStorage.setItem('username', myUsername);
  localStorage.setItem('userId', myUserId);
  
  console.log('[DEBUG] Valid session confirmed:', {
    myUsername,
    myUserId,
    email: user.email
  });
  
  await updateNavUserState(session);
  
  // ‚úÖ Handle room invites with proper state management
  const pendingRoomInvite = localStorage.getItem('pendingRoomInvite');
  const currentRoomInvite = roomFromUrl;
  const targetRoom = pendingRoomInvite || currentRoomInvite;
  
 if (targetRoom) {
  console.log('[DEBUG] Processing room invite:', targetRoom);
  
  // Clear pending invite
  localStorage.removeItem('pendingRoomInvite');
  
  // ‚úÖ ONLY set up room state if we're not in a game over state
  if (!gameOver) {
    // Set up room state BEFORE navigation
    myRoomId = targetRoom;
    roomId = targetRoom;
    isPrivateGame = true;
    isLeavingGame = false;
    
    localStorage.setItem('privateRoomId', targetRoom);
    localStorage.removeItem('isLeavingGame');
    
    // Navigate and join
    await navigateTo('/waiting');
    setTimeout(() => {
      safeEmit('joinGame', {
        roomId: targetRoom,
        username: myUsername,
        userId: myUserId
      });
    }, 100);
    
    return;
  } else {
    console.log('[DEBUG] Ignoring room invite - game is over');
  }
}
  
  // No room invite, go to home
  navigateTo('/home');
  
} catch (error) {
  console.error('[DEBUG] Session validation failed:', error);
  await forceSignOut();
}

  // Event listeners for page lifecycle
  window.addEventListener('popstate', () => {
    navigateTo(window.location.pathname, { skipPush: true });
  });

  window.addEventListener('beforeunload', (e) => {
    if (gameStarted && !gameOver && socket && socket.connected) {
      isLeavingGame = true;
      socket.emit('playerSignedOut', {
        roomId: myRoomId || roomId,
        username: myUsername,
        userId: myUserId,
        reason: 'page_closed'
      });
    }
  });
});


</script>


















</body>
</html>