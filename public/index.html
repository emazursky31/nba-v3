<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NBA Teammate Game</title>

  <!-- External CSS -->
  <link rel="stylesheet" href="style.css" />

  <!-- Socket.IO -->
  <script src="https://cdn.socket.io/4.6.1/socket.io.min.js" crossorigin="anonymous"></script>

  <!-- Supabase (ES Module) -->
  <script type="module">
    import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm'

    const SUPABASE_URL = 'https://rbjdlzgptvpfsnkakasj.supabase.co'
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJiamRsemdwdHZwZnNua2FrYXNqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg5ODYxMzksImV4cCI6MjA2NDU2MjEzOX0.U0EhIpOaKrHQmAJHcCBVJLKDGEW-m91eNj2bWRejYpk'
    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY)

    window.supabase = supabase // Expose for later use
  </script>
</head>

<body>
<nav>
  <a href="#" id="nav-title-link" style="text-decoration: none; color: inherit;">
    <span id="nav-title">üèÄ Who He Played With</span>
  </a>
  
  <div class="nav-dropdown" id="nav-dropdown" style="display: none;">
    <button class="nav-dropdown-btn" id="nav-dropdown-btn">
      <span id="nav-username">Menu</span>
      <span class="dropdown-arrow">‚ñº</span>
    </button>
   <div class="nav-dropdown-content" id="nav-dropdown-content">
  <a href="#" id="nav-dropdown-profile">Profile</a>
  <a href="#" id="nav-dropdown-signout">Sign Out</a>
</div>
  </div>
</nav>





<!-- üîë Sign Up / Sign In -->
<section data-route="/signup">
  <!-- Game Title and Subtitle -->
  <div class="game-intro">
    <h1>Who He Played With</h1>
    <p class="game-subtitle">Test your NBA knowledge by connecting players through their teammates</p>
  </div>

  <!-- How to Play Section -->
 <div class="how-to-play">
  <h3>How to Play</h3>
  <div class="rules-grid">
    <div class="rule-item">
      <span class="rule-number">1</span>
      <p>A random NBA player is chosen as the starting point</p>
    </div>
    <div class="rule-item">
      <span class="rule-number">2</span>
      <p>Take turns naming a <strong>regular season teammate</strong> of the current player</p>
    </div>
    <div class="rule-item">
      <span class="rule-number">3</span>
      <p>Players must have been active on the same team for at least one regular season game at any point in their career (they don't need to have played together on court)</p>
    </div>
    <div class="rule-item">
      <span class="rule-number">4</span>
      <p>Each correct guess becomes the new current player</p>
    </div>
    <div class="rule-item">
      <span class="rule-number">5</span>
      <p>You have <strong>30 seconds per turn</strong> and can guess as many times as you want within the time limit</p>
    </div>
    <div class="rule-item">
      <span class="rule-number">6</span>
      <p>Don't run out of time - keep the chain going!</p>
    </div>
  </div>
</div>

  <div class="auth-tabs-container">
    <div class="auth-tabs">
      <button id="tab-signup" class="auth-tab active" type="button">Sign Up</button>
      <button id="tab-signin" class="auth-tab" type="button">Sign In</button>
    </div>
    <div class="auth-forms-row">
      <form id="signupForm" class="auth-form active" autocomplete="off">
        <h2>Sign Up</h2>
        <input type="email" id="signup-email" placeholder="Email" required>
        <input type="password" id="signup-password" placeholder="Password" required>
        <input id="signup-username" placeholder="Username" required>
        <button id="signupBtn" type="submit">Sign Up</button>
      </form>
      <form id="signinForm" class="auth-form" autocomplete="off">
        <h2>Sign In</h2>
        <input type="email" id="signin-email" placeholder="Email" required>
        <input type="password" id="signin-password" placeholder="Password" required>
        <button id="signinBtn" type="submit">Sign In</button>
        <p><a href="#" id="forgotPasswordLink">Forgot password?</a></p>
      </form>
    </div>
  </div>
</section>



 <!-- üîó Check your email after sign up -->
  <section data-route="/verify" class="hidden">
    <h2>Check your email!</h2>
    <p>We've sent you a confirmation link. Click it to verify your account.</p>
  </section>


   <!-- ‚úÖ Confirmation success -->
  <section data-route="/confirmed" class="hidden">
    <h2>Account Confirmed</h2>
    <p>Your email is verified! You can now continue.</p>
    <button id="confirmedContinueBtn">Continue</button>
  </section>

  <!-- üîë Reset password -->
  <section data-route="/reset" class="hidden">
    <h2>Reset Password</h2>
    <input type="email" id="reset-email" placeholder="Email">
    <button id="resetBtn">Send Reset Link</button>
  </section>

  <!-- ‚úÖ Reset success -->
  <section data-route="/reset-confirmed" class="hidden">
    <h2>Password Reset</h2>
    <p>Check your email for a link to set a new password.</p>
  </section>

<!-- Set password -->
  <section data-route="/update-password" class="hidden">
  <h2>Set a New Password</h2>
  <input type="password" id="new-password" placeholder="New password" />
  <button id="updatePasswordBtn">Update Password</button>
</section>


  <!-- ‚úèÔ∏è Create username/profile
  <section data-route="/username" class="hidden">
    <h2>Create Profile</h2>
    <input id="create-username" placeholder="Choose a username">
    <button id="saveUsernameBtn">Save</button>
  </section> -->


<!-- Home Screen -->
<!-- Home Screen with Game Setup -->
<section id="homeSelection" data-route="/home" class="hidden" style="text-align: center; margin-top: 2rem; position: relative;">
  
  <h3 id="home-welcome"></h3>

  <div id="gameSetup" class="game-setup-container">
    <!-- Step indicator -->
    <div class="setup-progress">
      <div class="step active" data-step="1">
        <span class="step-number">1</span>
        <span class="step-label">Game Type</span>
      </div>
      <div class="step" data-step="2">
        <span class="step-number">2</span>
        <span class="step-label">Starting Era</span>
      </div>
    </div>

    <!-- Game type selection -->
    <div id="gameModeSelection" class="selection-grid">
      <div class="selection-card" data-mode="private">
        <div class="selection-icon">üîí</div>
        <h3>Private Game</h3>
        <p class="selection-description">
          Create a private room and invite a friend to play. Share the room code or invite link to get started.
        </p>
        <button class="selection-btn" id="privateGameBtn">Start Private Game</button>
      </div>
      
      <div class="selection-card" data-mode="public">
        <div class="selection-icon">üåê</div>
        <h3>Public Game</h3>
        <p class="selection-description">
          Join the matchmaking queue and get paired with another player looking for a game.
        </p>
        <button class="selection-btn" id="findGameBtn">Find Public Game</button>
      </div>
    </div>

    <!-- Era selection (appears after game type selected) -->
    <div id="eraSelection" class="selection-grid era-step hidden">
      <h3 class="era-title">Choose Starting Era</h3>
      <p class="era-subtitle">Select the era for your leadoff player</p>
      
      <div class="era-cards">
        <div class="selection-card" data-era="2000-present">
          <!-- <div class="selection-icon">üèÄ</div> -->
          <h3>Modern Era</h3>
          <p class="selection-era">2000-Present</p>
          <p class="selection-description">
            Start with players from the modern NBA era featuring superstars like LeBron, Kobe, Durant, and Curry.
          </p>
          <button class="selection-btn era-btn" data-era="2000-present">Choose Modern Era</button>
        </div>
        
        <div class="selection-card" data-era="1980-1999">
          <!-- <div class="selection-icon">üëë</div> -->
          <h3>Golden Era</h3>
          <p class="selection-era">1980-1999</p>
          <p class="selection-description">
            Begin with legends from basketball's golden age including Jordan, Magic, Bird, and the Dream Team era.
          </p>
          <button class="selection-btn era-btn" data-era="1980-1999">Choose Golden Era</button>
        </div>
        
        <div class="selection-card" data-era="1960-1979">
          <!-- <div class="selection-icon">üèÜ</div> -->
          <h3>Classic Era</h3>
          <p class="selection-era">1960-1979</p>
          <p class="selection-description">
            Start with classic players from the ABA merger era featuring Kareem, Dr. J, and the early championship dynasties.
          </p>
          <button class="selection-btn era-btn" data-era="1960-1979">Choose Classic Era</button>
        </div>
        
        <div class="selection-card" data-era="pre-1960">
          <!-- <div class="selection-icon">‚≠ê</div> -->
          <h3>Pioneer Era</h3>
          <p class="selection-era">Pre-1960</p>
          <p class="selection-description">
            Begin with basketball pioneers and early NBA legends who built the foundation of professional basketball.
          </p>
          <button class="selection-btn era-btn" data-era="pre-1960">Choose Pioneer Era</button>
        </div>
      </div>
    </div>
  </div>
</section>



<!-- Profile Section -->
<section id="profileSection" data-route="/profile">
  <h1>Your Profile</h1>
  
  <div class="profile-container">
    <!-- User Info Card -->
    <div class="profile-info-card">
      <h2>Account Information</h2>
      <div class="profile-field">
        <label>Username:</label>
        <span id="profile-username">Loading...</span>
      </div>
      <div class="profile-field">
        <label>Email:</label>
        <span id="profile-email">Loading...</span>
      </div>
      <div class="profile-field">
        <label>Member Since:</label>
        <span id="profile-member-since">Loading...</span>
      </div>
    </div>

    <!-- Stats Card -->
    <div class="profile-stats-card">
      <h2>Game Statistics</h2>
      <div class="profile-stats">
        <div class="stat-card">
          <div class="stat-number" id="profile-total-games">0</div>
          <div class="stat-label">Games Played</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="profile-games-won">0</div>
          <div class="stat-label">Games Won</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="profile-win-rate">0%</div>
          <div class="stat-label">Win Rate</div>
        </div>
        <!-- <div class="stat-card">
          <div class="stat-number" id="profile-avg-guesses">0</div>
          <div class="stat-label">Avg Guesses</div>
        </div> -->
      </div>
    </div>

    <!-- Actions -->
    <div class="profile-actions">
      <button id="profile-signout-btn" class="signout-button">Sign Out</button>
    </div>
  </div>
</section>



<!-- Invite link container (used only in private games) -->
<section id="inviteLinkContainer" data-route="/invite" class="hidden" style="text-align: center; margin-top: 1rem;"></section>

<!-- Status message -->
<section id="status" data-route="/status" style="text-align: center; margin-top: 1rem;"></section>

<!-- Waiting Room View -->
<section id="waitingRoom" data-route="/waiting" class="hidden" style="text-align: center; margin-top: 2rem;">
  <h2>Waiting Room</h2>
  <p id="waitingStatus">Waiting for another player to join...</p>
 <div class="nba-loader" aria-hidden="true">
  <svg class="basketball-icon" viewBox="0 0 64 64"><circle cx="32" cy="32" r="30" fill="#f78f1e" stroke="#000" stroke-width="2"/><path d="M2 32h60M32 2v60M12 12c11 11 29 11 40 0M12 52c11-11 29-11 40 0" stroke="#000" stroke-width="2" fill="none"/></svg>
  <svg class="basketball-icon" viewBox="0 0 64 64"><circle cx="32" cy="32" r="30" fill="#f78f1e" stroke="#000" stroke-width="2"/><path d="M2 32h60M32 2v60M12 12c11 11 29 11 40 0M12 52c11-11 29-11 40 0" stroke="#000" stroke-width="2" fill="none"/></svg>
  <svg class="basketball-icon" viewBox="0 0 64 64"><circle cx="32" cy="32" r="30" fill="#f78f1e" stroke="#000" stroke-width="2"/><path d="M2 32h60M32 2v60M12 12c11 11 29 11 40 0M12 52c11-11 29-11 40 0" stroke="#000" stroke-width="2" fill="none"/></svg>
</div>

  <code id="displayRoomCode" style="font-size: 1.5rem; font-weight: bold;"></code>
  <div id="inviteLinkWrapper" style="margin-top: 1rem;">
  <p>Invite a friend to join using this link:</p>
  <input id="inviteLink" type="text" readonly style="width: 80%; max-width: 400px; padding: 0.5rem;" />
  <div style="display: flex; gap: 0.5rem; margin-top: 0.75rem; justify-content: center;">
    <button id="copyInviteBtn">Copy Link</button>
    <button id="shareInviteBtn">Share</button>
  </div>
  <div id="copyToast" style="display:none; color: green; margin-top: 0.5rem;">Link copied!</div>
</div>
</section>


<!-- Matched Screen with Countdown -->
<section id="matchedScreen" data-route="/matched" class="hidden" style="text-align: center; margin-top: 2rem;">
  <h3>Match Found!</h3>
  <div id="matchedMessage" style="font-size: 1.25rem; margin: 1.5rem 0; color: var(--success-color);">
    Matched with: <span id="matchedOpponentName">Opponent</span>
  </div>
  <div id="countdownContainer" style="margin: 2rem 0;">
    <p style="font-size: 1.1rem; color: var(--text-secondary);">Game starting in...</p>
    <div id="countdownTimer" style="font-size: 3rem; font-weight: bold; color: var(--primary-color);">5</div>
  </div>
</section>


<!-- Scoreboard UI -->
<!-- <section id="scoreboardSection">
  <div id="jumbotronScoreboard" class="scoreboard-box">
    <div class="scoreboard-header">
      <span id="player1Name">Player 1</span>
      <span id="player2Name">Player 2</span>
    </div>
    <div class="scoreboard-scores">
      <span id="player1Score" class="scoreDigits">0</span>
      <span id="player2Score" class="scoreDigits">0</span>
    </div>
  </div>
</section> -->


<!-- In-Game UI -->

<section id="gameArea" data-route="/play" class="hidden" style="position: relative;">
  <div id="playersDisplay">
    <span class="opponent-label">Opponent:</span>
    <span class="player-name opponent" id="playerOpponent">OpponentName</span>
  </div>

  <div id="turnSection">
    <div class="turn-prompt" id="turnPromptText">
      <div class="prompt-header">Name any teammate of:</div>
      <div class="player-info">
        <img id="currentPlayerHeadshot" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAAvklEQVRoge3XsQ2AIBBF0ZLpDoBuwHFHqK8cQvMrIo3FLPHom/b2mX9rcNqZmZmZmZmZmZmdFz5ec3m6F3+v4PYs3PmR7JbiDD1N9g5IuT16CWYExozP7G9Czzxq/cE8ksYbFxExk2RcMUfYHNk0RMYPhk0QcMbJHUYyNsi9h5YDyYFSNqLD6c+5h3tGn+MO9ZftHJz5nz/rq3ZTzRzqkIxuYwAAAABJRU5ErkJggg==" alt="Current Player Headshot" width="60" height="60" style="border-radius: 50%; object-fit: cover;"/>
        <div class="player-details">
          <strong class="turn-player-name" id="currentPlayerName">Loading...</strong>
          <a href="#" class="career-link" onclick="toggleLeadoffCareer()" style="display: flex;">
            <span class="toggle-text">Career Details</span> <span class="toggle-icon career-arrow">‚ñº</span>
          </a>
        </div>
      </div>
    </div>

    <div id="leadoff-career-section" class="leadoff-career-section" style="display: none;">
      <div id="leadoff-career-content" class="leadoff-career-content" style="display: none;">
        <div class="career-loading">Loading career details...</div>
      </div>
    </div>

    <div class="timer-skip-row">
  <div id="timer-container">
    <svg class="progress-ring" viewBox="0 0 80 80">
      <circle class="progress-ring-track" cx="40" cy="40" r="35"/>
      <circle class="progress-ring-circle" cx="40" cy="40" r="35"
              stroke-dasharray="219.91"
              stroke-dashoffset="0"/>
    </svg>
    <div id="timer">30</div>
  </div>
  <a href="#" class="skip-link hidden" id="skipTurnBtn">Skip</a>
</div>


    <div id="guessControls" style="position: relative;">
      <input
        type="text"
        id="guessInput"
        placeholder="Type a teammate's name..."
        autocomplete="off"
        autocorrect="off"
        autocapitalize="off"
        spellcheck="false"
      />
      <button id="submitGuessBtn" disabled>Submit Guess</button>
      
      <div id="autocomplete-list"></div>
    </div>
  </div>

  <div id="messageContainer"></div>
</section>


<div id="successful-guesses-container" style="text-align: center; margin-top: 2rem;">
  
  <div id="card-deck" class="card-deck-container"></div>
</div>




<!-- Game Over UI -->
<section data-route="/gameover" class="hidden" style="text-align: center; margin-top: 2rem;">
  <div id="gameOverContainer" style="display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 1rem;">
    <!-- Game over message will be dynamically added here -->

    <!-- Add this container for winner/loser details -->
    <div id="gameOverResults" style="font-size: 1.2rem; margin-top: 1rem;"></div>
  </div>
  <button id="rematchBtn" style="margin-top: 1rem;">Request Rematch</button>
</section>




<script>
// 1. Global variables and state (outside DOMContentLoaded)
// Core state
  let roomId = null;
  let myRoomId = null;
  let selectedPlayer = null;
  let fetchTimeout = null;
  let gameStarted = false;
  let gameOver = false;
  let leadoffPlayerName = null;
  let careerDataLoaded = false;
  let myUsername = null;
  let opponentName = null;
  let successfulGuesses = [];
  let isPrivateGame = false;
  let socket = null;
  let isLeavingGame = false;
  let currentRoute = '';
  let statusDiv = null;
  let socketConnected = false;
  let emitQueue = [];
  let selectedEra = '2000-present'; // Default era
  let gameTypeSelected = false;

  // DOM element references (assigned in DOMContentLoaded)
let guessInput = null;
let submitGuessBtn = null;
let rematchBtn = null;
let messagesEl = null;
let currentPlayerNameEl = null;
let currentPlayerHeadshotEl = null;
let currentPlayerHeadshotUrl = null;
let timerEl = null;
let autocompleteList = null;
let waitingRoom = null;
let gameArea = null;
let inviteLinkContainer = null;
let myUserId = null;
let storedHeadshots = new Map();
const DEFAULT_PLAYER_IMAGE = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAAvklEQVRoge3XsQ2AIBBF0ZLpDoBuwHFHqK8cQvMrIo3FLPHom/b2mX9rcNqZmZmZmZmZmZmdFz5ec3m6F3+v4PYs3PmR7JbiDD1N9g5IuT16CWYExozP7G9Czzxq/cE8ksYbFxExk2RcMUfYHNk0RMYPhk0QcMbJHUYyNsi9h5YDyYFSNqLD6c+5h3tGn+MO9ZftHJz5nz/rq3ZTzRzqkIxuYwAAAABJRU5ErkJggg==';




// 2. Function definitions (outside DOMContentLoaded)

async function validateAndCleanupSession() {
  const { data: { session } } = await supabase.auth.getSession();
  const storedUsername = localStorage.getItem('username');
  const storedUserId = localStorage.getItem('userId');
  
  // The key insight: session is either valid or null
  // There's no "invalid session object"
  
  if (!session) {
    // No session = definitely not authenticated
    if (storedUsername || storedUserId) {
      // Clean up stale localStorage
      console.log('Cleaning up stale localStorage data');
      localStorage.removeItem('username');
      localStorage.removeItem('userId');
      myUsername = null;
      myUserId = null;
    }
    return false; // Not authenticated
  }
  
  // Session exists and is valid
  // Ensure localStorage matches
  const expectedUsername = session.user.user_metadata?.username || session.user.email;
  const expectedUserId = session.user.id;
  
  if (storedUsername !== expectedUsername || storedUserId !== expectedUserId) {
    // Fix localStorage to match session
    localStorage.setItem('username', expectedUsername);
    localStorage.setItem('userId', expectedUserId);
    myUsername = expectedUsername;
    myUserId = expectedUserId;
  }
  
  return true; // Valid and consistent
}



 // ‚úÖ Sign Up handler
  async function signUp(e) {
    e.preventDefault(); // üõë Stop default form submit

    const email = document.getElementById('signup-email').value.trim();
    const password = document.getElementById('signup-password').value.trim();
    const username = document.getElementById('signup-username').value.trim();

    if (!email || !password || !username) {
      alert('Please fill in all fields.');
      return;
    }

    if (password.length < 6) {
      alert('Password must be at least 6 characters.');
      return;
    }

    console.log('[DEBUG] SignUp data =>', email, username);

    const { data, error } = await supabase.auth.signUp({
      email,
      password,
      options: {
        data: { username }
      }
    });

    if (error) {
      console.error('SignUp error:', error.message);
      return;
    }

    console.log('‚úÖ Sign Up successful:', data);
    navigateTo('/verify'); // üëà Show verification screen
  }

  // ‚úÖ Sign In handler
  async function signIn(e) {
    e.preventDefault(); // üõë Stop default form submit

    const email = document.getElementById('signin-email').value.trim();
    const password = document.getElementById('signin-password').value.trim();

    if (!email || !password) {
      alert('Please fill in all fields.');
      return;
    }

    console.log('[DEBUG] SignIn data =>', email);

    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password
    });

    if (error) {
      console.error('SignIn error:', error.message);
      alert(error.message);
      return;
    }

    console.log('‚úÖ Sign In successful:', data);
    const user = data.user;
    myUsername = user.user_metadata?.username || user.email;
    myUserId = user.id;
    localStorage.setItem('username', myUsername);
    localStorage.setItem('userId', myUserId);

    console.log('[DEBUG] Username set to:', myUsername);
    console.log('[DEBUG] UserId set to:', myUserId);

    if (socket && socket.connected) {
      socket.emit('userSignedIn', { userId: myUserId, username: myUsername });
    }

    const pendingRoomInvite = localStorage.getItem('pendingRoomInvite');
    if (pendingRoomInvite) {
      console.log('[DEBUG] Found pending room invite after sign in:', pendingRoomInvite);

      // Clear the pending invite and set up the room
      localStorage.removeItem('pendingRoomInvite');
      myRoomId = pendingRoomInvite;
      roomId = pendingRoomInvite;
      isPrivateGame = true;
      localStorage.setItem('privateRoomId', pendingRoomInvite);

      // Join the private room
     safeEmit('joinGame', { 
      roomId: myRoomId, 
      username: myUsername, 
      userId,
      era: selectedEra 
    });
      navigateTo('/waiting');
      return;
    }
    
    navigateTo('/home'); 
  }


  function setupNavDropdown() {
  const dropdown = document.getElementById('nav-dropdown');
  const dropdownBtn = document.getElementById('nav-dropdown-btn');
  const dropdownContent = document.getElementById('nav-dropdown-content');
  const navTitleLink = document.getElementById('nav-title-link');
  const navDropdownProfile = document.getElementById('nav-dropdown-profile');
  const navDropdownSignout = document.getElementById('nav-dropdown-signout');

  if (!dropdown || !dropdownBtn) return;

  // Toggle dropdown on button click
  dropdownBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    dropdown.classList.toggle('open');
  });

  // Close dropdown when clicking outside
  document.addEventListener('click', (e) => {
    if (!dropdown.contains(e.target)) {
      dropdown.classList.remove('open');
    }
  });

  // Title link navigation
  if (navTitleLink) {
    navTitleLink.addEventListener('click', (e) => {
      e.preventDefault();
      dropdown.classList.remove('open');
      
      // Navigate based on auth state
      if (myUsername && myUserId) {
        navigateTo('/home');
      } else {
        navigateTo('/signup');
      }
    });
  }

  // Dropdown home link
  if (navDropdownProfile) {
  navDropdownProfile.addEventListener('click', (e) => {
    e.preventDefault();
    dropdown.classList.remove('open');
    
    if (myUsername && myUserId) {
      navigateTo('/profile');
    } else {
      navigateTo('/signup');
    }
  });
}

  // Dropdown signout link
  if (navDropdownSignout) {
    navDropdownSignout.addEventListener('click', async (e) => {
      e.preventDefault();
      dropdown.classList.remove('open');
      await signOut();
    });
  }
}

async function signOut() {
  try {
    // Check if user is in an active game
    if (gameStarted && !gameOver && socket && socket.connected) {
      // Emit a specific sign-out event to give opponent the win
      socket.emit('playerSignedOut', { 
        roomId: myRoomId || roomId,
        username: myUsername,
        reason: 'signed_out'
      });
    }
    
    // Set leaving game flag to prevent reconnection attempts
    isLeavingGame = true;
    localStorage.setItem('isLeavingGame', 'true');
    
    // Sign out from Supabase
    const { error } = await supabase.auth.signOut();
    if (error) {
      console.error('Sign out error:', error.message);
      alert('Sign out error: ' + error.message);
      return;
    }
    
    // Clear all game state and localStorage
    resetAllGameState();
    localStorage.clear();
    
    // Reset global variables
    myUsername = null;
    myUserId = null;
    myRoomId = null;
    roomId = null;
    gameStarted = false;
    gameOver = true;
    
    // Update UI and navigate
    updateNavUserState(null);
    navigateTo('/signup');
    
    console.log('Successfully signed out');
  } catch (error) {
    console.error('Unexpected sign out error:', error);
    alert('An unexpected error occurred during sign out.');
  }
}

async function loadProfileData() {
  // Update profile information
  const profileUsername = document.getElementById('profile-username');
  const profileEmail = document.getElementById('profile-email');
  const profileMemberSince = document.getElementById('profile-member-since');
  
  if (profileUsername) {
    profileUsername.textContent = myUsername || 'Guest';
  }
  
  // Get user session for email
  const { data: { session } } = await supabase.auth.getSession();
  if (profileEmail && session?.user?.email) {
    profileEmail.textContent = session.user.email;
  }
  
  if (profileMemberSince) {
    if (session?.user?.created_at) {
      const createdDate = new Date(session.user.created_at);
      profileMemberSince.textContent = createdDate.toLocaleDateString();
    } else {
      profileMemberSince.textContent = new Date().toLocaleDateString();
    }
  }
  
  // Load real stats from database
  await loadRealProfileStats();
}


async function getUserStats(userId) {
  if (!userId) return { games_played: 0, wins: 0, losses: 0 };
  
  try {
    const { data, error } = await supabase
      .from('user_stats')
      .select('games_played, wins, losses')
      .eq('user_id', userId)
      .single();
      
    if (data) {
      return {
        games_played: data.games_played || 0,
        wins: data.wins || 0,
        losses: data.losses || 0,
        win_rate: data.games_played > 0 ? Math.round((data.wins / data.games_played) * 100) : 0
      };
    }
    return { games_played: 0, wins: 0, losses: 0, win_rate: 0 };
  } catch (error) {
    console.error('Error loading user stats:', error);
    return { games_played: 0, wins: 0, losses: 0, win_rate: 0 };
  }
}


async function loadRealProfileStats() {
  const stats = await getUserStats(myUserId);
  
  // Safely update DOM elements only if they exist
  const updateElement = (id, value) => {
    const el = document.getElementById(id);
    if (el) el.textContent = value;
  };
  
  updateElement('profile-total-games', stats.games_played);
  updateElement('profile-games-won', stats.wins);
  updateElement('profile-win-rate', `${stats.win_rate}%`);
  updateElement('profile-avg-guesses', '0'); // Placeholder
}


async function displayStatsOnHomePage() {
  const stats = await getUserStats(myUserId);
  
  // Update home page elements (when you add them)
  const updateElement = (id, value) => {
    const el = document.getElementById(id);
    if (el) el.textContent = value;
  };
  
  updateElement('home-games-played', stats.games_played);
  updateElement('home-win-rate', `${stats.win_rate}%`);
  // etc.
}



function updateSplitScoreboard(stats, player1, player2) {
  const p1NameEl = document.getElementById('player1Name');
  const p2NameEl = document.getElementById('player2Name');

  if (!p1NameEl || !p2NameEl) {
    console.warn('[DEBUG] Scoreboard elements not found. Skipping updateSplitScoreboard.');
    return; // Or: queue the update!
  }

  const p1Name = player1 || 'Player 1';
  const p2Name = player2 || 'Player 2';

  p1NameEl.textContent = p1Name;
  p2NameEl.textContent = p2Name;

  const safeStats = stats || {};
  const player1Stats = safeStats[p1Name];
  const player2Stats = safeStats[p2Name];
  const p1Wins = (player1Stats && typeof player1Stats.wins === 'number') ? player1Stats.wins : 0;
  const p2Wins = (player2Stats && typeof player2Stats.wins === 'number') ? player2Stats.wins : 0;

  document.getElementById('player1Score').textContent = p1Wins;
  document.getElementById('player2Score').textContent = p2Wins;
}



function waitForScoreboard() {
  return new Promise((resolve) => {
    const check = () => {
      if (
        document.getElementById('player1Name') &&
        document.getElementById('player1Score')
      ) {
        resolve();
      } else {
        requestAnimationFrame(check);
      }
    };
    check();
  });
}



function markLeadoffInGuesses(guesses, leadoffName) {
  return guesses.map(g => ({
    ...g,
    isLeadoff: g.name === leadoffName
  }));
}

function showLeadoffCareerSection(playerName) {
  careerDataLoaded = false;
  
  const careerSection = document.getElementById('leadoff-career-section');
  const careerContent = document.getElementById('leadoff-career-content');
  const careerLink = document.querySelector('.career-link');
  
  if (!careerSection || !careerContent) {
    console.error('Career section elements not found in DOM');
    return;
  }
  
  // ‚úÖ CRITICAL: Show the career link first
  if (careerLink) {
    careerLink.style.display = 'flex';  // Change from 'none' to 'flex'
    careerLink.style.alignItems = 'center';
    careerLink.style.gap = '0.25rem';
  }
  
  // Now get the toggle elements after they're visible
  const toggleText = document.querySelector('.toggle-text');
  const toggleIcon = document.querySelector('.toggle-icon');
  
  if (!toggleText || !toggleIcon) {
    console.error('Toggle elements not found in DOM');
    return;
  }
  
  // Show the career section header but keep content collapsed
  careerSection.style.display = 'block';
  careerContent.style.display = 'none';
  
  // Always reset to "Career Details" when showing the section
  toggleText.textContent = 'Career Details';
  toggleIcon.textContent = '‚ñº';
  
  // Reset content
  careerContent.innerHTML = '<div class="career-loading">Loading career details...</div>';
}




// Function to toggle the career details visibility and load data if needed
async function toggleLeadoffCareer() {
  const careerContent = document.getElementById('leadoff-career-content');
  const toggleIcon = document.querySelector('.toggle-icon');
  const toggleText = document.querySelector('.toggle-text'); 
  
  if (!careerContent || !toggleIcon || !toggleText) {
    console.error('Career elements not found');
    return;
  }
  
  const isExpanded = careerContent.style.display === 'block';
  
  if (isExpanded) {
    // Collapse
    careerContent.style.display = 'none';
    toggleIcon.textContent = '‚ñº';
    toggleText.textContent = 'Career Details'; 
  } else {
    // Expand
    careerContent.style.display = 'block';
    toggleIcon.textContent = '‚ñ≤';
    toggleText.textContent = 'Hide Details'; // Optional: change text when expanded
    
    if (!careerDataLoaded) {
      try {
        const currentPlayerName = getCurrentPlayerName();
        if (!currentPlayerName) {
          throw new Error('No current player name available');
        }
        
        const response = await fetch(`/player-career?name=${encodeURIComponent(currentPlayerName)}`);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const careerData = await response.json();
        displayCareerData(careerData);
        careerDataLoaded = true;
        
      } catch (error) {
        console.error('Error loading career data:', error);
        careerContent.innerHTML = `<div class="career-error">Failed to load career data: ${error.message}</div>`;
      }
    }
  }
}


// Helper function to get current player name
function getCurrentPlayerName() {
   console.log('[DEBUG] successfulGuesses:', successfulGuesses);
  console.log('[DEBUG] window.successfulGuesses:', window.successfulGuesses);

  if (typeof successfulGuesses !== 'undefined' && successfulGuesses && successfulGuesses.length > 0) {
    const leadoffGuess = successfulGuesses.find(guess => guess.isLeadoff);
    if (leadoffGuess && leadoffGuess.name) {
      console.log('[getCurrentPlayerName] Found leadoff player:', leadoffGuess.name);
      return leadoffGuess.name;
    }
  }
  
  // Fallback: check window.successfulGuesses
  if (window.successfulGuesses && window.successfulGuesses.length > 0) {
    const leadoffGuess = window.successfulGuesses.find(guess => guess.isLeadoff);
    if (leadoffGuess && leadoffGuess.name) {
      console.log('[getCurrentPlayerName] Found leadoff player in window:', leadoffGuess.name);
      return leadoffGuess.name;
    }
  }
  
  console.warn('[getCurrentPlayerName] Could not find leadoff player in successfulGuesses');
  return null;
}



function hideLeadoffCareer() {
  const careerSection = document.getElementById('leadoff-career-section');
  const careerLink = document.querySelector('.career-link');
  
  // Hide the career section
  if (careerSection) {
    careerSection.style.display = 'none';
  }
  
  // ‚úÖ ALSO hide the career link and arrow
  if (careerLink) {
    careerLink.style.display = 'none';
  }
  
  careerDataLoaded = false;
}


function showSkipToast(message) {
  // Remove any existing skip toast notifications
  const existingToast = document.querySelector('.skip-toast');
  if (existingToast) {
    existingToast.remove();
  }

  // Create new toast notification
  const toast = document.createElement('div');
  toast.className = 'skip-toast';
  toast.textContent = message;
  
  // Add to page
  document.body.appendChild(toast);
  
  // Auto-remove after 3 seconds
  setTimeout(() => {
    toast.classList.add('fade-out');
    setTimeout(() => {
      if (toast.parentNode) {
        toast.remove();
      }
    }, 300);
  }, 3000);
}



function displayCareerData(careerData) {
  const careerContent = document.getElementById('leadoff-career-content');
  if (!careerContent) return;
  
  const { playerName, firstYear, lastYear, totalTeams, teamStints } = careerData;
  
  let html = `
    <div class="team-stints-section">
  `;
  
  teamStints.forEach(stint => {
    const years = stint.startYear === stint.endYear 
      ? stint.startYear 
      : `${stint.startYear}‚Äì${stint.endYear}`;
    
    html += `
      <div class="team-stint">
        <span class="team-name">${stint.team}</span>
        <span class="years">${years}</span>
      </div>
    `;
  });
  
  html += `</div>`;
  
  careerContent.innerHTML = html;
}



async function startPrivateGame() {
   // Validate session before starting
  const { data: { session } } = await supabase.auth.getSession();
  if (!session?.user?.id) {
    console.log('[startPrivateGame] No valid session, redirecting');
    navigateTo('/signup');
    return;
  }

  console.log('[DEBUG] startPrivateGame called');
  resetAllGameState();

  isPrivateGame = true;
  isLeavingGame = false;
  console.log('[DEBUG] Reset isLeavingGame to false for private game');

  if (!myUsername) {
    alert('Missing username');
    return;
  }

  if (gameStarted && !gameOver) {
    alert('Finish your current game first.');
    return;
  }

  // Generate new room and clear stale room data
  myRoomId = `room-${Math.random().toString(36).substring(2, 8)}`;
  console.log(`[DEBUG] Generated new private room: ${myRoomId}`);

  const { data } = await window.supabase.auth.getUser();
  const userId = data?.user?.id;
  if (!userId) {
    alert('Could not get your user ID. Please sign in again.');
    return;
  }
  
  myUserId = userId;
  localStorage.setItem('userId', myUserId);
  
  // ‚úÖ Set up waiting room UI BEFORE navigation
  const statusDiv = document.getElementById('status');
  if (statusDiv) {
    statusDiv.textContent = `Started private room: ${myRoomId}`;
  }
  
  const displayRoomCode = document.getElementById('displayRoomCode');
  if (displayRoomCode) {
    displayRoomCode.textContent = myRoomId;
  }

  const inviteInput = document.getElementById('inviteLink');
  if (inviteInput) {
    inviteInput.value = `${window.location.origin}?room=${myRoomId}`;
  }

  // Ensure waiting room is visible
  const waitingRoom = document.getElementById('waitingRoom');
  if (waitingRoom) {
    waitingRoom.classList.remove('hidden');
  }

  // Setup copy button listeners
  setupCopyInviteListeners();

  // ‚úÖ Navigate and then emit
  await navigateTo('/waiting');
  safeEmit('joinGame', { 
  roomId: myRoomId, 
  username: myUsername, 
  userId,
  era: selectedEra || localStorage.getItem('selectedEra') || '2000-present' 
});
}



async function joinPublicGame() {
  // Validate session before joining
  const { data: { session } } = await supabase.auth.getSession();
  if (!session?.user?.id) {
    console.log('[joinPublicGame] No valid session, redirecting');
    navigateTo('/signup');
    return;
  }

  console.log('[DEBUG] joinPublicGame called');
  resetAllGameState();


  if (socket && socket.connected && session.user) {
    socket.emit('userSignedIn', { 
      userId: session.user.id, 
      username: session.user.user_metadata?.username || session.user.email 
    });
  }

  isLeavingGame = false;
  localStorage.removeItem('isLeavingGame');

  if (!myUsername) {
    console.warn('[DEBUG] myUsername is null, attempting to recover from session');
    // Try to get username from current session
    const { data: { user } } = await supabase.auth.getUser();
    if (user) {
      myUsername = user.user_metadata?.username || user.email;
      localStorage.setItem('username', myUsername);
      console.log('[DEBUG] Recovered username:', myUsername);
    }

    // If still no username, show error
    if (!myUsername) {
      alert('Missing username. Please sign out and sign in again.');
      return;
    }
  }

  if (gameStarted && !gameOver) {
    alert('Finish your current game first.');
    return;
  }

  myRoomId = null;
  roomId = null;
  isPrivateGame = false;
  selectedPlayer = null;
  successfulGuesses = [];
  gameOver = false;
  gameStarted = false;
  leadoffPlayerName = null;
  opponentName = null;

  // Clear UI elements
  if (currentPlayerNameEl) currentPlayerNameEl.textContent = '';
  if (timerEl) timerEl.textContent = '';
  if (currentPlayerHeadshotEl) currentPlayerHeadshotEl.src = DEFAULT_PLAYER_IMAGE;

  // Clear turn history
  const cardDeck = document.getElementById('card-deck');
  if (cardDeck) cardDeck.innerHTML = '';

  // Clear any persistent localStorage
  localStorage.removeItem('privateRoomId');
  localStorage.removeItem('isLeavingGame');

  // ‚úÖ Ensure socket is connected (don't re-initialize)
  if (!socket || !socket.connected) {
    console.log('[joinPublicGame] Socket not ready, waiting for connection...');
    // Socket should already be initialized in DOMContentLoaded
  }

  // Fetch user_id from Supabase and emit findMatch with userId
  const { data: { user } } = await supabase.auth.getUser();
  const userId = user?.id;
  if (!userId) {
    alert('Could not get your user ID. Please sign in again.');
    return;
  }

  myUserId = userId;
  localStorage.setItem('userId', myUserId);

  console.log('[DEBUG] Navigating to /waiting...');
  await navigateTo('/waiting');

  // ‚úÖ Add this: Ensure status message is set for public games
  if (statusDiv) {
    statusDiv.textContent = 'Looking for an opponent...';
  }

  console.log('[DEBUG] Using safeEmit to find match:', myUsername, userId);
  safeEmit('findMatch', { username: myUsername, userId, era: selectedEra });
}



  function safeEmit(event, data) {
    if (!socket) {
      console.warn(`[safeEmit] Socket is null ‚Äî this shouldn't happen after DOMContentLoaded`);
      return; // Don't emit if socket isn't ready
    }

  emitQueue.push({ event, data });

  if (socket && socket.connected) {
    console.log(`[safeEmit] Socket connected ‚Äî emitting "${event}" immediately`);
    flushEmitQueue();
  } else {
    console.log(`[safeEmit] Socket not connected ‚Äî queued "${event}"`);
  }
}

function flushEmitQueue() {
  if (!socket) {
    console.warn(`[flushEmitQueue] Socket is null ‚Äî cannot flush`);
    return;
  }

  while (socket.connected && emitQueue.length > 0) {
    const { event, data } = emitQueue.shift();
    console.log(`[safeEmit] Flushing queued "${event}"`);
    socket.emit(event, data);
  }
}

function updateTimerStyle(timeLeft, totalTime = 30) {
  const timerEl = document.getElementById('timer');
  const progressRing = document.querySelector('.progress-ring-circle');
  
  if (!timerEl || !progressRing) return;
  
  // Calculate progress (0 to 1, where 1 is full time remaining)
  const progress = timeLeft / totalTime;
  
  // ‚úÖ FIX: Use consistent radius that matches SVG
  const radius = 35; 
  const circumference = 2 * Math.PI * 35; 
  
  // Calculate offset - start from top (12:00 position)
  const offset = circumference * (1 - progress);
  
  // Update both stroke-dasharray and stroke-dashoffset
  progressRing.style.strokeDasharray = circumference;
  progressRing.style.strokeDashoffset = offset;
  
  // Remove existing classes
  progressRing.classList.remove('critical-time', 'low-time');
  
  // Add appropriate class based on time remaining
  if (timeLeft <= 5) {
    progressRing.classList.add('critical-time');
  } else if (timeLeft <= 10) {
    progressRing.classList.add('low-time');
  }
  
  // Update the number display
  timerEl.textContent = `:${timeLeft}`;
}








function updateHeadshot(player) {
  if (currentPlayerHeadshotEl) {
    currentPlayerHeadshotEl.src = player.headshot_url || DEFAULT_PLAYER_IMAGE;
    currentPlayerHeadshotEl.alt = `${player.player_name || 'Unknown'} Headshot`;
  }
}

function triggerGameEndCardSpread() {
  const deckContainer = document.getElementById('card-deck');
  if (!deckContainer) return;
  
  // Add a small delay to let the game over UI settle
  setTimeout(() => {
    deckContainer.classList.add('game-ended');  // ‚úÖ Add to the container itself
    
    // Optional: Add a subtle sound effect or visual feedback
    console.log('üé¥ Cards spreading out to show the full game sequence!');
  }, 1000); // 1 second delay after game ends
}

function resetCardSpread() {
  const deckContainer = document.getElementById('card-deck');
  if (!deckContainer) return;
  
  // Remove the game-ended class
  deckContainer.classList.remove('game-ended');
  
  // ‚úÖ Also force remove any lingering transform styles
  deckContainer.style.transform = '';
  
  // ‚úÖ Reset any individual card transforms
  const cards = deckContainer.querySelectorAll('.player-card');
  cards.forEach(card => {
    card.style.transform = '';
    card.style.left = '';
    card.style.zIndex = '';
  });
  
  console.log('üé¥ Card spread animation reset for new game');
}



function attachRouteListeners(route) {
  supabase.auth.getSession().then(({ data }) => {
    updateNavUserState(data.session);
  });

  switch (route) {
    case '/signup':
      // Setup auth tab switching
      setupAuthTabs();
      // Only non-form button listeners (forms handled by setupFormListeners)
      const forgotPasswordLink = document.getElementById('forgotPasswordLink');
      if (forgotPasswordLink) {
        forgotPasswordLink.addEventListener('click', (e) => {
          e.preventDefault();
          navigateTo('/reset');
        });
      }
      break;



    case '/confirmed':
      const confirmedContinueBtn = document.getElementById('confirmedContinueBtn');
      if (confirmedContinueBtn) {
        confirmedContinueBtn.addEventListener('click', () => {
          handleAuthSuccess();
        });
      }
      // Update nav state for confirmed page
      updateNavUserState();
      break;

    case '/home':
      // const privateGameBtn = document.getElementById('privateGameBtn');
      // const findGameBtn = document.getElementById('findGameBtn');
      // const signoutBtn = document.getElementById('signoutBtn');
      
      // if (privateGameBtn) {
      //   privateGameBtn.addEventListener('click', () => {
      //     if (privateGameBtn.disabled) return; // Prevent multiple clicks
      //     privateGameBtn.disabled = true;
      //     setTimeout(() => privateGameBtn.disabled = false, 2000); // Re-enable after 2s

      //     isLeavingGame = false;
      //     startPrivateGame();
      //   });
      // }

      // if (findGameBtn) {
      //   findGameBtn.addEventListener('click', () => {
      //     if (findGameBtn.disabled) return; // Prevent multiple clicks
      //     findGameBtn.disabled = true;
      //     setTimeout(() => findGameBtn.disabled = false, 2000); // Re-enable after 2s

      //     isLeavingGame = false;
      //     joinPublicGame();
      //   });
      // }

      setupGameTypeSelection();
      setupEraSelection();


      const signoutBtn = document.getElementById('signoutBtn');
      if (signoutBtn) {
        signoutBtn.addEventListener('click', signOut);
      }

      loadPlayerStats();
      break;

      case '/profile':
  loadProfileData();
  
  const profileSignoutBtn = document.getElementById('profile-signout-btn');
  if (profileSignoutBtn) {
    profileSignoutBtn.addEventListener('click', signOut);
  }
  break;

    case '/play':
      // Game-specific listeners
      const submitGuessBtn = document.getElementById('submitGuessBtn');
      const rematchBtn = document.getElementById('rematchBtn');
      
      if (submitGuessBtn) {
        submitGuessBtn.addEventListener('click', submitGuess);
      }
      
      if (rematchBtn) {
        rematchBtn.addEventListener('click', requestRematch);
      }
      
      // Setup autocomplete for gameplay
      setupAutocompleteListeners();
      setupMobileInputFocus();
      break;

    case '/waiting':
      if (isPrivateGame && myRoomId) {
        const inviteInput = document.getElementById('inviteLink');
        if (inviteInput) {
          inviteInput.value = `${window.location.origin}?room=${myRoomId}`;
        }

        const roomCodeEl = document.getElementById('displayRoomCode');
        if (roomCodeEl) {
          roomCodeEl.textContent = myRoomId;
        }

        waitingRoom.classList.remove('hidden');
      }
      // Setup copy invite button listener anyway
      setupCopyInviteListeners();
      break;


    case '/matched':
      // No specific listeners needed for matched screen
      // Countdown handles automatic transition
      break;


    // Add other route handlers as needed
  }
}

function navigateTo(path, options = {}) {
  return new Promise((resolve) => {
    // ‚úÖ Don't reset leaving game flag when navigating to waiting room
    if (path === '/home') {
      isLeavingGame = false;
      localStorage.removeItem('isLeavingGame');
    } else if (path === '/waiting' && isPrivateGame && myRoomId) {
      // Preserve room state when going to waiting room
      isLeavingGame = false;
      localStorage.removeItem('isLeavingGame');
      console.log('[DEBUG] Preserving room state for waiting room navigation');
    }

    currentRoute = path;

    if (!options.skipPush) {
      history.pushState({}, '', path);
    }

    showRouteSection(path);
    updateUIForRoute(path);
    attachRouteListeners(path);

    requestAnimationFrame(() => {
      resolve();
    });
  });
}



function setupMobileInputFocus() {
  const guessInput = document.getElementById('guessInput');
  if (!guessInput) return;

  guessInput.addEventListener('focus', () => {
    if (window.innerWidth <= 768) {
      setTimeout(() => {
        // Gentle scroll to ensure input is visible without hiding player info
        const inputRect = guessInput.getBoundingClientRect();
        const viewportHeight = window.innerHeight;
        
        // Only scroll if input is below the fold
        if (inputRect.bottom > viewportHeight - 50) {
          const scrollAmount = inputRect.bottom - viewportHeight + 100;
          window.scrollBy({
            top: scrollAmount,
            behavior: 'smooth'
          });
        }
      }, 300);
    }
  });
}



function scrollToGameArea() {
  // Only apply on mobile devices
  if (window.innerWidth <= 768) {
    const gameArea = document.getElementById('gameArea');
    const turnSection = document.getElementById('turnSection');
    
    if (gameArea && turnSection) {
      // Calculate optimal scroll position
      const gameAreaTop = gameArea.getBoundingClientRect().top + window.scrollY;
      const turnSectionTop = turnSection.getBoundingClientRect().top + window.scrollY;
      
      // Use turn section as primary target, fallback to game area
      const targetPosition = turnSectionTop || gameAreaTop;
      const offset = 20; // Small padding from top
      
      window.scrollTo({
        top: Math.max(0, targetPosition - offset),
        behavior: 'smooth'
      });
    }
  }
}



function setupAuthTabs() {
  const tabSignup = document.getElementById('tab-signup');
  const tabSignin = document.getElementById('tab-signin');
  const signupForm = document.getElementById('signupForm');
  const signinForm = document.getElementById('signinForm');
  
  if (tabSignup && tabSignin && signupForm && signinForm) {
    tabSignup.addEventListener('click', function() {
      tabSignup.classList.add('active');
      tabSignin.classList.remove('active');
      signupForm.classList.add('active');
      signinForm.classList.remove('active');
    });
    
    tabSignin.addEventListener('click', function() {
      tabSignin.classList.add('active');
      tabSignup.classList.remove('active');
      signinForm.classList.add('active');
      signupForm.classList.remove('active');
    });
  }
}



  function submitGuess() {
  const guess = guessInput.value.trim();
  clearGuessError();

  if (!guess) {
    showGuessError('Enter a guess');
    return;
  }
  if (guess !== selectedPlayer) {
    showGuessError('Please select a player from the dropdown list.');
    return;
  }

  socket.emit('playerGuess', { roomId, guess });
  guessInput.value = '';
  selectedPlayer = null;
  submitGuessBtn.disabled = true;
  clearAutocomplete();
}


function requestRematch() {
  if (!myRoomId) {
    console.error('No roomId defined. Cannot request rematch.');
    return;
  }
  rematchBtn.disabled = true;
  rematchBtn.textContent = 'Waiting for opponent...';
  socket.emit('requestRematch', { roomId: myRoomId });
}


function resetGameUI() {
  gameStarted = true;
  gameOver = false;

  // Clear old timers
  if (window.timerInterval) {
    clearInterval(window.timerInterval);
    window.timerInterval = null;
  }

  guessInput.disabled = true;
  submitGuessBtn.disabled = true;
  guessInput.value = '';
  clearGuessError();
  clearAutocomplete();

  // Reset rematch button visibility and style
  rematchBtn.style.display = 'none';
  rematchBtn.disabled = false;
  rematchBtn.textContent = 'Rematch';
  rematchBtn.style.backgroundColor = '';

  // Reset UI parts
  messagesEl.innerHTML = '';
  messagesEl.style.display = 'block';

  // ‚úÖ CRITICAL: Reset card spread animation BEFORE clearing cards
  resetCardSpread();

  // Clear stored headshots for new game
  storedHeadshots.clear();

  successfulGuesses.length = 0;
  document.getElementById('card-deck').innerHTML = '';
  renderSuccessfulGuesses();

  currentPlayerNameEl.textContent = 'Loading...';
  timerEl.textContent = ':30';

  // ‚úÖ Use CSS classes instead of inline styles
  waitingRoom.classList.add('hidden');     // Instead of style.display = 'none'
  gameArea.classList.remove('hidden');     // Instead of style.display = 'block'
  document.getElementById('turnSection').style.display = 'block';

  // Hide game over container
  const gameOverContainer = document.getElementById('gameOverContainer');
  gameOverContainer.innerHTML = '';
  gameOverContainer.style.display = 'none';

  // Clear persistent rematch message
  const messageContainer = document.getElementById('messageContainer');
  if (messageContainer) {
    messageContainer.innerHTML = '';
  }

  // Reset career section
  hideLeadoffCareer();
  leadoffPlayerName = null;
}



function showGuessError(message) {
  showMessage(message, 'error');
}


 function clearGuessError() {
    const container = document.getElementById('messageContainer');
    container.innerHTML = '';
  }

  function showMessage(message, type = 'info', persist = false) {
    const container = document.getElementById('messageContainer');
    container.innerHTML = '';

    const div = document.createElement('div');
    div.textContent = message;
    div.classList.add('message');

    if (type === 'error') div.classList.add('error');

    container.appendChild(div);

    if (!persist) {
      setTimeout(() => {
        div.classList.add('fade-out');
        setTimeout(() => container.innerHTML = '', 1000);
      }, 3000);
    }
  }




  function clearAutocomplete() {
    autocompleteList.innerHTML = '';
    autocompleteList.style.display = 'none';
  }


function showAutocompleteSuggestions(suggestions) {
  const list = document.getElementById('autocomplete-list');
  list.innerHTML = '';

  if (suggestions.length === 0) {
    list.style.display = 'none';  // Hide when empty
    return;
  }

  list.style.display = 'block'; // Show when populated

  suggestions.forEach(suggestionEl => {
    // suggestionEl is an element, append it directly
    list.appendChild(suggestionEl);
  });
}

async function ensureUserSession() {
  const { data: { session }, error } = await supabase.auth.getSession();
  
  if (error || !session?.user) {
    console.warn('[ensureUserSession] No valid session!');
    myUsername = null;
    myUserId = null;
    return false;
  }
  
  const user = session.user;
  myUserId = user.id;
  myUsername = user.user_metadata?.username || user.email;
  
  // Sync localStorage
  localStorage.setItem('username', myUsername);
  localStorage.setItem('userId', myUserId);
  
  console.debug('[ensureUserSession] Session validated:', myUsername, myUserId);
  return true;
}


function resetAllGameState() {
  roomId = null;
  myRoomId = null;
  selectedPlayer = null;
  gameStarted = false;
  gameOver = true;
  leadoffPlayerName = null;
  hideLeadoffCareer();
  opponentName = null;
  successfulGuesses = [];
  isPrivateGame = false;
  isLeavingGame = false;
  
  localStorage.removeItem('privateRoomId');
  localStorage.removeItem('isLeavingGame');

   gameTypeSelected = false;
  const eraSelection = document.getElementById('eraSelection');
  const gameModeSelection = document.getElementById('gameModeSelection');
  
  if (eraSelection) {
    eraSelection.classList.add('hidden');
  }
  
  if (gameModeSelection) {
    gameModeSelection.style.opacity = '1';
    gameModeSelection.style.pointerEvents = 'auto';
  }
  
  // Reset step indicator
  document.querySelectorAll('.step').forEach(s => s.classList.remove('active'));
  document.querySelector('[data-step="1"]')?.classList.add('active');
  
  // Reset UI elements
  if (currentPlayerNameEl) currentPlayerNameEl.textContent = '';
  if (timerEl) timerEl.textContent = '';
  if (currentPlayerHeadshotEl) currentPlayerHeadshotEl.src = DEFAULT_PLAYER_IMAGE;
  
  const cardDeck = document.getElementById('card-deck');
  if (cardDeck) cardDeck.innerHTML = '';
  
  resetCardSpread();
}



function renderSuccessfulGuesses() {
  const deckContainer = document.getElementById('card-deck');
  if (!deckContainer || !Array.isArray(successfulGuesses)) return;

  deckContainer.innerHTML = '';
  const reversedGuesses = [...successfulGuesses].reverse();

  reversedGuesses.forEach((guessObj, index) => {
    const name = guessObj?.name || '';
    const isLeadoff = !!guessObj?.isLeadoff;
    const guesser = guessObj?.guesser || '';
    const sharedTeams = Array.isArray(guessObj?.sharedTeams) ? guessObj.sharedTeams : [];
    const headshotUrl = guessObj?.headshot_url || DEFAULT_PLAYER_IMAGE;

    console.log(`Card ${index}: ${name}, headshot: ${headshotUrl}`);

    if (!name) return;

    const card = document.createElement('div');
    card.className = 'player-card';
    
    // Set the headshot URL as a CSS custom property
    card.style.setProperty('--headshot-url', `url("${headshotUrl}")`);
    card.setAttribute('data-headshot', headshotUrl);
    
    if (index === 0 && successfulGuesses.length > 1) {
      card.classList.add('new-card');
    }
    
    if (isLeadoff) {
      card.classList.add('leadoff');
    } else if (guesser === myUsername) {
      card.classList.add('your-guess');
    } else {
      card.classList.add('opponent-guess');
    }

    // Rest of the card creation code remains the same...
    const headerEl = document.createElement('div');
    headerEl.className = 'card-header';
    headerEl.textContent = isLeadoff ? 'Leadoff Player' : 'Teammate';
    card.appendChild(headerEl);

    const nameEl = document.createElement('div');
    nameEl.className = 'card-player-name';
    nameEl.textContent = name;
    card.appendChild(nameEl);

    const connectionEl = document.createElement('div');
    connectionEl.className = 'card-connection';
    
    if (!isLeadoff && sharedTeams.length > 0) {
      const teamStrings = sharedTeams.map(team => {
        if (typeof team === 'object' && team.team && team.years) {
          return `${team.team} (${team.years})`;
        }
        return team;
      });
      
      connectionEl.innerHTML = `<strong>Connected via:</strong><br>${teamStrings.join('<br>')}`;
    } else if (isLeadoff) {
      connectionEl.innerHTML = '<strong>Starting Player</strong><br>Begin the chain!';
    }
    card.appendChild(connectionEl);

    const footerEl = document.createElement('div');
    footerEl.className = 'card-footer';
    if (isLeadoff) {
      footerEl.textContent = 'Game Start';
    } else if (guesser === myUsername) {
      footerEl.textContent = 'Guessed by You';
    } else {
      footerEl.innerHTML = `Guessed by<br>${guesser}`;
    }
    card.appendChild(footerEl);

    deckContainer.appendChild(card);
  });
}






function showRouteSection(path) {
  const allSections = document.querySelectorAll('section[data-route]');
  let matched = false;

  allSections.forEach(section => {
    const route = section.getAttribute('data-route');
    if (route === path) {
      section.classList.remove('hidden');
      matched = true;
    } else {
      section.classList.add('hidden');
    }
  });

  // Fallback if no matching route found
  if (!matched) {
    const defaultSection = document.querySelector('section[data-route="/signup"]');
    if (defaultSection) {
      defaultSection.classList.remove('hidden');
    }
  }
}

function updateUIForRoute(path) {
  if (path !== currentRoute) {
    console.debug('[updateUIForRoute] Skipped because stale:', path, 'Expected:', currentRoute);
    return;
  }

  console.debug('[updateUIForRoute] Handling:', path);

if (path === '/home') {
  console.log('[DEBUG] updateUIForRoute: Handling /home');

  updateNavUserState();

  // ‚úÖ Emit leaveGame when navigating away from active game
  if (socket && socket.connected && (gameStarted || myRoomId) && !isLeavingGame) {
    console.log('[DEBUG] Emitting leaveGame due to navigation to home');
    isLeavingGame = true;
    localStorage.setItem('isLeavingGame', 'true');
    
    socket.emit('leaveGame');
  }

  gameStarted = false;
  gameOver = true;
  roomId = null;
  myRoomId = null;
  isPrivateGame = false;
  selectedPlayer = null;
  successfulGuesses = [];

  const welcomeEl = document.getElementById('home-welcome');
  if (welcomeEl && myUsername) {
    welcomeEl.textContent = `Welcome, ${myUsername}! Choose your game mode below.`;
  }
}


if (path === '/profile') {
  console.log('[DEBUG] updateUIForRoute: Handling /profile');

  updateNavUserState();

  // ‚úÖ Emit leaveGame when navigating away from active game (same as home)
  if (socket && socket.connected && (gameStarted || myRoomId) && !isLeavingGame) {
    console.log('[DEBUG] Emitting leaveGame due to navigation to profile');
    isLeavingGame = true;
    localStorage.setItem('isLeavingGame', 'true');
    
    socket.emit('leaveGame');
  }

  gameStarted = false;
  gameOver = true;
  roomId = null;
  myRoomId = null;
  isPrivateGame = false;
  selectedPlayer = null;
  successfulGuesses = [];

  // Load profile data
  loadProfileData();
}


 if (path === '/waiting') {
  if (isLeavingGame && !isPrivateGame) {
    console.log('[DEBUG] updateUIForRoute: Skipping /waiting because isLeavingGame is true');
    return;
  }
  
  // ‚úÖ Ensure isLeavingGame is false for waiting room
    if (isPrivateGame && myRoomId) {
    isLeavingGame = false;
    localStorage.removeItem('isLeavingGame');
    console.log('[DEBUG] Cleared isLeavingGame flag for private room:', myRoomId);
  }

  // Fix: Use correct element ID
  const waitingStatus = document.getElementById('waitingStatus');
  if (waitingStatus) {
    waitingStatus.textContent = isPrivateGame
      ? 'Waiting for a friend to join...'
      : 'Looking for an opponent...';
  }

  // Fix: Ensure status div is updated
  const statusDiv = document.getElementById('status');
  if (statusDiv && isPrivateGame && myRoomId) {
    statusDiv.textContent = `Started private room: ${myRoomId}`;
  }

  const codeEl = document.getElementById('displayRoomCode');
  const inviteWrapper = document.getElementById('inviteLinkWrapper');
  const inviteInput = document.getElementById('inviteLink');

  if (codeEl) {
    if (isPrivateGame && myRoomId) {
      const displayCode = myRoomId.replace('room-', '').substring(0, 8);
      codeEl.textContent = displayCode;
      codeEl.style.display = 'block';
    } else {
      codeEl.style.display = 'none';
    }
  }

  if (inviteWrapper && inviteInput) {
    if (isPrivateGame && myRoomId) {
      const inviteUrl = `${window.location.origin}?room=${myRoomId}`;
      inviteInput.type = 'text';
      inviteInput.value = inviteUrl;
      inviteWrapper.style.display = 'block';
    } else {
      inviteWrapper.style.display = 'none';
    }
  }

  // Fix: Ensure waiting room is visible
  const waitingRoom = document.getElementById('waitingRoom');
  if (waitingRoom) {
    waitingRoom.classList.remove('hidden');
  }
}


  const guessContainer = document.getElementById('successful-guesses-container');
  if (guessContainer) {
    guessContainer.style.display = (path === '/play' || path === '/gameover') ? 'block' : 'none';
  }

  const scoreboard = document.getElementById('scoreboardSection');
  if (scoreboard) {
    if (path === '/play' || path === '/gameover') {
      scoreboard.classList.remove('hidden');
    } else {
      scoreboard.classList.add('hidden');
    }
  }
}




function setupFormListeners() {
  // Signup form
  const signupForm = document.getElementById('signupForm');
  if (signupForm) {
    signupForm.addEventListener('submit', signUp);
    console.log('[DEBUG] signupForm listener attached');
  } else {
    console.warn('[WARN] signupForm not found - may not be on signup route');
  }

  // Signin form
  const signinForm = document.getElementById('signinForm');
  if (signinForm) {
    signinForm.addEventListener('submit', signIn);
    console.log('[DEBUG] signinForm listener attached');
  } else {
    console.warn('[WARN] signinForm not found - may not be on signin route');
  }

  // Reset password form
  const resetForm = document.getElementById('resetForm');
  if (resetForm) {
    resetForm.addEventListener('submit', resetPassword);
    console.log('[DEBUG] resetForm listener attached');
  } else {
    console.warn('[WARN] resetForm not found - may not be on reset route');
  }

  // Reset password button (not a form)
  const resetBtn = document.getElementById('resetBtn');
if (resetBtn) {
  resetBtn.addEventListener('click', resetPassword);
  console.log('[DEBUG] resetBtn listener attached');
} else {
  console.warn('[WARN] resetBtn not found - may not be on reset route');
}

// Update password button (not a form)
const updatePasswordBtn = document.getElementById('updatePasswordBtn');
if (updatePasswordBtn) {
  updatePasswordBtn.addEventListener('click', updatePassword);
  console.log('[DEBUG] updatePasswordBtn listener attached');
} else {
  console.warn('[WARN] updatePasswordBtn not found - may not be on update-password route');
}

  // Update password form
  const updatePasswordForm = document.getElementById('updatePasswordForm');
  if (updatePasswordForm) {
    updatePasswordForm.addEventListener('submit', updatePassword);
    console.log('[DEBUG] updatePasswordForm listener attached');
  } else {
    console.warn('[WARN] updatePasswordForm not found - may not be on update-password route');
  }

  // Username form (if you have one for setting username)
  const usernameForm = document.getElementById('usernameForm');
  if (usernameForm) {
    usernameForm.addEventListener('submit', setUsername);
    console.log('[DEBUG] usernameForm listener attached');
  } else {
    console.warn('[WARN] usernameForm not found - may not be on username route');
  }
}


function showOpponentIncorrectGuess(guesserName, incorrectGuess, currentPlayer) {
  // Use existing message system with opponent-specific styling
  const message = `"Guessed: ${incorrectGuess}" ‚ùå`;
  showMessage(message, 'opponent-incorrect', false);
  
  // Auto-clear after 4 seconds
  setTimeout(() => clearGuessError(), 4000);
}


function handleGoHome() {
  console.debug('[CLIENT] handleGoHome called');

  if (socket && socket.connected && (gameStarted || myRoomId) && !isLeavingGame) {
    console.log('[DEBUG] Emitting leaveGame from handleGoHome');
    isLeavingGame = true;
    localStorage.setItem('isLeavingGame', 'true');
    
    socket.emit('leaveGame', {
      roomId: myRoomId || roomId,
      username: myUsername,
      reason: 'clicked_home'
    });
  }

  resetAllGameState();

  myRoomId = null;
  roomId = null;
  isPrivateGame = false;
  gameStarted = false;
  gameOver = true;
  selectedPlayer = null;
  successfulGuesses = [];

  localStorage.removeItem('privateRoomId');

  navigateTo('/home');
}


function setupCopyInviteListeners() {
  const copyInviteBtn = document.getElementById('copyInviteBtn');
  const shareInviteBtn = document.getElementById('shareInviteBtn');
  const copyToast = document.getElementById('copyToast');
  const inviteInput = document.getElementById('inviteLink');

  if (!copyInviteBtn || !copyToast || !inviteInput) {
    return;
  }

  // Enhanced mobile/tablet detection
  function isMobileOrTablet() {
    // Check for touch capability
    const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    
    // Check screen size (mobile/tablet range)
    const isMobileSize = window.innerWidth <= 1024; // Tablets typically ‚â§ 1024px
    
    // Check user agent for mobile/tablet indicators
    const userAgent = navigator.userAgent.toLowerCase();
    const mobileKeywords = [
      'mobile', 'android', 'iphone', 'ipad', 'ipod', 
      'blackberry', 'windows phone', 'tablet'
    ];
    const hasMobileUA = mobileKeywords.some(keyword => userAgent.includes(keyword));
    
    // Device must have touch AND (be mobile-sized OR have mobile user agent)
    return hasTouch && (isMobileSize || hasMobileUA);
  }

  // Show share button only on mobile/tablet with Web Share API support
  if (shareInviteBtn && navigator.share && isMobileOrTablet()) {
    shareInviteBtn.style.display = 'inline-block';
    console.log('[Share] Share button enabled for mobile/tablet device');
  } else {
    if (shareInviteBtn) {
      shareInviteBtn.style.display = 'none';
    }
    console.log('[Share] Share button hidden - desktop or no Web Share API');
  }

  // Copy functionality
  copyInviteBtn.addEventListener('click', () => {
    navigator.clipboard.writeText(inviteInput.value)
      .then(() => {
        copyToast.textContent = 'Link copied!';
        copyToast.style.display = 'block';
        copyInviteBtn.disabled = true;

        setTimeout(() => {
          copyToast.style.display = 'none';
          copyInviteBtn.disabled = false;
        }, 2000);
      })
      .catch(err => {
        // Fallback for older browsers
        inviteInput.select();
        inviteInput.setSelectionRange(0, 99999);
        document.execCommand('copy');
        
        copyToast.textContent = 'Link copied!';
        copyToast.style.display = 'block';
        setTimeout(() => copyToast.style.display = 'none', 2000);
      });
  });

  // Native share functionality
  if (shareInviteBtn) {
    shareInviteBtn.addEventListener('click', async () => {
      const shareData = {
        title: 'Join my NBA Teammate Game!',
        text: 'Can you guess NBA teammates? Join my private game!',
        url: inviteInput.value
      };

      try {
        if (navigator.share) {
          await navigator.share(shareData);
          copyToast.textContent = 'Shared successfully!';
          copyToast.style.display = 'block';
          setTimeout(() => copyToast.style.display = 'none', 2000);
        }
      } catch (err) {
        // User cancelled or error occurred
        if (err.name !== 'AbortError') {
          console.log('Share failed, falling back to copy');
          // Fallback to copy
          copyInviteBtn.click();
        }
      }
    });
  }

  // Re-check on window resize (for device rotation)
  window.addEventListener('resize', () => {
    if (shareInviteBtn && navigator.share) {
      if (isMobileOrTablet()) {
        shareInviteBtn.style.display = 'inline-block';
      } else {
        shareInviteBtn.style.display = 'none';
      }
    }
  });
}


function showMatchedScreen(opponentName) {
  // Update opponent name
  const matchedOpponentEl = document.getElementById('matchedOpponentName');
  if (matchedOpponentEl) {
    matchedOpponentEl.textContent = opponentName;
  }

  // Navigate to matched screen
  navigateTo('/matched');

  // Start 5-second countdown
  startMatchCountdown();
}

function startMatchCountdown() {
  const countdownEl = document.getElementById('countdownTimer');
  if (!countdownEl) return;

  let timeLeft = 5;
  countdownEl.textContent = timeLeft;

  const countdownInterval = setInterval(() => {
    timeLeft--;
    
    if (timeLeft > 0) {
      countdownEl.textContent = timeLeft;
    } else {
      clearInterval(countdownInterval);
      
      // Countdown finished - now join the game and signal ready
      socket.emit('joinGame', { 
  roomId: myRoomId, 
  username: myUsername,
  userId: myUserId,
  era: localStorage.getItem('selectedEra') || '2000-present' 
});
      
      // Signal that this player is ready to start
      socket.emit('readyToStart', { roomId: myRoomId });
      
      // Navigate to waiting room
      navigateTo('/waiting');
    }
  }, 1000);
}



async function handleAuthSuccess() {
  const { data: { user }, error } = await supabase.auth.getUser();
  if (error || !user) {
    console.error('No user signed in');
    navigateTo('/signup');
    return;
  }

  const username = user.user_metadata?.username || null;

  if (!username) {
    console.error('No username found in user_metadata!');
    navigateTo('/signup');
    return;
  }

  // Try updating profiles row, but don‚Äôt block navigation if it fails
  const { error: updateError } = await supabase
    .from('profiles')
    .update({ username })
    .eq('id', user.id);

  if (updateError) {
    console.warn('Warning: Error updating profile:', updateError.message);
  } else {
    console.log('‚úÖ Username saved to profiles:', username);
  }

  myUsername = username;
  localStorage.setItem('username', myUsername);

  // Clear URL hash to remove confirmation tokens
  history.replaceState(null, '', window.location.pathname);

  const pendingRoomInvite = localStorage.getItem('pendingRoomInvite');
  if (pendingRoomInvite) {
    console.log('[DEBUG] Found pending room invite after email confirmation:', pendingRoomInvite);

    // Clear the pending invite and set up the room
    localStorage.removeItem('pendingRoomInvite');
    myRoomId = pendingRoomInvite;
    roomId = pendingRoomInvite;
    isPrivateGame = true;
    localStorage.setItem('privateRoomId', pendingRoomInvite);

    // Join the private room
    safeEmit('joinGame', {
      roomId: myRoomId,
      username: myUsername,
      userId: myUserId,
      era: localStorage.getItem('selectedEra') || '2000-present'
    });
    navigateTo('/waiting');
    return;
  }

  navigateTo('/home');
}

async function forceSignOut() {
  console.log('[forceSignOut] Cleaning up invalid session...');
  
  // ‚úÖ Preserve pending room invite
  const pendingRoomInvite = localStorage.getItem('pendingRoomInvite');
  
  try {
    await supabase.auth.signOut();
  } catch (error) {
    console.warn('[forceSignOut] Supabase signout error:', error);
  }
  
  // Clear everything
  localStorage.clear();
  
  // ‚úÖ Restore pending room invite if it existed
  if (pendingRoomInvite) {
    localStorage.setItem('pendingRoomInvite', pendingRoomInvite);
  }
  
  myUsername = null;
  myUserId = null;
  myRoomId = null;
  roomId = null;
  isPrivateGame = false;
  gameStarted = false;
  gameOver = true;
  
  resetAllGameState();
  await updateNavUserState(null);
  navigateTo('/signup');
}






async function updateNavUserState(session) {
  const navTitle = document.getElementById('nav-title');
  const navDropdown = document.getElementById('nav-dropdown');
  const navUsername = document.getElementById('nav-username');

  if (!navTitle || !navDropdown) return;

  // If no session provided, get current session
  if (!session) {
    const { data } = await supabase.auth.getSession();
    session = data.session;
  }

  const hasValidSession = session?.user && myUsername && myUserId;

  if (!hasValidSession) {
    // Not logged in - hide dropdown
    navTitle.style.display = 'inline-block';
    navDropdown.style.display = 'none';
  } else {
    // Logged in - show dropdown with username
    navTitle.style.display = 'inline-block';
    navDropdown.style.display = 'block';
    
    if (navUsername) {
      navUsername.textContent = myUsername || 'Menu';
    }
  }
}




async function resetPassword() {
  const emailInput = document.getElementById('reset-email');
  const email = emailInput.value.trim();

  if (!email) {
    alert('Please enter your email address.');
    return;
  }

  try {
    const { data, error } = await supabase.auth.resetPasswordForEmail(email, {
      redirectTo: `${window.location.origin}/update-password`
    });

    if (error) {
      console.error('[ERROR] Supabase reset error:', error.message);
      alert('Error sending reset email: ' + error.message);
      return;
    }

    console.log('[INFO] Password reset email sent:', data);
    navigateTo('/reset-confirmed'); // Switch to your "Check your email" screen!
  } catch (err) {
    console.error('[ERROR] Unexpected:', err);
    alert('An unexpected error occurred.');
  }
}

async function updatePassword() {
  const newPasswordInput = document.getElementById('new-password');
  const newPassword = newPasswordInput.value.trim();

  if (!newPassword) {
    alert('Please enter a new password.');
    return;
  }

  const { data, error } = await supabase.auth.updateUser({
    password: newPassword
  });

  if (error) {
    console.error('[ERROR] Failed to update password:', error.message);
    alert('Error updating password: ' + error.message);
    return;
  }

  console.log('[INFO] Password updated:', data);

  // ‚úÖ Redirect the user back to sign in, or show success
  alert('Password updated successfully! Please sign in with your new password.');
  navigateTo('/signup');
}





function setupAutocompleteListeners() {
  const guessInput = document.getElementById('guessInput');
  const submitGuessBtn = document.getElementById('submitGuessBtn');
  
  if (!guessInput || !submitGuessBtn) {
    console.warn('Autocomplete elements not found');
    return;
  }

  guessInput.addEventListener('input', function() {
    const val = this.value.trim();
    clearAutocomplete();
    selectedPlayer = null;
    submitGuessBtn.disabled = true;

    if (!val) {
      showAutocompleteSuggestions([]);
      return;
    }

    if (fetchTimeout) clearTimeout(fetchTimeout);

    fetchTimeout = setTimeout(async () => {
      try {
        const res = await fetch(`/players?q=${encodeURIComponent(val)}`);
        if (!res.ok) throw new Error('Network response not ok');

        const results = await res.json();
        if (results.length === 0) {
          showAutocompleteSuggestions([]);
          return;
        }

        const suggestions = results.map(player => {
          const wrapper = document.createElement('div');
          wrapper.className = 'autocomplete-item';

          const nameSpan = document.createElement('span');
          nameSpan.textContent = player.player_name;

          const yearsSpan = document.createElement('span');
          yearsSpan.className = 'career-years';
          yearsSpan.textContent = ` ${player.first_year || '?'}‚Äì${player.last_year || '?'}`;
          yearsSpan.style.fontSize = '0.8em';
          yearsSpan.style.color = 'gray';
          yearsSpan.style.marginLeft = '5px';

          wrapper.appendChild(nameSpan);
          wrapper.appendChild(yearsSpan);

          wrapper.addEventListener('click', () => {
            guessInput.value = player.player_name;
            selectedPlayer = player.player_name;
            submitGuessBtn.disabled = false;
            clearAutocomplete();
          });

          return wrapper;
        });

        showAutocompleteSuggestions(suggestions);

      } catch (err) {
        console.error('Autocomplete fetch error:', err);
        showAutocompleteSuggestions([]);
      }
    }, 300);
  });

  guessInput.addEventListener('change', () => {
    if (guessInput.value !== selectedPlayer) {
      selectedPlayer = null;
      submitGuessBtn.disabled = true;
    }
  });
}


function initializeAuthStateListener() {
  if (window.supabase && window.supabase.auth) {
    window.supabase.auth.onAuthStateChange((event, session) => {
      updateNavUserState(session);
    });
  }
}


async function loadPlayerStats() {
  const el = document.getElementById('player-history');
  if (!el) return;

  const { data: sessionData, error: sessionError } = await supabase.auth.getSession();
  if (sessionError || !sessionData?.session?.user) {
    el.textContent = 'Games Played: 0 | Wins: 0 | Losses: 0';
    return;
  }

  const userId = sessionData.session.user.id;

  // ‚úÖ First, try to get existing stats
  let { data, error } = await supabase
    .from('user_stats')
    .select('games_played, wins, losses')
    .eq('user_id', userId)
    .single();

  // ‚úÖ If no row exists, create one
  if (error && error.code === 'PGRST116') { // No rows returned
    console.log('[loadPlayerStats] Creating new stats row for user:', userId);
    
    const { data: newData, error: insertError } = await supabase
      .from('user_stats')
      .insert({ 
        user_id: userId, 
        games_played: 0, 
        wins: 0, 
        losses: 0 
      })
      .select('games_played, wins, losses')
      .single();

    if (insertError) {
      console.error('[loadPlayerStats] Failed to create stats row:', insertError);
      el.textContent = 'Games Played: 0 | Wins: 0 | Losses: 0';
      return;
    }
    
    data = newData;
  } else if (error) {
    console.error('[loadPlayerStats] Unexpected error:', error);
    el.textContent = 'Games Played: 0 | Wins: 0 | Losses: 0';
    return;
  }

  el.textContent = `Games Played: ${data.games_played || 0} | Wins: ${data.wins || 0} | Losses: ${data.losses || 0}`;
}


function setupGameTypeSelection() {
  console.log('[DEBUG] setupGameTypeSelection called');
  
  const privateGameBtn = document.getElementById('privateGameBtn');
  const findGameBtn = document.getElementById('findGameBtn');
  
  console.log('[DEBUG] privateGameBtn:', privateGameBtn);
  console.log('[DEBUG] findGameBtn:', findGameBtn);
  
  // Update step indicator
  function updateStepIndicator(step) {
    console.log('[DEBUG] updateStepIndicator called with step:', step);
    document.querySelectorAll('.step').forEach(s => s.classList.remove('active'));
    document.querySelector(`[data-step="${step}"]`)?.classList.add('active');
  }
  
  // Handle private game selection
  if (privateGameBtn) {
    // Remove any existing listeners first
    privateGameBtn.replaceWith(privateGameBtn.cloneNode(true));
    const newPrivateBtn = document.getElementById('privateGameBtn');
    
    newPrivateBtn.addEventListener('click', (e) => {
      e.preventDefault();
      console.log('[DEBUG] Private game button clicked');
      gameTypeSelected = 'private';
      showEraSelection();
      updateStepIndicator(2);
    });
    console.log('[DEBUG] Private game button listener attached');
  } else {
    console.error('[DEBUG] privateGameBtn not found!');
  }
  
  // Handle public game selection  
  if (findGameBtn) {
    // Remove any existing listeners first
    findGameBtn.replaceWith(findGameBtn.cloneNode(true));
    const newFindBtn = document.getElementById('findGameBtn');
    
    newFindBtn.addEventListener('click', (e) => {
      e.preventDefault();
      console.log('[DEBUG] Public game button clicked');
      gameTypeSelected = 'public';
      showEraSelection();
      updateStepIndicator(2);
    });
    console.log('[DEBUG] Public game button listener attached');
  } else {
    console.error('[DEBUG] findGameBtn not found!');
  }
}


function showEraSelection() {
    console.log('[DEBUG] showEraSelection called');
    
    const eraSelection = document.getElementById('eraSelection');
    const gameModeSelection = document.getElementById('gameModeSelection');
    
    if (eraSelection && gameModeSelection) {
        // Remove hidden class and add show class
        eraSelection.classList.remove('hidden');
        eraSelection.classList.add('show');  // ‚Üê ADD THIS LINE
        eraSelection.style.display = 'block';
        
        // Update step indicator
        updateStepIndicator(2);
        
        // Scroll to era selection
        setTimeout(() => {
            eraSelection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }, 100);
    }
}



function setupEraSelection() {
  console.log('[DEBUG] setupEraSelection called');
  
  const eraButtons = document.querySelectorAll('.era-btn');
  console.log('[DEBUG] Found era buttons:', eraButtons.length);
  
  eraButtons.forEach((button, index) => {
    console.log('[DEBUG] Setting up era button', index, button.getAttribute('data-era'));
    
    button.addEventListener('click', (e) => {
      e.preventDefault();
      
      const era = button.getAttribute('data-era');
      selectedEra = era;
      localStorage.setItem('selectedEra', era);
      
      console.log('[DEBUG] Era selected:', era, 'Game type:', gameTypeSelected);
      
      // Start the appropriate game type
      if (gameTypeSelected === 'private') {
        console.log('[DEBUG] Starting private game with era:', era);
        startPrivateGame();
      } else if (gameTypeSelected === 'public') {
        console.log('[DEBUG] Starting public game with era:', era);
        joinPublicGame();
      }
    });
  });
}





///////////////////////////////////////////////
// 3. Socket handlers (outside DOMContentLoaded)
function setupSocketHandlers() {
  socket.removeAllListeners();

socket.on('connect', () => {
  console.log('[safeEmit] Socket connected ‚Äî flushing emitQueue');

  if (myUserId && myUsername) {
    socket.emit('userSignedIn', { userId: myUserId, username: myUsername });
  }

  // ‚úÖ SAFE: Only auto-rejoin if game is actively in progress
  // This preserves rematch while preventing unwanted auto-starts
  if (myRoomId && !isLeavingGame && gameStarted && !gameOver && myUsername && myUserId) {
    console.log('[DEBUG] Reconnecting to active game after socket connect:', myRoomId);
    setTimeout(() => {
      safeEmit('joinGame', {
        roomId: myRoomId,
        username: myUsername,
        userId: myUserId,
        era: localStorage.getItem('selectedEra') || '2000-present'
      });
    }, 100);
  } else if (gameOver || !gameStarted) {
    // ‚úÖ Clear localStorage persistence but keep myRoomId for rematch
    console.log('[DEBUG] Game not active - clearing localStorage persistence');
    localStorage.removeItem('privateRoomId');
    // Note: myRoomId is preserved for rematch functionality
  }

  flushEmitQueue();
});




socket.on('disconnect', (reason) => {
  console.log('[DEBUG] Socket disconnected:', reason);
  
  // If this was an intentional sign-out, handle it immediately
  if (isLeavingGame || localStorage.getItem('isLeavingGame') === 'true') {
    resetAllGameState();
    if (gameStarted && !gameOver && myRoomId && myUsername) {
      socket.emit('playerSignedOut', { 
        roomId: myRoomId,
        username: myUsername,
        reason: 'signed_out'
      });
    }
  } else {
    // For accidental disconnects, give a grace period
    setTimeout(() => {
      if (!socket.connected) {
        // ‚úÖ FIXED: Replace the missing handlePlayerLeaving function
        if (gameStarted && !gameOver && myRoomId && myUsername) {
          socket.emit('playerSignedOut', { 
            roomId: myRoomId,
            username: myUsername,
            reason: 'disconnected'
          });
        }
      }
    }, 10000); // 10 second grace period
  }
});



socket.on('playersUpdate', (count) => {
  console.log('[DEBUG] playersUpdate received:', count);

  if (isLeavingGame) {
    console.log('[DEBUG] playersUpdate skipped: isLeavingGame is true');
    return;
  }

  const statusDiv = document.getElementById('status');
  const rematchBtn = document.getElementById('rematchBtn');

  if (statusDiv) {
    statusDiv.textContent = `Players in room: ${count}`;
  } else {
    console.warn('statusDiv not found in DOM');
  }

  if (rematchBtn) {
    if (count < 2) {
      rematchBtn.style.display = 'none';
      navigateTo('/waiting');
    } else {
      navigateTo('/play');
    }
  } else {
    console.warn('rematchBtn not found in DOM');
  }
});





socket.on('matched', ({ roomId, opponent }) => {
  if (isLeavingGame || localStorage.getItem('isLeavingGame') === 'true') {
    console.log('[DEBUG] Ignoring matched event because isLeavingGame is true');
    return;
  }

  if (gameStarted && !gameOver) return;

  // Clear stale flags
  isLeavingGame = false;
  localStorage.removeItem('isLeavingGame');

  myRoomId = roomId;
  opponentName = opponent;

  // Show matched screen with countdown
  showMatchedScreen(opponent);

  // // Include userId in joinGame
  // socket.emit('joinGame', { 
  //   roomId: myRoomId, 
  //   username: myUsername,
  //   userId: myUserId
  // });
});






// 2. Game Lifecycle
socket.on('gameStarted', async (data) => {
  if (isLeavingGame) {
    console.log('[DEBUG] Ignoring gameStarted because isLeavingGame === true');
    return;
  }

  console.log('[CLIENT] Received gameStarted event:', data);

   // Clear any countdown timers that might still be running
  const countdownEl = document.getElementById('countdownTimer');
  if (countdownEl) {
    // Clear any existing countdown intervals
  }

  resetCardSpread();

  gameStarted = true;
  gameOver = false;

  // Clear previous headshot storage for new game
  storedHeadshots.clear();

  const leadoffPlayer = data.leadoffPlayer || null;
  leadoffPlayerName = leadoffPlayer?.player_name || null;
  if (leadoffPlayerName) {
  showLeadoffCareerSection(leadoffPlayerName);
  }

  if (window.timerInterval) {
    clearInterval(window.timerInterval);
    window.timerInterval = null;
    console.warn('[CLIENT] Cleared leftover timer before starting new one.');
  }

  guessInput.disabled = true;
  submitGuessBtn.disabled = true;
  guessInput.value = '';
  clearGuessError();
  clearAutocomplete();

  rematchBtn.style.display = 'none';
  rematchBtn.disabled = false;
  rematchBtn.textContent = 'Rematch';

  messagesEl.innerHTML = '';
  messagesEl.style.display = 'block';

  // ‚úÖ Initialize successfulGuesses with leadoff player immediately
  successfulGuesses = [];
  if (leadoffPlayer && leadoffPlayer.player_name) {
    // Store leadoff headshot
    if (leadoffPlayer.headshot_url) {
      storedHeadshots.set(leadoffPlayer.player_name, leadoffPlayer.headshot_url);
    }
    
    const leadoffGuess = {
      guesser: 'Leadoff',
      name: leadoffPlayer.player_name,
      isLeadoff: true,
      headshot_url: leadoffPlayer.headshot_url || DEFAULT_PLAYER_IMAGE
    };
    
    successfulGuesses.push(leadoffGuess);
    
    // Store leadoff data globally for preservation
    window.leadoffPlayerData = {
      name: leadoffPlayer.player_name,
      headshot_url: leadoffPlayer.headshot_url || DEFAULT_PLAYER_IMAGE
    };
  }

  console.log('[CLIENT] successfulGuesses after reset:', successfulGuesses);
  renderSuccessfulGuesses();

  // ‚úÖ Update current player name (NBA player)
  currentPlayerNameEl.textContent = data.currentPlayerName || '???';

  // ‚úÖ Update current player headshot
  if (currentPlayerHeadshotEl) {
    currentPlayerHeadshotEl.src = data.currentPlayerHeadshotUrl || DEFAULT_PLAYER_IMAGE;
    currentPlayerHeadshotEl.alt = (data.currentPlayerName || 'Unknown') + ' Headshot';
  }

  // ‚úÖ Update player labels
  const playerYouEl = document.getElementById('playerYou');
  const playerOpponentEl = document.getElementById('playerOpponent');
  if (playerOpponentEl && data.opponentName) {
    playerOpponentEl.textContent = data.opponentName;
    opponentName = data.opponentName;
  }
  if (playerYouEl) playerYouEl.textContent = myUsername || 'You';

  // ‚úÖ Correct: use currentPlayerUsername, not currentPlayerName!
  const isYourTurn = data.currentPlayerUsername === myUsername;

  if (playerYouEl && playerOpponentEl) {
    playerYouEl.classList.toggle('active-turn', isYourTurn);
    playerOpponentEl.classList.toggle('active-turn', !isYourTurn);
  }

  timerEl.textContent = `:${data.timeLeft || 30}`;
  updateTimerStyle(data.timeLeft || 30);
  console.log('[CLIENT] Timer initialized at:', data.timeLeft || 15);

  console.log('[DEBUG] Navigating to /play...');
  await navigateTo('/play');
  console.debug('[DEBUG] Waiting for scoreboard readiness...');
  await waitForScoreboard();
  socket.emit('getMatchStats');
});





socket.on('matchStats', (stats) => {
  console.log('[CLIENT] Updated matchStats:', stats);
  updateSplitScoreboard(stats, myUsername, opponentName);
});



socket.on('gameOver', (data) => {
  console.log('[DEBUG] gameOver received:', data);

  // If I intentionally left, skip handling
  if (isLeavingGame) {
    console.debug('[DEBUG] Ignoring gameOver because isLeavingGame === true');
    isLeavingGame = false;
    return;
  }

  gameOver = true;
  localStorage.removeItem('privateRoomId');

  // Stop input & timer
  guessInput.disabled = true;
  submitGuessBtn.disabled = true;

  if (window.timerInterval) {
    clearInterval(window.timerInterval);
    window.timerInterval = null;
  }
  timerEl.textContent = ':--';

  // Ensure myUsername & opponentName
  if (!myUsername && data.winnerName && data.loserName) {
    if (data.role === 'winner') {
      myUsername = data.winnerName;
      opponentName = data.loserName;
    } else {
      myUsername = data.loserName;
      opponentName = data.winnerName;
    }
  } else if (!opponentName && data.winnerName && data.loserName) {
    opponentName = (myUsername === data.winnerName) ? data.loserName : data.winnerName;
  }

  // Show game over container
  const container = document.getElementById('gameOverContainer');
  container.style.display = 'flex';
  container.innerHTML = '';

  // Create the layout structure
  
  // 1. "Game Over" header
  const gameOverHeader = document.createElement('div');
  gameOverHeader.style.fontSize = '2rem';
  gameOverHeader.style.fontWeight = 'bold';
  gameOverHeader.style.textAlign = 'center';
  gameOverHeader.style.marginBottom = '1rem';
  gameOverHeader.textContent = 'Game Over';
  container.appendChild(gameOverHeader);

  // 2. Winner/Loser message
  const resultMessage = document.createElement('div');
  resultMessage.style.fontSize = '1.5rem';
  resultMessage.style.textAlign = 'center';
  resultMessage.style.marginBottom = '1rem';
  resultMessage.style.fontWeight = 'bold';

  if (data.role === 'winner') {
    if (data.reason === 'opponent_left' || data.reason === 'opponent_signed_out') {
      resultMessage.textContent = 'You won!';
    } else {
      resultMessage.textContent = 'You won!';
    }
    resultMessage.style.color = 'green';
  } else if (data.role === 'loser') {
    if (data.reason === 'timer_expired') {
      resultMessage.textContent = 'You ran out of time.';
    } else {
      resultMessage.textContent = 'You lost.';
    }
    resultMessage.style.color = 'darkred';
  } else if (data.reason === 'opponent_left') {
    resultMessage.textContent = 'Your opponent left the game.';
    resultMessage.style.color = 'gray';
  } else {
    resultMessage.textContent = 'Game ended.';
    resultMessage.style.color = 'gray';
  }

  container.appendChild(resultMessage);

  // 3. Turn count display
  if (data.turnCount !== undefined && data.turnCount > 0) {
    const turnDisplay = document.createElement('div');
    turnDisplay.style.fontSize = '1.2rem';
    turnDisplay.style.textAlign = 'center';
    turnDisplay.style.marginBottom = '1.5rem';
    turnDisplay.style.fontWeight = 'bold';
    turnDisplay.textContent = `Turns: ${data.turnCount}`;
    container.appendChild(turnDisplay);
  }

  // ‚úÖ ADD OPPONENT LEFT MESSAGE IN GAME OVER SCREEN TOO
  if (data.reason === 'opponent_left' || data.reason === 'opponent_signed_out') {
    const opponentLeftMsg = document.createElement('div');
    opponentLeftMsg.style.cssText = `
      // background: #ffebee;
      // border: 2px solid #f44336;
      // border-radius: 8px;
      padding: 1rem;
      margin: 1rem 0;
      text-align: center;
      font-weight: bold;
      color: #475569;
    `;
    opponentLeftMsg.innerHTML = `
      <div>Opponent left the game</div>
    `;
    container.appendChild(opponentLeftMsg);
  }

  // Handle rematch button visibility
  if (data.canRematch === false || data.reason === 'opponent_left' || data.reason === 'opponent_signed_out') {
    rematchBtn.style.display = 'none';
  } else {
    rematchBtn.style.display = 'block';
    rematchBtn.disabled = false;
    rematchBtn.textContent = 'Rematch';
  }

  // Navigate and trigger card spread
  navigateTo('/gameover');
  triggerGameEndCardSpread();
});





// 3. Turn Management
socket.on('yourTurn', (data) => {
  navigateTo('/play');

  const turnSection = document.getElementById('turnSection');
  turnSection.classList.add('your-turn');
  turnSection.classList.remove('opponent-turn');
  turnSection.style.display = 'block';

  // Show guess controls
  document.getElementById('guessControls').style.display = 'block';
  guessInput.disabled = false;
  submitGuessBtn.disabled = !guessInput.value.trim();

  // Update player name safely
  if (currentPlayerNameEl) {
    currentPlayerNameEl.textContent = data.currentPlayerName || 'Your Turn';
  }

  // Update headshot safely
  if (currentPlayerHeadshotEl) {
    currentPlayerHeadshotEl.src = data.currentPlayerHeadshotUrl || DEFAULT_PLAYER_IMAGE;
    currentPlayerHeadshotEl.alt = `${data.currentPlayerName || 'Player'} Headshot`;
  }

  // Store headshot
  if (data.currentPlayerName && data.currentPlayerHeadshotUrl) {
    storedHeadshots.set(data.currentPlayerName, data.currentPlayerHeadshotUrl);
  }

  // Update prompt header text if needed
  const promptHeader = turnSection.querySelector('.prompt-header');
  if (promptHeader) {
    promptHeader.textContent = 'Name any teammate of:';
  }

  // Timer
  timerEl.textContent = `:${data.timeLeft || 30}`;
  updateTimerStyle(data.timeLeft || 30);

  // Messages
  messagesEl.style.display = 'block';
  showMessage(data.message || "It's your turn to guess!", 'info');

  // Skip button
  const skipLink = document.getElementById('skipTurnBtn');
if (skipLink) {
  skipLink.classList.remove('hidden'); // ‚úÖ Remove hidden class
  skipLink.style.display = 'inline-block';
  skipLink.classList.toggle('disabled', !data.canSkip);
  skipLink.textContent = data.canSkip ? 'Skip Turn' : 'Skip Used';
}

  // Highlight current player
  const playerYouEl = document.getElementById('playerYou');
  const playerOpponentEl = document.getElementById('playerOpponent');
  if (playerYouEl && playerOpponentEl) {
    playerYouEl.classList.add('active-turn');
    playerOpponentEl.classList.remove('active-turn');
  }

  setTimeout(() => scrollToGameArea(), 200);
});



socket.on('opponentTurn', (data) => {
  navigateTo('/play');

  const turnSection = document.getElementById('turnSection');
  turnSection.classList.remove('your-turn');
  turnSection.classList.add('opponent-turn');
  turnSection.style.display = 'block';

  // Hide guess controls
  document.getElementById('guessControls').style.display = 'none';
  guessInput.disabled = true;
  submitGuessBtn.disabled = true;

  // Update player name safely
  if (currentPlayerNameEl) {
    currentPlayerNameEl.textContent = data.currentPlayerName || "Opponent's Turn";
  }

  // Update headshot safely
  if (currentPlayerHeadshotEl) {
    currentPlayerHeadshotEl.src = data.currentPlayerHeadshotUrl || DEFAULT_PLAYER_IMAGE;
    currentPlayerHeadshotEl.alt = `${data.currentPlayerName || 'Player'} Headshot`;
  }

  // Store headshot
  if (data.currentPlayerName && data.currentPlayerHeadshotUrl) {
    storedHeadshots.set(data.currentPlayerName, data.currentPlayerHeadshotUrl);
  }

  // Update prompt header text
  const promptHeader = turnSection.querySelector('.prompt-header');
  if (promptHeader) {
    promptHeader.textContent = `${opponentName || 'Your opponent'} is naming a teammate of:`;
  }

  // Timer
  timerEl.textContent = data.timeLeft || '';
  if (data.timeLeft) updateTimerStyle(data.timeLeft);

  // Messages
  messagesEl.style.display = 'block';
  showMessage(data.message || "Waiting for your opponent to guess...", 'info');

  // Skip button hidden during opponent turn
  const skipLink = document.getElementById('skipTurnBtn');
if (skipLink) {
  skipLink.classList.add('hidden'); // ‚úÖ Add hidden class back
  skipLink.style.display = 'none';
}

  // Highlight opponent
  const playerYouEl = document.getElementById('playerYou');
  const playerOpponentEl = document.getElementById('playerOpponent');
  if (playerYouEl && playerOpponentEl) {
    playerYouEl.classList.remove('active-turn');
    playerOpponentEl.classList.add('active-turn');
  }

  setTimeout(() => scrollToGameArea(), 200);
});


// Add skip event handlers in the socket setup section
socket.on('turnSkipped', (data) => {
    // Show toast notification
    if (data.skippedBy === socket.id) {
        showSkipToast('You skipped your turn. Sending to opponent');
    } else {
        showSkipToast(`${data.skippedByUsername} skipped their turn - it's your turn now`);
    }
    
    const skippedPlayerName = data.skippedBy === socket.id ? 'You' : data.skippedByUsername;
    
    // Update UI to show skip occurred
    showMessage(`${skippedPlayerName} skipped the turn. Base player remains: ${data.currentPlayerName}`, 'info');
    
    // Hide guess controls
    document.getElementById('guessControls').style.display = 'none';
    
    // Update turn prompt
    if (data.newActivePlayer === socket.id) {
        document.getElementById('turnPrompt').textContent = `Your turn! Find a teammate of ${data.currentPlayerName}`;
    } else {
        document.getElementById('turnPrompt').textContent = `Opponent's turn to find a teammate of ${data.currentPlayerName}`;
    }
});


socket.on('skipError', (message) => {
    alert(message);
});

socket.on('opponentIncorrectGuess', (data) => {
  // Show a subtle notification that opponent made an incorrect guess
  showOpponentIncorrectGuess(data.guesserName, data.incorrectGuess, data.currentPlayerName);
});


socket.on('message', (msg) => {
  navigateTo('/play'); // Ensure user is on the gameplay page
  showMessage(msg, 'error');
});

socket.on('turnEnded', (data) => {
  console.log('turnEnded currentPlayerHeadshotUrl:', data.currentPlayerHeadshotUrl);
  
  // ‚úÖ CRITICAL: Store the NEW current player's headshot FIRST
  // This is the player who was just guessed and will be on the new card
  if (data.currentPlayerName && data.currentPlayerHeadshotUrl) {
    storedHeadshots.set(data.currentPlayerName, data.currentPlayerHeadshotUrl);
    console.log('Storing NEW current player headshot BEFORE processing:', data.currentPlayerName, data.currentPlayerHeadshotUrl);
  }
  
  navigateTo('/play');

  if (Array.isArray(data.successfulGuesses)) {
    // Now the headshot will be available for the newly added card
    successfulGuesses = data.successfulGuesses.map(guess => {
      const storedHeadshot = storedHeadshots.get(guess.name);
      const updatedGuess = {
        ...guess,
        headshot_url: storedHeadshot || guess.headshot_url || DEFAULT_PLAYER_IMAGE
      };
      
      if (guess.name === leadoffPlayerName || guess.isLeadoff) {
        updatedGuess.isLeadoff = true;
        if (guess.name === leadoffPlayerName && window.leadoffPlayerData) {
          updatedGuess.headshot_url = storedHeadshots.get(guess.name) || window.leadoffPlayerData.headshot_url || DEFAULT_PLAYER_IMAGE;
        }
      }
      
      console.log(`Final headshot for ${guess.name}:`, updatedGuess.headshot_url);
      return updatedGuess;
    });
    
    successfulGuesses = markLeadoffInGuesses(successfulGuesses, leadoffPlayerName);
    renderSuccessfulGuesses();
  }

  if (data.message) {
    showMessage(data.message, data.message.startsWith('Incorrect guess') ? 'error' : 'info');
  }

   hideLeadoffCareer();

  // ‚úÖ Save turn state for next turn rendering
  currentPlayerName = data.currentPlayerName || '???';
  currentPlayerHeadshotUrl = data.currentPlayerHeadshotUrl || DEFAULT_PLAYER_IMAGE;
  timeLeft = data.timeLeft || 15;

  renderPlayScreen();

  setTimeout(() => {
    scrollToGameArea();
  }, 300); // Small delay to let DOM updates complete
});





function renderPlayScreen() {
  if (currentPlayerNameEl) {
    currentPlayerNameEl.textContent = currentPlayerName;
  }
  if (currentPlayerHeadshotEl) {
    currentPlayerHeadshotEl.src = currentPlayerHeadshotUrl;
    currentPlayerHeadshotEl.alt = `${currentPlayerName} Headshot`;
  }
  if (timerEl) {
  timerEl.textContent = `:${timeLeft}`;
  updateTimerStyle(timeLeft);
}
}





socket.on('timerTick', (data) => {
  timerEl.textContent = `:${data.timeLeft}`;
  updateTimerStyle(data.timeLeft);
});




// Simplified rematch request notification
socket.on('rematchRequested', ({ username }) => {
  console.log('[DEBUG] Rematch requested by:', username);
  
  // Clear any existing rematch messages
  const existingRematchMsg = document.getElementById('rematch-notification');
  if (existingRematchMsg) {
    existingRematchMsg.remove();
  }

  // Create simplified notification
  const rematchNotification = document.createElement('div');
  rematchNotification.id = 'rematch-notification';
  rematchNotification.style.cssText = `
    background: #e3f2fd;
    border: 2px solid #2196f3;
    border-radius: 8px;
    padding: 1rem;
    margin: 1rem 0;
    text-align: center;
    font-weight: bold;
    color: #1976d2;
    animation: pulse 2s infinite;
  `;

  rematchNotification.innerHTML = `
    <div>Rematch requested</div>
  `;

  // Add pulsing animation if not already added
  if (!document.getElementById('pulse-animation-style')) {
    const style = document.createElement('style');
    style.id = 'pulse-animation-style';
    style.textContent = `
      @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.02); }
        100% { transform: scale(1); }
      }
    `;
    document.head.appendChild(style);
  }

  // Insert notification in the game over container
  const gameOverContainer = document.getElementById('gameOverContainer');
  if (gameOverContainer) {
    gameOverContainer.appendChild(rematchNotification);
    console.log('[DEBUG] Rematch notification added to game over container');
  } else {
    console.warn('[DEBUG] Game over container not found');
  }

  // Update rematch button style to indicate pending request
  const rematchBtn = document.getElementById('rematchBtn');
  if (rematchBtn) {
    rematchBtn.style.backgroundColor = '#4caf50';
    rematchBtn.style.transform = 'scale(1.05)';
    rematchBtn.style.boxShadow = '0 4px 8px rgba(76, 175, 80, 0.3)';
    console.log('[DEBUG] Rematch button style updated');
  }
});




// When rematch actually starts
socket.on('rematchStarted', () => {
  resetGameUI();

  // Clear ALL rematch-related notifications
  const notifications = document.querySelectorAll('#rematch-notification, #opponent-left-notification');
  notifications.forEach(el => el.remove());

  // Reset rematch button styles
  rematchBtn.disabled = false;
  rematchBtn.style.backgroundColor = '';
  rematchBtn.style.transform = '';
  rematchBtn.style.boxShadow = '';
  rematchBtn.textContent = 'Rematch';

  // Re-join the same room to trigger new game start
  if (myRoomId && myUsername) {
    console.log('[CLIENT] Rejoining room for rematch:', myRoomId);
    socket.emit('joinGame', {
  roomId: myRoomId,
  username: myUsername,
  userId: myUserId,
  era: selectedEra || localStorage.getItem('selectedEra') || '2000-present'
});
    socket.emit('getMatchStats');
  } else {
    console.error('[CLIENT] Missing roomId or username for rematch.');
  }
});


// Handle opponent leaving the room - WORKS ON ALL SCREENS
socket.on('opponentLeft', ({ message }) => {
  console.log('[DEBUG] opponentLeft event received:', message);
  
  // Clear any existing notifications
  const existingNotifications = document.querySelectorAll('#rematch-notification, #opponent-left-notification');
  existingNotifications.forEach(el => el.remove());

  // Create opponent left notification
  // const leftNotification = document.createElement('div');
  // leftNotification.id = 'opponent-left-notification';
  // leftNotification.style.cssText = `
  //   position: fixed;
  //   top: 20px;
  //   left: 50%;
  //   transform: translateX(-50%);
  //   background: #ffebee;
  //   border: 2px solid #f44336;
  //   border-radius: 8px;
  //   padding: 1rem 2rem;
  //   text-align: center;
  //   font-weight: bold;
  //   color: #c62828;
  //   z-index: 10000;
  //   box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  //   animation: slideDown 0.3s ease-out;
  // `;

  // leftNotification.innerHTML = `
  //   <div style="font-size: 1.2rem; margin-bottom: 0.5rem;">üëã Player Left</div>
  //   <div>Your opponent left the game</div>
  //   <div style="margin-top: 0.5rem; font-size: 0.9rem;">
  //     Rematch is no longer available
  //   </div>
  // `;

  if (!document.getElementById('slide-down-animation-style')) {
    const style = document.createElement('style');
    style.id = 'slide-down-animation-style';
    style.textContent = `
      @keyframes slideDown {
        from { 
          opacity: 0; 
          transform: translateX(-50%) translateY(-20px); 
        }
        to { 
          opacity: 1; 
          transform: translateX(-50%) translateY(0); 
        }
      }
    `;
    document.head.appendChild(style);
  }

  // ‚úÖ CRITICAL: Add to document body so it appears on ANY screen
  document.body.appendChild(leftNotification);
  console.log('[DEBUG] Opponent left notification added to body (visible on all screens)');

  // Hide and disable rematch button if it exists
  const rematchBtn = document.getElementById('rematchBtn');
  if (rematchBtn) {
    rematchBtn.style.display = 'none';
    console.log('[DEBUG] Rematch button hidden due to opponent leaving');
  }

  // Auto-remove notification after 5 seconds
  setTimeout(() => {
    if (leftNotification.parentNode) {
      leftNotification.remove();
      console.log('[DEBUG] Opponent left notification auto-removed');
    }
  }, 5000);
});






  }




// 4. DOMContentLoaded (minimal, focused)
document.addEventListener('DOMContentLoaded', async () => {
  console.log('[DEBUG] DOMContentLoaded');

  selectedEra = localStorage.getItem('selectedEra') || '2000-present';
  gameTypeSelected = false;

  // ‚úÖ INITIALIZE SOCKET FIRST - Before any routing logic
  console.log('[DOMContentLoaded] Initializing socket connection...');
  socket = io();
  setupSocketHandlers();

  let justConfirmed = false;

  // Initialize all event listeners
  setupAutocompleteListeners();
  setupFormListeners();
  setupAuthTabs();
  initializeAuthStateListener();
  updateNavUserState();
  setupNavDropdown();

  // Cache DOM element references
  statusDiv = document.getElementById('status');
  guessInput = document.getElementById('guessInput');
  submitGuessBtn = document.getElementById('submitGuessBtn');
  rematchBtn = document.getElementById('rematchBtn');
  messagesEl = document.getElementById('messageContainer');
  currentPlayerNameEl = document.getElementById('currentPlayerName');
  currentPlayerHeadshotEl = document.getElementById('currentPlayerHeadshot');
  timerEl = document.getElementById('timer');
  autocompleteList = document.getElementById('autocomplete-list');
  waitingRoom = document.getElementById('waitingRoom');
  gameArea = document.getElementById('gameArea');
  inviteLinkContainer = document.getElementById('inviteLinkContainer');

  const skipTurnLink = document.getElementById('skipTurnBtn');
if (skipTurnLink) {
  skipTurnLink.addEventListener('click', (e) => {
    e.preventDefault();
    if (!skipTurnLink.classList.contains('disabled')) {
      if (confirm('Are you sure you want to skip your turn? You can only skip once per game.')) {
        socket.emit('playerSkip');
      }
    }
  });
}
  
  // Set initial default image
  if (currentPlayerHeadshotEl) {
    currentPlayerHeadshotEl.src = DEFAULT_PLAYER_IMAGE;
  }

  supabase.auth.onAuthStateChange((_event, session) => {
    updateNavUserState(session);
  });

  const urlHash = window.location.hash;
  const searchParams = new URLSearchParams(window.location.search);
  const typeParam = searchParams.get('type');

  console.log('[DEBUG] On load: urlHash:', urlHash, 'typeParam:', typeParam);

  // Handle password recovery separately
  if (
    (urlHash.includes('access_token') && urlHash.includes('type=recovery'))
    || (typeParam === 'recovery')
  ) {
    console.log('[DEBUG] Found password recovery in URL');
    try {
      const { data: { user }, error } = await supabase.auth.getUser();
      if (error) {
        console.error('[ERROR] Password recovery failed:', error.message);
        navigateTo('/signup');
      } else {
        console.log('[DEBUG] Password recovery successful for:', user?.email);
        // Go directly to update password page
        await navigateTo('/update-password');
      }
    } catch (e) {
      console.error('[ERROR] Exception during password recovery:', e);
      navigateTo('/signup');
    }
    return;
  }

  // Handle email confirmation (signup/email_confirm only)
  if (
    (urlHash.includes('access_token') &&
      (urlHash.includes('type=signup') || urlHash.includes('type=email_confirm')))
    || (typeParam === 'signup' || typeParam === 'email_confirm')
  ) {
    console.log('[DEBUG] Found email confirmation in URL');
    try {
      const { data: { user }, error } = await supabase.auth.getUser();
      if (error) {
        console.error('[ERROR] Email confirmation failed:', error.message);
      } else {
        console.log('[DEBUG] Email confirmed for:', user?.email);

        myUsername = user.user_metadata?.username || user.email;
        myUserId = user.id;
        localStorage.setItem('username', myUsername);
        localStorage.setItem('userId', myUserId);

        const { data: { session } } = await supabase.auth.getSession();

        await navigateTo('/confirmed');
        await updateNavUserState(session);
      }
    } catch (e) {
      console.error('[ERROR] Exception during email confirmation:', e);
    }
    return;
  }

  // --- 3Ô∏è‚É£ Validate session state FIRST ---
console.log('[DEBUG] Starting session validation...');

// ‚úÖ FIRST: Check for room invite in URL and preserve it
const params = new URLSearchParams(window.location.search);
const roomFromUrl = params.get('room');

if (roomFromUrl) {
  console.log('[DEBUG] Found room invite in URL:', roomFromUrl);
  localStorage.setItem('pendingRoomInvite', roomFromUrl);
}

try {
  const { data: { session }, error } = await supabase.auth.getSession();
  
  if (error) {
    console.error('[DEBUG] Session error:', error);
    await forceSignOut();
    return;
  }
  
  if (!session || !session.user) {
    console.log('[DEBUG] No valid session found');
    localStorage.removeItem('username');
    localStorage.removeItem('userId');
    localStorage.removeItem('privateRoomId');
    localStorage.removeItem('isLeavingGame');
    
    myUsername = null;
    myUserId = null;
    
    await updateNavUserState(null);
    navigateTo('/signup');
    return;
  }
  
  // Valid session exists - set up user data
  const user = session.user;
  myUsername = user.user_metadata?.username || user.email;
  myUserId = user.id;
  
  localStorage.setItem('username', myUsername);
  localStorage.setItem('userId', myUserId);

  if (!localStorage.getItem('selectedEra')) {
    localStorage.setItem('selectedEra', selectedEra);
  }
  
  console.log('[DEBUG] Valid session confirmed:', {
    myUsername,
    myUserId,
    email: user.email,
    selectedEra: selectedEra
  });
  
  await updateNavUserState(session);
  
  // ‚úÖ Handle room invites with proper state management
  const pendingRoomInvite = localStorage.getItem('pendingRoomInvite');
  const currentRoomInvite = roomFromUrl;
  const targetRoom = pendingRoomInvite || currentRoomInvite;
  
 if (targetRoom) {
  console.log('[DEBUG] Processing room invite:', targetRoom);
  
  // Clear pending invite
  localStorage.removeItem('pendingRoomInvite');
  
  // ‚úÖ ONLY set up room state if we're not in a game over state
  if (!gameOver) {
    // Set up room state BEFORE navigation
    myRoomId = targetRoom;
    roomId = targetRoom;
    isPrivateGame = true;
    isLeavingGame = false;
    
    localStorage.setItem('privateRoomId', targetRoom);
    localStorage.removeItem('isLeavingGame');
    
    // Navigate and join
    await navigateTo('/waiting');
    setTimeout(() => {
      safeEmit('joinGame', {
       roomId: targetRoom,
       username: myUsername,
       userId: myUserId,
       era: selectedEra || localStorage.getItem('selectedEra') || '2000-present'
     })
    }, 100);
    
    return;
  } else {
    console.log('[DEBUG] Ignoring room invite - game is over');
  }
}
  
  // No room invite, go to home
  navigateTo('/home');
  
} catch (error) {
  console.error('[DEBUG] Session validation failed:', error);
  await forceSignOut();
}

  // Event listeners for page lifecycle
  window.addEventListener('popstate', () => {
    navigateTo(window.location.pathname, { skipPush: true });
  });

  window.addEventListener('beforeunload', (e) => {
  // ‚úÖ COVERS: Tab close, browser close, page refresh, navigation away
  if ((gameStarted && !gameOver) || myRoomId) {
    console.log('[DEBUG] Page unloading during active game - notifying opponent');
    
    if (socket && socket.connected) {
      // Use playerSignedOut for immediate notification
      socket.emit('playerSignedOut', {
        roomId: myRoomId || roomId,
        username: myUsername,
        userId: myUserId,
        reason: 'page_closed'
      });
    }
  }
});

});


</script>


















</body>
</html>