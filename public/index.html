<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>NBA Teammate Game</title>
  <script src="https://cdn.socket.io/4.6.1/socket.io.min.js" crossorigin="anonymous"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

 <style>
  body {
    font-family: Arial, sans-serif;
    max-width: 600px;
    margin: auto;
    padding: 1rem;
    line-height: 1.5;
    background-color: #f9f9f9;
    color: #222;
  }

  h1, h2, h3 {
    text-align: center;
    margin-bottom: 1rem;
  }

  input[type="text"] {
    width: 100%;
    padding: 0.5rem;
    font-size: 1rem;
    margin-top: 0.25rem;
    box-sizing: border-box;
  }

  button {
    padding: 0.5rem 1rem;
    font-size: 1rem;
    margin-top: 0.5rem;
    cursor: pointer;
  }

  #status {
    text-align: center;
    margin-top: 1rem;
    font-style: italic;
    color: #555;
  }

  #waitingRoom {
    text-align: center;
    margin-top: 2rem;
  }

  #displayRoomCode {
    font-size: 1.5rem;
    font-weight: bold;
    display: inline-block;
    margin-top: 0.5rem;
  }

  #gameArea {
    margin-top: 2rem;
    position: relative;
  }

  @keyframes pulse-border {
  0% {
    box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.5);
  }
  70% {
    box-shadow: 0 0 0 10px rgba(40, 167, 69, 0);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(40, 167, 69, 0);
  }
}

  #turnSection {
    margin-bottom: 1.5rem;
  }

  #turnSection.your-turn {
  border: 3px solid #28a745;
  background-color: #e8f5e9;
  padding: 1rem;
  border-radius: 8px;
  box-shadow: 0 0 12px rgba(40, 167, 69, 0.3);
  transition: all 0.3s ease;
  animation: pulse-border 1.5s infinite;
}

#turnSection.opponent-turn {
  opacity: 0.6;
}


  #timer {
    font-size: 2rem;
    font-weight: bold;
    text-align: center;
    color: #333;
    margin: 1rem 0;
  }

  #guessControls {
  display: flex;
  gap: 0.75rem; /* a bit more gap */
  margin-bottom: 1rem;
  align-items: center; /* vertical center */
  justify-content: center; /* center horizontally */
}

 #guessControls input {
  flex: 1 1 auto;
  min-width: 0; /* helps prevent overflow */
  padding: 0.75rem 1rem; /* more padding for easier touch */
  font-size: 1.1rem;
  border-radius: 4px;
  border: 1px solid #ccc;
  box-sizing: border-box;
}

#submitGuessBtn {
  padding: 0.85rem 1.75rem;
  font-size: 1.1rem;
  min-width: 130px;
  min-height: 56px; /* ‚Üê Ensures at least 56px tall */
  border-radius: 6px;
  cursor: pointer;
  background-color: #007bff;
  color: white;
  border: none;
  transition: background-color 0.25s ease;
}

#submitGuessBtn:disabled {
  background-color: #aaa;
  cursor: not-allowed;
}

#submitGuessBtn:hover:not(:disabled) {
  background-color: #0056b3;
}

#autocomplete-list {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  z-index: 9999;
  background-color: white;
  border: 1px solid #ccc;
  max-height: 200px;
  overflow-y: auto;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
}

.autocomplete-item {
  display: flex;
  justify-content: space-between;
  padding: 6px 10px;
  cursor: pointer;
}

.autocomplete-item:hover {
  background-color: #f0f0f0;
}

.career-years {
  font-size: 0.8em;
  color: gray;
}



  #autocomplete-list div {
    padding: 0.5rem;
    cursor: pointer;
  }

  #autocomplete-list div:hover {
    background: #f0f0f0;
  }

  #successful-guesses-container {
    margin-top: 1rem;
    text-align: center;
  }

  #successful-guesses-list {
    list-style: none;
    padding-left: 0;
    margin-top: 0.5rem;
    text-align: center;
  }

  #successful-guesses-list li {
    margin: 0.5rem 0;
  }

  .hidden {
    display: none !important;
  }

  /* Unified message styling */
  .message {
    margin-top: 0.5rem;
    font-size: 1rem;
    text-align: center;
    color: #333;
    transition: opacity 1s ease;
    opacity: 1;
  }

  .message.error {
    color: red;
    font-weight: bold;
  }

  .message.fade-out {
    opacity: 0;
  }

 .turn-prompt {
  font-size: 1.3rem;
  color: #222;
  margin-bottom: 1rem;
  text-align: center;
  line-height: 1.6;
}

.turn-prompt .turn-player-name {
  display: block;
  font-size: 1.6rem;
  margin-top: 0.5rem;
  color: #007bff;
}

#playersDisplay {
  text-align: center;
  margin-top: 1rem;
  font-size: 1.3rem;
  font-weight: bold;
  color: #222;
}

.player-name {
  padding: 0 0.5rem;
}

.player-name.you {
  color: #28a745; /* green */
}

.player-name.opponent {
  color: #007bff; /* blue */
}

.vs-separator {
  color: #555;
  padding: 0 0.5rem;
}



  #gameOverContainer {
    display: none;
    text-align: center;
    margin-top: 2rem;
  }

  #rematchBtn {
  display: block; /* ‚Üê Change this from "none" or "inline-block" to block */
  margin: 1.5rem auto 0; /* auto left/right centers it */
  padding: 0.5rem 1.5rem;
  font-weight: bold;
  border: none;
  border-radius: 4px;
  background-color: #007bff;
  color: white;
  transition: background-color 0.3s ease;
}


  #rematchBtn:hover {
    background-color: #0056b3;
  }

@media (max-width: 480px) {
  #guessControls {
    flex-direction: column;
    gap: 0.6rem;
  }

  #guessControls input, 
  #submitGuessBtn {
    width: 100%;
    min-width: auto;
  }

  #submitGuessBtn {
    font-size: 1.2rem;
    padding: 1rem;          /* visually balances a bigger tap target */
    min-height: 56px;       /* reaffirm minimum height */
  }
}
</style>


</head>
<body>
<h1>NBA Teammate Game</h1>

<!-- Step 1: Username Entry -->
<section id="usernameSection" data-route="/username" style="text-align: center; margin-top: 2rem;">
  <h2>Enter Your Username</h2>
  <input type="text" id="usernameInput" placeholder="Choose a username" />
  <button id="submitUsernameBtn">Continue</button>
</section>

<!-- Step 2: Game Mode Selection -->
<section id="modeSelection" data-route="/mode" class="hidden" style="text-align: center; margin-top: 2rem;">
  <h2>Choose Your Game Mode</h2>
  <button id="privateGameBtn">üîí Start Private Game</button>
  <button id="findGameBtn">üåê Join Public Game</button>
  <br>
  <button id="changeUsernameBtn" style="margin-top: 1rem;">Change Username</button>
</section>

<!-- Invite link container (used only in private games) -->
<section id="inviteLinkContainer" data-route="/invite" class="hidden" style="text-align: center; margin-top: 1rem;"></section>

<!-- Status message -->
<section id="status" data-route="/status" style="text-align: center; margin-top: 1rem;"></section>

<!-- Waiting Room View -->
<section id="waitingRoom" data-route="/waiting" class="hidden" style="text-align: center; margin-top: 2rem;">
  <h2>Waiting Room</h2>
  <p>Waiting for another player to join...</p>
  <code id="displayRoomCode" style="font-size: 1.5rem; font-weight: bold;"></code>
</section>

<!-- In-Game UI -->
<section id="gameArea" data-route="/play" class="hidden" style="position: relative;">
 <div id="playersDisplay">
  <span class="player-name you" id="playerYou">You</span>
  <span class="vs-separator">vs</span>
  <span class="player-name opponent" id="playerOpponent">Opponent</span>
</div>

  <div id="turnSection">
  <p class="turn-prompt" id="turnPromptText">
  üéØ Name any teammate of:<br>
  <strong class="turn-player-name" id="currentPlayerName">LeBron James</strong>
</p>


   <p>Time left: <span id="timer">15</span> seconds</p>
    <div id="guessControls" style="position: relative;">
      <input
        type="text"
        id="guessInput"
        placeholder="Type a teammate's name..."
        autocomplete="off"
      />
      <button id="submitGuessBtn" disabled>Submit Guess</button>
      <div id="autocomplete-list"></div>
    </div>
  </div>

  <div id="messageContainer"></div>

  <div id="successful-guesses-container" style="margin-top: 2px;">
    <h3>Turn History</h3>
    <ul id="successful-guesses-list"></ul>
  </div>
</section>


<!-- Game Over UI -->
<section data-route="/gameover" class="hidden" style="text-align: center; margin-top: 2rem;">
  <div id="gameOverContainer" style="display: flex; justify-content: center; align-items: center;">
    <!-- Game over message will be dynamically added here -->
  </div>
  <button id="rematchBtn" style="margin-top: 1rem;">Request Rematch</button>
</section>



<script>
 document.addEventListener('DOMContentLoaded', () => {
    const socket = io();

    // Core state
    let roomId = null;
    let myRoomId = null;
    let selectedPlayer = null;
    let fetchTimeout = null;
    let gameStarted = false;
    let gameOver = false;
    let leadoffPlayerName = null;
    let myUsername = null;
    let opponentName = null;
    let successfulGuesses = [];

    // Elements
    const usernameSection = document.getElementById('usernameSection');
    const usernameInput = document.getElementById('usernameInput');
    const submitUsernameBtn = document.getElementById('submitUsernameBtn');
    const changeUsernameBtn = document.getElementById('changeUsernameBtn');

    const modeSelection = document.getElementById('modeSelection');
    const privateGameBtn = document.getElementById('privateGameBtn');
    const findGameBtn = document.getElementById('findGameBtn');
    const inviteLinkContainer = document.getElementById('inviteLinkContainer');
    const statusDiv = document.getElementById('status');
    const waitingRoom = document.getElementById('waitingRoom');
    const gameArea = document.getElementById('gameArea');
    const currentPlayerNameEl = document.getElementById('currentPlayerName');
    const timerEl = document.getElementById('timer');
    const guessInput = document.getElementById('guessInput');
    const submitGuessBtn = document.getElementById('submitGuessBtn');
    const messagesEl = document.getElementById('messageContainer');
    const autocompleteList = document.getElementById('autocomplete-list');
    const rematchBtn = document.getElementById('rematchBtn');

    // Join private game from shared invite link
    const urlParams = new URLSearchParams(window.location.search);
    const sharedRoom = urlParams.get('room');
    if (sharedRoom) {
      myRoomId = sharedRoom;
      roomId = sharedRoom;

      const joinAfterUsername = () => {
        const stored = localStorage.getItem('username');
        if (!stored) {
          usernameSection.style.display = 'block';
          return setTimeout(joinAfterUsername, 100);
        }

        myUsername = stored;
        navigateTo('/waiting');
        socket.emit('joinGame', { roomId: sharedRoom, username: myUsername });

        statusDiv.textContent = `Joined private room: ${sharedRoom}`;
        waitingRoom.style.display = 'block';

        inviteLinkContainer.classList.remove('hidden');
        document.getElementById('displayRoomCode').textContent = sharedRoom;
        inviteLinkContainer.innerHTML = `
          Share this link to invite a friend:<br>
          <a href="${window.location.origin}?room=${sharedRoom}" target="_blank">
            ${window.location.origin}?room=${sharedRoom}
          </a>
        `;
      };

      joinAfterUsername();
    }

function handleUsernameEntry() {
  const stored = localStorage.getItem('username');
  if (stored) {
    myUsername = stored;
    navigateTo('/mode');
  } else {
    navigateTo('/username');
  }
}



    submitUsernameBtn.onclick = () => {
      const entered = usernameInput.value.trim();
      if (!entered) return alert('Please enter a username.');
      myUsername = entered;
      localStorage.setItem('username', myUsername);
      navigateTo('/mode');
    };

    changeUsernameBtn.onclick = () => {
      localStorage.removeItem('username');
      location.reload();
    };

    handleUsernameEntry();

   privateGameBtn.onclick = () => {
  const generatedRoomId = `room-${Math.random().toString(36).substring(2, 8)}`;
  roomId = generatedRoomId;
  myRoomId = generatedRoomId;

  socket.emit('joinGame', { roomId: myRoomId, username: myUsername });

  // Update any dynamic text
  statusDiv.textContent = `Started private room: ${myRoomId}`;
  document.getElementById('displayRoomCode').textContent = myRoomId;

  // Update invite link
  inviteLinkContainer.innerHTML = `
    Share this link to invite a friend:<br>
    <a href="${window.location.origin}?room=${myRoomId}" target="_blank">
      ${window.location.origin}?room=${myRoomId}
    </a>
  `;

  // Route to waiting room
  navigateTo('/waiting');
};


  findGameBtn.onclick = () => {
  if (!myUsername) return alert('Missing username');
  if (gameStarted && !gameOver) return alert('Finish your current game first.');

  socket.emit('findMatch', myUsername);

  statusDiv.textContent = 'Looking for a game...';

  // Navigate to the waiting room instead of manually hiding/showing sections
  navigateTo('/waiting');
};


    socket.on('connect', () => {});

  socket.on('playersUpdate', (count) => {
  statusDiv.textContent = `Players in room: ${count}`;

  if (count < 2) {
    rematchBtn.style.display = 'none';
    navigateTo('/waiting');
  } else {
    navigateTo('/play'); // or '/game' or whatever route you've assigned to the main gameplay area
  }
});


   socket.on('matched', ({ roomId, opponent }) => {
  if (gameStarted && !gameOver) return;

  myRoomId = roomId;
  opponentName = opponent;

  statusDiv.textContent = `Matched with ${opponent}! Joining game...`;

  // Navigate to waiting room while joining the game
  navigateTo('/waiting');

  socket.emit('joinGame', { roomId: myRoomId, username: myUsername });
});




// 2. Game Lifecycle
socket.on('gameStarted', (data) => {
  console.log('[CLIENT] Received gameStarted event:', data);

  gameStarted = true;
  gameOver = false;

  leadoffPlayerName = data.leadoffPlayer || null;

  // Clear old timers
  if (window.timerInterval) {
    clearInterval(window.timerInterval);
    window.timerInterval = null;
    console.warn('[CLIENT] Cleared leftover timer before starting new one.');
  }

  // Clear input + errors
  guessInput.disabled = true;
  submitGuessBtn.disabled = true;
  guessInput.value = '';
  clearGuessError();
  clearAutocomplete();

  // Reset rematch state
  rematchBtn.style.display = 'none';
  rematchBtn.disabled = false;
  rematchBtn.textContent = 'Rematch';

  // Clear any messages
  messagesEl.innerHTML = '';
  messagesEl.style.display = 'block';

  // Reset turn history cleanly
  successfulGuesses = [];

  if (data.leadoffPlayer) {
    leadoffPlayerName = data.leadoffPlayer;
    successfulGuesses.push({
      guesser: 'Leadoff',
      name: leadoffPlayerName,
      isLeadoff: true
    });
  }

  console.log('[CLIENT] successfulGuesses after reset:', successfulGuesses);
  renderSuccessfulGuesses();

  // Set current player name
  currentPlayerNameEl.textContent = data.currentPlayerName;

  // ‚úÖ Update "You" and "Opponent" names
  const playerYouEl = document.getElementById('playerYou');
  const playerOpponentEl = document.getElementById('playerOpponent');

  if (playerYouEl) playerYouEl.textContent = myUsername || 'You';
  if (playerOpponentEl && opponentName) playerOpponentEl.textContent = opponentName;

  // ‚úÖ Highlight active player
  const isYourTurn = data.currentPlayerName === myUsername;
  if (playerYouEl && playerOpponentEl) {
    playerYouEl.classList.toggle('active-turn', isYourTurn);
    playerOpponentEl.classList.toggle('active-turn', !isYourTurn);
  }

  // Set initial timer
  timerEl.textContent = data.timeLeft || 15;
  console.log('[CLIENT] Timer initialized at:', data.timeLeft || 15);

  // Navigate to game view
  navigateTo('/game');
});




socket.on('gameOver', (data) => {
  console.log('gameOver received:', data);
  gameOver = true;

  // Disable inputs
  guessInput.disabled = true;
  submitGuessBtn.disabled = true;

  // Clear turn timer
  if (window.timerInterval) {
    clearInterval(window.timerInterval);
    window.timerInterval = null;
  }
  timerEl.textContent = '';

  // Reset and show game over container
  const container = document.getElementById('gameOverContainer');
  container.style.display = 'block'; // ‚úÖ Ensure visibility
  container.innerHTML = '';

  // Show Game Over Message
  const gameOverMsg = document.createElement('div');
  gameOverMsg.style.fontSize = '1.5rem';
  gameOverMsg.style.textAlign = 'center';
  gameOverMsg.style.fontWeight = 'bold';
  gameOverMsg.style.marginTop = '1rem';

  // Determine message content
  if (data.message) {
    gameOverMsg.textContent = data.message;
  } else if (data.reason === 'opponent_left') {
    gameOverMsg.textContent = 'Your opponent left the game.';
  } else {
    gameOverMsg.textContent = 'Game Over!';
  }

  // Color by role
  if (data.role === 'winner') {
    gameOverMsg.style.color = 'green';
  } else if (data.role === 'loser') {
    gameOverMsg.style.color = 'darkred';
  } else {
    gameOverMsg.style.color = 'gray';
  }

  container.appendChild(gameOverMsg);

  // Show or hide rematch button
  if (data.canRematch === false || data.reason === 'opponent_left') {
    rematchBtn.style.display = 'none';
  } else {
    rematchBtn.style.display = 'block';
    rematchBtn.disabled = false;
    rematchBtn.textContent = 'Rematch';
  }

  // üß≠ Navigate to the game over screen
  navigateTo('/gameover');
});






// 3. Turn Management
socket.on('yourTurn', (data) => {
  navigateTo('/play');

  const turnSection = document.getElementById('turnSection');

  turnSection.classList.add('your-turn');
  turnSection.classList.remove('opponent-turn');

  document.getElementById('guessControls').style.display = 'block';
  guessInput.disabled = false;
  submitGuessBtn.disabled = !guessInput.value.trim();

  currentPlayerNameEl.textContent = data.currentPlayerName || 'Your Turn';
  timerEl.textContent = data.timeLeft || 15;

  turnSection.style.display = 'block';
  messagesEl.style.display = 'block';

  showMessage(data.message || "It's your turn to guess!", 'info');

 const turnPromptEl = document.getElementById('turnPromptText');
if (turnPromptEl) {
  turnPromptEl.innerHTML = `üéØ Name any teammate of:<br><strong class="turn-player-name">${data.currentPlayerName}</strong>`;
}



  // ‚úÖ Highlight the current player in playersDisplay
  const playerYouEl = document.getElementById('playerYou');
  const playerOpponentEl = document.getElementById('playerOpponent');

  if (playerYouEl && playerOpponentEl) {
    playerYouEl.classList.add('active-turn');
    playerOpponentEl.classList.remove('active-turn');
  }
});



socket.on('opponentTurn', (data) => {
  navigateTo('/play');

  const turnSection = document.getElementById('turnSection');

  turnSection.classList.remove('your-turn');
  turnSection.classList.add('opponent-turn');

  document.getElementById('guessControls').style.display = 'none';
  guessInput.disabled = true;
  submitGuessBtn.disabled = true;

  currentPlayerNameEl.textContent = data.currentPlayerName || "Opponent's Turn";
  timerEl.textContent = '';

  turnSection.style.display = 'block';
  messagesEl.style.display = 'block';

  showMessage(data.message || "Waiting for your opponent to guess...", 'info');

  const turnPromptEl = document.getElementById('turnPromptText');
if (turnPromptEl) {
  turnPromptEl.innerHTML = `üïí Waiting for opponent to name a teammate of:<br><strong class="turn-player-name">${data.currentPlayerName}</strong>`;
}



  // ‚úÖ Highlight the opponent in playersDisplay
  const playerYouEl = document.getElementById('playerYou');
  const playerOpponentEl = document.getElementById('playerOpponent');

  if (playerYouEl && playerOpponentEl) {
    playerYouEl.classList.remove('active-turn');
    playerOpponentEl.classList.add('active-turn');
  }
});




socket.on('message', (msg) => {
  navigateTo('/play'); // Ensure user is on the gameplay page
  showMessage(msg, 'error');
});



socket.on('turnEnded', (data) => {
  navigateTo('/play');  // Ensure user is on gameplay page
  if (data.successfulGuess) {
    const match = data.successfulGuess.match(/"([^"]+)"/);
    const playerName = match ? match[1] : data.successfulGuess;
    successfulGuesses.push(playerName);
    renderSuccessfulGuesses();
  }

  if (data.message) {
    showMessage(data.message, data.message.startsWith('Incorrect guess') ? 'error' : 'info');
  }

  updateTurn(data);
});

socket.on('timerTick', (data) => {
  timerEl.textContent = data.timeLeft;
});


  // Autocomplete logic
guessInput.addEventListener('input', function() {
  const val = this.value.trim();
  clearAutocomplete();
  selectedPlayer = null;
  submitGuessBtn.disabled = true;

  if (!val) {
    showAutocompleteSuggestions([]);
    return;
  }

  if (fetchTimeout) clearTimeout(fetchTimeout);

  fetchTimeout = setTimeout(async () => {
    try {
      const res = await fetch(`/players?q=${encodeURIComponent(val)}`);
      if (!res.ok) throw new Error('Network response not ok');

      const results = await res.json();
      if (results.length === 0) {
        showAutocompleteSuggestions([]);
        return;
      }

      // ‚úÖ Create an array of actual HTML elements to pass to showAutocompleteSuggestions
      const suggestions = results.map(player => {
        const wrapper = document.createElement('div');
        wrapper.className = 'autocomplete-item';

        const nameSpan = document.createElement('span');
        nameSpan.textContent = player.player_name;

        const yearsSpan = document.createElement('span');
        yearsSpan.className = 'career-years';
        yearsSpan.textContent = ` ${player.first_year || '?'}‚Äì${player.last_year || '?'}`;

        yearsSpan.style.fontSize = '0.8em';
        yearsSpan.style.color = 'gray';
        yearsSpan.style.marginLeft = '5px';

        wrapper.appendChild(nameSpan);
        wrapper.appendChild(yearsSpan);

        wrapper.addEventListener('click', () => {
        guessInput.value = player.player_name;
        selectedPlayer = player.player_name;
        submitGuessBtn.disabled = false;
        clearAutocomplete();
      });

        return wrapper;
      });

      showAutocompleteSuggestions(suggestions);

    } catch (err) {
      console.error('Autocomplete fetch error:', err);
      showAutocompleteSuggestions([]);
    }
  }, 300);
});





  guessInput.addEventListener('change', () => {
    if (guessInput.value !== selectedPlayer) {
      selectedPlayer = null;
      submitGuessBtn.disabled = true;
    }
  });

  submitGuessBtn.onclick = () => {
    const guess = guessInput.value.trim();
    clearGuessError();

    if (!guess) {
      showGuessError('Enter a guess');
      return;
    }
    if (guess !== selectedPlayer) {
      showGuessError('Please select a player from the dropdown list.');
      return;
    }

    socket.emit('playerGuess', { roomId, guess });
    guessInput.value = '';
    selectedPlayer = null;
    submitGuessBtn.disabled = true;
    clearAutocomplete();
  };


rematchBtn.onclick = () => {
  if (!myRoomId) {
    console.error('No roomId defined. Cannot request rematch.');
    return;
  }

  rematchBtn.disabled = true;
  rematchBtn.textContent = 'Waiting for opponent...';

  socket.emit('requestRematch', { roomId: myRoomId });
};


// When another player requests a rematch
socket.on('rematchRequested', ({ username }) => {
  showMessage(`${username} wants a rematch! Click your Rematch button to accept.`, 'info', true);

 
});



// When rematch actually starts
socket.on('rematchStarted', () => {
  resetGameUI();

  // Clear any rematch prompt message
  const rematchInfo = document.getElementById('rematch-info');
  if (rematchInfo) rematchInfo.remove();

  // Reset rematch button styles
  rematchBtn.disabled = false;
  rematchBtn.style.backgroundColor = ''; // Reset highlight
  rematchBtn.textContent = 'Rematch';

  // ‚úÖ Re-join the same room to trigger new game start
  if (myRoomId && myUsername) {
    console.log('[CLIENT] Rejoining room for rematch:', myRoomId);
    socket.emit('joinGame', { roomId: myRoomId, username: myUsername });
  } else {
    console.error('[CLIENT] Missing roomId or username for rematch.');
  }
});




function resetGameUI() {
  gameStarted = true;
  gameOver = false;

  // Clear old timers
  if (window.timerInterval) {
    clearInterval(window.timerInterval);
    window.timerInterval = null;
  }

  guessInput.disabled = true;
  submitGuessBtn.disabled = true;
  guessInput.value = '';
  clearGuessError();
  clearAutocomplete();

  // Reset rematch button visibility and style
  rematchBtn.style.display = 'none';  // Or 'inline-block' if you want it visible immediately
  rematchBtn.disabled = false;
  rematchBtn.textContent = 'Rematch';
  rematchBtn.style.backgroundColor = ''; // Clear any highlight

  // Reset UI parts
  messagesEl.innerHTML = '';
  messagesEl.style.display = 'block';

  successfulGuesses.length = 0;
  document.getElementById('successful-guesses-list').innerHTML = '';
  renderSuccessfulGuesses();

  currentPlayerNameEl.textContent = '';
  timerEl.textContent = '';

  // Show/hide game areas as needed
  waitingRoom.style.display = 'none';
  gameArea.style.display = 'block';
  document.getElementById('turnSection').style.display = 'block';

  // Hide game over container
  const gameOverContainer = document.getElementById('gameOverContainer');
  gameOverContainer.innerHTML = '';
  gameOverContainer.style.display = 'none';

  // Clear persistent rematch message
  const messageContainer = document.getElementById('messageContainer');
  if (messageContainer) {
    messageContainer.innerHTML = '';
  }
}







 function clearGuessError() {
  const container = document.getElementById('messageContainer');
  container.innerHTML = '';
}

function showMessage(message, type = 'info', persist = false) {
  const container = document.getElementById('messageContainer');
  container.innerHTML = '';

  const div = document.createElement('div');
  div.textContent = message;
  div.classList.add('message');

  if (type === 'error') div.classList.add('error');

  container.appendChild(div);

  if (!persist) {
    setTimeout(() => {
      div.classList.add('fade-out');
      setTimeout(() => container.innerHTML = '', 1000);
    }, 3000);
  }
}






  function updateTurn(data) {
    currentPlayerNameEl.textContent = data.currentPlayerName || '???';
    timerEl.textContent = data.timeLeft || 15;
  }



 function clearAutocomplete() {
  autocompleteList.innerHTML = '';
  autocompleteList.style.display = 'none';
}


function showAutocompleteSuggestions(suggestions) {
  const list = document.getElementById('autocomplete-list');
  list.innerHTML = '';

  if (suggestions.length === 0) {
    list.style.display = 'none';  // Hide when empty
    return;
  }

  list.style.display = 'block'; // Show when populated

  suggestions.forEach(suggestionEl => {
    // suggestionEl is an element, append it directly
    list.appendChild(suggestionEl);
  });
}





 function renderSuccessfulGuesses() {
  const listEl = document.getElementById('successful-guesses-list');
  listEl.innerHTML = '';

  const displayList = [...successfulGuesses];

  displayList.forEach((guessObj, index) => {
    const li = document.createElement('li');
    li.style.margin = '0.5rem 0';
    li.style.fontWeight = (index === displayList.length - 1) ? 'bold' : 'normal';

    const name = typeof guessObj === 'string' ? guessObj : guessObj.name;
    const isLeadoff = typeof guessObj === 'object' && guessObj.isLeadoff;

    li.style.color = isLeadoff ? '#007bff' : '#000';
    li.textContent = name;
    listEl.appendChild(li);

    if (index < displayList.length - 1) {
      const arrow = document.createElement('div');
      arrow.style.textAlign = 'center';
      arrow.style.fontSize = '1.2rem';
      arrow.style.color = '#888';
      arrow.textContent = '‚Üì';
      listEl.appendChild(arrow);
    }
  });
 }

function navigateTo(path) {
  history.pushState({}, '', path);
  renderRoute(path);
}

function renderRoute(path) {
  const allSections = document.querySelectorAll('section[data-route]');
  let matched = false;

  allSections.forEach(section => {
    const route = section.getAttribute('data-route');
    if (route === path) {
      section.classList.remove('hidden');
      matched = true;
    } else {
      section.classList.add('hidden');
    }
  });

  if (!matched) {
    const defaultSection = document.querySelector('section[data-route="/username"]');
    if (defaultSection) {
      defaultSection.classList.remove('hidden');
    }
  }
}

document.getElementById('guessInput').addEventListener('focus', () => {
  // Only apply if screen width is <= 480px (adjust as needed for "mobile")
  if (window.innerWidth <= 480) {
    const guessControls = document.getElementById('guessControls');
    const topOffset = guessControls.getBoundingClientRect().top + window.scrollY;
    const padding = parseFloat(getComputedStyle(document.body).paddingTop) || 16;

    window.scrollTo({
      top: topOffset - padding,
      behavior: 'smooth'
    });
  }
});



// Handle browser back/forward navigation
window.addEventListener('popstate', () => {
  renderRoute(location.pathname);
});

// Initial route on page load
document.addEventListener('DOMContentLoaded', () => {
  const initialPath = (location.pathname === '/' || location.pathname === '') ? '/username' : location.pathname;
  renderRoute(initialPath);
});


  }); // End of DOMContentLoaded
</script>
</body>
</html>