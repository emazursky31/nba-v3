<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>NBA Teammate Game</title>
  <script src="https://cdn.socket.io/4.6.1/socket.io.min.js" crossorigin="anonymous"></script>
  <script type="module">
  import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm'

  const SUPABASE_URL = 'https://rbjdlzgptvpfsnkakasj.supabase.co'
  const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJiamRsemdwdHZwZnNua2FrYXNqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg5ODYxMzksImV4cCI6MjA2NDU2MjEzOX0.U0EhIpOaKrHQmAJHcCBVJLKDGEW-m91eNj2bWRejYpk'
  const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY)

  window.supabase = supabase // Expose for later use
</script>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

 <style>
/* Revert to original site-wide styling */
  body {
    font-family: Arial, sans-serif;
    max-width: 600px;
    margin: auto;
    padding: 1rem;
    line-height: 1.5;
    background-color: #f9f9f9;
    color: #222;
  }

  h1, h2, h3 {
    text-align: center;
    margin-bottom: 1rem;
  }

  input[type="text"] {
    width: 100%;
    padding: 0.5rem;
    font-size: 1rem;
    margin-top: 0.25rem;
    box-sizing: border-box;
  }

  button {
    padding: 0.5rem 1rem;
    font-size: 1rem;
    margin-top: 0.5rem;
    cursor: pointer;
  }

  #status {
    text-align: center;
    margin-top: 1rem;
    font-style: italic;
    color: #555;
  }

  #waitingRoom {
    text-align: center;
    margin-top: 2rem;
  }

  #displayRoomCode {
    font-size: 1.5rem;
    font-weight: bold;
    display: inline-block;
    margin-top: 0.5rem;
  }

  #gameArea {
    margin-top: 2rem;
    position: relative;
  }

  @keyframes pulse-border {
  0% {
    box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.5);
  }
  70% {
    box-shadow: 0 0 0 10px rgba(40, 167, 69, 0);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(40, 167, 69, 0);
  }
}

  #turnSection {
    margin-bottom: 1.5rem;
  }

  #turnSection.your-turn {
  border: 3px solid #28a745;
  background-color: #e8f5e9;
  padding: 1rem;
  border-radius: 8px;
  box-shadow: 0 0 12px rgba(40, 167, 69, 0.3);
  transition: all 0.3s ease;
  animation: pulse-border 1.5s infinite;
}

#turnSection.opponent-turn {
  opacity: 0.6;
}


  #timer {
    font-size: 2rem;
    font-weight: bold;
    text-align: center;
    color: #333;
    margin: 1rem 0;
  }

  #guessControls {
  display: flex;
  gap: 0.75rem; /* a bit more gap */
  margin-bottom: 1rem;
  align-items: center; /* vertical center */
  justify-content: center; /* center horizontally */
}

 #guessControls input {
  flex: 1 1 auto;
  min-width: 0; /* helps prevent overflow */
  padding: 0.75rem 1rem; /* more padding for easier touch */
  font-size: 1.1rem;
  border-radius: 4px;
  border: 1px solid #ccc;
  box-sizing: border-box;
}

#submitGuessBtn {
  padding: 0.85rem 1.75rem;
  font-size: 1.1rem;
  min-width: 130px;
  min-height: 56px; /* ‚Üê Ensures at least 56px tall */
  border-radius: 6px;
  cursor: pointer;
  background-color: #007bff;
  color: white;
  border: none;
  transition: background-color 0.25s ease;
}

#submitGuessBtn:disabled {
  background-color: #aaa;
  cursor: not-allowed;
}

#submitGuessBtn:hover:not(:disabled) {
  background-color: #0056b3;
}

#autocomplete-list {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  z-index: 9999;
  background-color: white;
  border: 1px solid #ccc;
  max-height: 200px;
  overflow-y: auto;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
}

.autocomplete-item {
  display: flex;
  justify-content: space-between;
  padding: 6px 10px;
  cursor: pointer;
}

.autocomplete-item:hover {
  background-color: #f0f0f0;
}

.career-years {
  font-size: 0.8em;
  color: gray;
}



  #autocomplete-list div {
    padding: 0.5rem;
    cursor: pointer;
  }

  #autocomplete-list div:hover {
    background: #f0f0f0;
  }

  #successful-guesses-container {
    margin-top: 1rem;
    text-align: center;
  }

  #successful-guesses-list {
    list-style: none;
    padding-left: 0;
    margin-top: 0.5rem;
    text-align: center;
  }

  #successful-guesses-list li {
    margin: 0.5rem 0;
  }

  .hidden {
    display: none !important;
  }

  /* Unified message styling */
  .message {
    margin-top: 0.5rem;
    font-size: 1rem;
    text-align: center;
    color: #333;
    transition: opacity 1s ease;
    opacity: 1;
  }

  .message.error {
    color: red;
    font-weight: bold;
  }

  .message.fade-out {
    opacity: 0;
  }

 .turn-prompt {
  font-size: 1.3rem;
  color: #222;
  margin-bottom: 1rem;
  text-align: center;
  line-height: 1.6;
}

.turn-prompt .turn-player-name {
  display: block;
  font-size: 1.6rem;
  margin-top: 0.5rem;
  color: #007bff;
}

#playersDisplay {
  text-align: center;
  margin-top: 1rem;
  font-size: 1.3rem;
  font-weight: bold;
  color: #222;
}

.player-name {
  padding: 0 0.5rem;
}

.player-name.you {
  color: #28a745; /* green */
}

.player-name.opponent {
  color: #007bff; /* blue */
}

.vs-separator {
  color: #555;
  padding: 0 0.5rem;
}

#welcome-message {
  font-size: 1.5rem;
  margin-bottom: 1rem;
  text-align: center;
  color: #333;
}


  #gameOverContainer {
    display: none;
    text-align: center;
    margin-top: 2rem;
  }

  #rematchBtn {
  display: block; /* ‚Üê Change this from "none" or "inline-block" to block */
  margin: 1.5rem auto 0; /* auto left/right centers it */
  padding: 0.5rem 1.5rem;
  font-weight: bold;
  border: none;
  border-radius: 4px;
  background-color: #007bff;
  color: white;
  transition: background-color 0.3s ease;
}


  #rematchBtn:hover {
    background-color: #0056b3;
  }

 #scoreboardSection {
  position: fixed;
  top: 1rem;
  right: 1rem;
  z-index: 1000;
}

#jumbotronScoreboard {
   background: #fff !important;
  color: #111 !important;
  border: 2px solid #111 !important;
  width: 180px !important;
  min-width: 120px !important;
  max-width: 95vw;
  font-family: Arial, sans-serif;
  box-shadow: none;
}

.scoreboard-box {
  background: #fff !important;
  border: 2px solid #111 !important;
  color: #111 !important;
  min-width: 120px !important;
  border-radius: 6px;
}

.scoreboard-header,
.scoreboard-scores {
  display: flex;
  flex-direction: row;
  width: 100%;
  height: 100%;
}

.scoreboard-header span,
.scoreboard-scores span {
  flex: 1 1 0;
  width: 50%;
  box-sizing: border-box;
  text-align: center;
  padding: 0.5rem;
}

.scoreboard-header .divider,
.scoreboard-scores .divider {
  background: #111 !important;
}

.scoreboard-header {
   background: #fff !important;
  color: #111 !important;
  border-bottom: 1px solid #111 !important;
}

.scoreboard-scores {
  background: #fff !important;
  color: #111 !important;
}

.divider {
  border-left: 1px solid #333;
  flex: 0 0 1px;
  padding: 0;
}


@media (max-width: 480px) {
  #guessControls {
    flex-direction: column;
    gap: 0.6rem;
  }

  #guessControls input, 
  #submitGuessBtn {
    width: 100%;
    min-width: auto;
  }

  #submitGuessBtn {
    font-size: 1.2rem;
    padding: 1rem;          /* visually balances a bigger tap target */
    min-height: 56px;       /* reaffirm minimum height */
  }

  #jumbotronScoreboard {
    width: 98vw !important;
    min-width: 0 !important;
    font-size: 0.95rem;
    padding: 0.2rem 0.1rem;
  }
  .scoreboard-box {
    min-width: 0 !important;
    font-size: 0.95rem;
  }
}

.auth-tabs-container {
  width: 100%;
  max-width: 600px;
  margin: 2rem auto;
}
.auth-tabs {
  display: flex;
  justify-content: center;
  margin-bottom: 1.5rem;
}
.auth-tab {
  flex: 1;
  padding: 1rem 2rem;
  background: #f0f0f0;
  border: none;
  border-bottom: 3px solid transparent;
  color: #333;
  font-size: 1.1rem;
  font-weight: bold;
  cursor: pointer;
  transition: background 0.2s, border-bottom 0.2s, color 0.2s;
}
.auth-tab.active {
  background: #fff;
  border-bottom: 3px solid #007bff;
  color: #007bff;
  z-index: 2;
}
.auth-forms-row {
  display: flex;
  gap: 2rem;
  justify-content: center;
  align-items: flex-start;
}
.auth-form {
  background: #fff;
  border: 1.5px solid #e0e4ea;
  border-radius: 18px;
  box-shadow: 0 6px 24px rgba(0,0,0,0.10), 0 1.5px 4px rgba(0,0,0,0.04);
  padding: 2.2rem 2rem 1.7rem 2rem;
  min-width: 260px;
  width: 100%;
  max-width: 340px;
  display: none;
  flex-direction: column;
  gap: 1.2rem;
  align-items: stretch;
  transition: box-shadow 0.2s, border 0.2s;
}
.auth-form.active {
  display: flex;
  z-index: 1;
  border: 2.5px solid #007bff;
  box-shadow: 0 10px 32px rgba(0,123,255,0.10), 0 2px 8px rgba(0,0,0,0.06);
}
.auth-form input {
  border-radius: 8px;
  border: 1.2px solid #d1d5db;
  padding: 0.85rem 1rem;
  font-size: 1.05rem;
  background: #f8fafc;
  color: #222;
  transition: border 0.2s;
}
.auth-form input:focus {
  border: 1.5px solid #007bff;
  outline: none;
  background: #fff;
}
.auth-form button {
  border-radius: 8px;
  background: linear-gradient(90deg, #007bff 60%, #0056b3 100%);
  color: #fff;
  font-weight: 600;
  font-size: 1.08rem;
  border: none;
  padding: 0.85rem 0;
  margin-top: 0.5rem;
  box-shadow: 0 2px 8px rgba(0,123,255,0.08);
  transition: background 0.2s, box-shadow 0.2s;
  cursor: pointer;
}
.auth-form button:hover {
  background: linear-gradient(90deg, #0056b3 60%, #007bff 100%);
  box-shadow: 0 4px 16px rgba(0,123,255,0.13);
}
.auth-form h2 {
  margin-bottom: 0.5rem;
  color: #007bff;
  font-size: 1.35rem;
  font-weight: 700;
  letter-spacing: 0.01em;
  text-align: center;
}
.auth-form p, .auth-form a {
  font-size: 0.97rem;
  color: #555;
  text-align: center;
}
.auth-form a {
  color: #007bff;
  text-decoration: underline;
  cursor: pointer;
}
.auth-form a:hover {
  color: #0056b3;
}
</style>


</head>
<body>
<nav>
  <span id="nav-username" style="display: none;"></span>
  <a href="#" id="nav-home-link" style="display: none;">üè† Home</a>
  <button id="nav-signin-btn">Sign In</button>
  <button id="nav-signout-btn" style="display: none;">Sign Out</button>
</nav>



<h1>NBA Teammate Game</h1>


<!-- üîë Sign Up / Sign In -->
  <section data-route="/signup">
    <div class="auth-tabs-container">
      <div class="auth-tabs">
        <button id="tab-signup" class="auth-tab active" type="button">Sign Up</button>
        <button id="tab-signin" class="auth-tab" type="button">Sign In</button>
      </div>
      <div class="auth-forms-row">
        <form id="signupForm" class="auth-form active" autocomplete="off">
          <h2>Sign Up</h2>
          <input type="email" id="signup-email" placeholder="Email" required>
          <input type="password" id="signup-password" placeholder="Password" required>
          <input id="signup-username" placeholder="Username" required>
          <button id="signupBtn" type="submit">Sign Up</button>
        </form>
        <form id="signinForm" class="auth-form" autocomplete="off">
          <h2>Sign In</h2>
          <input type="email" id="signin-email" placeholder="Email" required>
          <input type="password" id="signin-password" placeholder="Password" required>
          <button id="signinBtn" type="submit">Sign In</button>
          <p><a href="#" id="forgotPasswordLink">Forgot password?</a></p>
        </form>
      </div>
    </div>
  </section>


 <!-- üîó Check your email after sign up -->
  <section data-route="/verify" class="hidden">
    <h2>Check your email!</h2>
    <p>We've sent you a confirmation link. Click it to verify your account.</p>
  </section>


   <!-- ‚úÖ Confirmation success -->
  <section data-route="/confirmed" class="hidden">
    <h2>Account Confirmed</h2>
    <p>Your email is verified! You can now continue.</p>
    <button id="confirmedContinueBtn">Continue</button>
  </section>

  <!-- üîë Reset password -->
  <section data-route="/reset" class="hidden">
    <h2>Reset Password</h2>
    <input type="email" id="reset-email" placeholder="Email">
    <button id="resetBtn">Send Reset Link</button>
  </section>

  <!-- ‚úÖ Reset success -->
  <section data-route="/reset-confirmed" class="hidden">
    <h2>Password Reset</h2>
    <p>Check your email for a link to set a new password.</p>
  </section>

<!-- Set password -->
  <section data-route="/update-password" class="hidden">
  <h2>Set a New Password</h2>
  <input type="password" id="new-password" placeholder="New password" />
  <button id="updatePasswordBtn">Update Password</button>
</section>


  <!-- ‚úèÔ∏è Create username/profile
  <section data-route="/username" class="hidden">
    <h2>Create Profile</h2>
    <input id="create-username" placeholder="Choose a username">
    <button id="saveUsernameBtn">Save</button>
  </section> -->


<!-- Home Screen -->
<section id="homeSelection" data-route="/home" class="hidden" style="text-align: center; margin-top: 2rem;">
  <h2 id="home-welcome"></h2>
  <h2>üè† Home</h2>

  <div id="gameModeSelection" style="margin-top: 1rem;">
    <button id="privateGameBtn">üîí Start Private Game</button>
    <button id="findGameBtn">üåê Join Public Game</button>
  </div>

  <div id="playerStats" style="margin-top: 2rem;">
    <h3>Your Stats</h3>
    <p id="player-history">Games played, wins, and other stats will appear here.</p>
  </div>
</section>


<!-- Invite link container (used only in private games) -->
<section id="inviteLinkContainer" data-route="/invite" class="hidden" style="text-align: center; margin-top: 1rem;"></section>

<!-- Status message -->
<section id="status" data-route="/status" style="text-align: center; margin-top: 1rem;"></section>

<!-- Waiting Room View -->
<section id="waitingRoom" data-route="/waiting" class="hidden" style="text-align: center; margin-top: 2rem;">
  <h2>Waiting Room</h2>
  <p>Waiting for another player to join...</p>
  <code id="displayRoomCode" style="font-size: 1.5rem; font-weight: bold;"></code>
  <div id="inviteLinkWrapper" style="margin-top: 1rem;">
    <p>Invite a friend to join using this link:</p>
    <input id="inviteLink" type="text" readonly style="width: 80%; max-width: 400px; padding: 0.5rem;" />
    <button id="copyInviteBtn">Copy Link</button>
  <div id="copyToast" style="display:none; color: green; margin-top: 0.5rem;">Link copied!</div>
  </div>
</section>

<!-- Scoreboard UI -->
<!-- <section id="scoreboardSection">
  <div id="jumbotronScoreboard" class="scoreboard-box">
    <div class="scoreboard-header">
      <span id="player1Name">Player 1</span>
      <span id="player2Name">Player 2</span>
    </div>
    <div class="scoreboard-scores">
      <span id="player1Score" class="scoreDigits">0</span>
      <span id="player2Score" class="scoreDigits">0</span>
    </div>
  </div>
</section> -->


<!-- In-Game UI -->
<section id="gameArea" data-route="/play" class="hidden" style="position: relative;">
 <div id="playersDisplay">
  <span class="player-name you" id="playerYou">You</span>
  <span class="vs-separator">vs</span>
  <span class="player-name opponent" id="playerOpponent">Opponent</span>
</div>

  <div id="turnSection">
  <p class="turn-prompt" id="turnPromptText" style="display: flex; align-items: center; gap: 12px;">
  üéØ Name any teammate of:<br>
  <img id="currentPlayerHeadshot" src="/images/default-player.png" alt="Current Player Headshot" width="60" height="60" style="border-radius: 50%; object-fit: cover;"/>
  <strong class="turn-player-name" id="currentPlayerName">LeBron James</strong>
</p>



   <p>Time left: <span id="timer">15</span> seconds</p>
    <div id="guessControls" style="position: relative;">
      <input
        type="text"
        id="guessInput"
        placeholder="Type a teammate's name..."
        autocomplete="off"
        autocorrect="off"
        autocapitalize="off"
        spellcheck="false"
      />
      <button id="submitGuessBtn" disabled>Submit Guess</button>
      <div id="autocomplete-list"></div>
    </div>
  </div>

  <div id="messageContainer"></div>
</section>



<!-- Game Over UI -->
<section data-route="/gameover" class="hidden" style="text-align: center; margin-top: 2rem;">
  <div id="gameOverContainer" style="display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 1rem;">
    <!-- Game over message will be dynamically added here -->

    <!-- Add this container for winner/loser details -->
    <div id="gameOverResults" style="font-size: 1.2rem; margin-top: 1rem;"></div>
  </div>
  <button id="rematchBtn" style="margin-top: 1rem;">Request Rematch</button>
</section>


<!-- Shared Turn History List -->
<div id="successful-guesses-container" style="text-align: center; margin-top: 2rem;">
  <h3 style="margin-bottom: 0.5rem;">Turn History</h3>
  <ul id="successful-guesses-list" style="list-style: none; padding: 0;"></ul>
</div>



<script>
// 1. Global variables and state (outside DOMContentLoaded)
// Core state
  let roomId = null;
  let myRoomId = null;
  let selectedPlayer = null;
  let fetchTimeout = null;
  let gameStarted = false;
  let gameOver = false;
  let leadoffPlayerName = null;
  let myUsername = null;
  let opponentName = null;
  let successfulGuesses = [];
  let isPrivateGame = false;
  let socket = null;
  let isLeavingGame = false;
// ‚úÖ Global route tracker
  let currentRoute = '';
  let statusDiv = null;
  let socketConnected = false;
  let emitQueue = [];

  // DOM element references (assigned in DOMContentLoaded)
let guessInput = null;
let submitGuessBtn = null;
let rematchBtn = null;
let messagesEl = null;
let currentPlayerNameEl = null;
let currentPlayerHeadshotEl = null;
let timerEl = null;
let autocompleteList = null;
let waitingRoom = null;
let gameArea = null;
let inviteLinkContainer = null;
let myUserId = null;




// 2. Function definitions (outside DOMContentLoaded)
 // ‚úÖ Sign Up handler
  async function signUp(e) {
    e.preventDefault(); // üõë Stop default form submit

    const email = document.getElementById('signup-email').value.trim();
    const password = document.getElementById('signup-password').value.trim();
    const username = document.getElementById('signup-username').value.trim();

    if (!email || !password || !username) {
      alert('Please fill in all fields.');
      return;
    }

    if (password.length < 6) {
      alert('Password must be at least 6 characters.');
      return;
    }

    console.log('[DEBUG] SignUp data =>', email, username);

    const { data, error } = await supabase.auth.signUp({
      email,
      password,
      options: {
        data: { username }
      }
    });

    if (error) {
      console.error('SignUp error:', error.message);
      return;
    }

    console.log('‚úÖ Sign Up successful:', data);
    navigateTo('/verify'); // üëà Show verification screen
  }

  // ‚úÖ Sign In handler
  async function signIn(e) {
    e.preventDefault(); // üõë Stop default form submit

    const email = document.getElementById('signin-email').value.trim();
    const password = document.getElementById('signin-password').value.trim();

    if (!email || !password) {
      alert('Please fill in all fields.');
      return;
    }

    console.log('[DEBUG] SignIn data =>', email);

    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password
    });

    if (error) {
      console.error('SignIn error:', error.message);
      alert(error.message);
      return;
    }

    console.log('‚úÖ Sign In successful:', data);
    const user = data.user;
    myUsername = user.user_metadata?.username || user.email;
    localStorage.setItem('username', myUsername);

    console.log('[DEBUG] Username set to:', myUsername);
    navigateTo('/home'); // üëà Take them to home or wherever
  }


function updateSplitScoreboard(stats, player1, player2) {
  const p1NameEl = document.getElementById('player1Name');
  const p2NameEl = document.getElementById('player2Name');

  if (!p1NameEl || !p2NameEl) {
    console.warn('[DEBUG] Scoreboard elements not found. Skipping updateSplitScoreboard.');
    return; // Or: queue the update!
  }

  const p1Name = player1 || 'Player 1';
  const p2Name = player2 || 'Player 2';

  p1NameEl.textContent = p1Name;
  p2NameEl.textContent = p2Name;

  const safeStats = stats || {};
  const player1Stats = safeStats[p1Name];
  const player2Stats = safeStats[p2Name];
  const p1Wins = (player1Stats && typeof player1Stats.wins === 'number') ? player1Stats.wins : 0;
  const p2Wins = (player2Stats && typeof player2Stats.wins === 'number') ? player2Stats.wins : 0;

  document.getElementById('player1Score').textContent = p1Wins;
  document.getElementById('player2Score').textContent = p2Wins;
}



function waitForScoreboard() {
  return new Promise((resolve) => {
    const check = () => {
      if (
        document.getElementById('player1Name') &&
        document.getElementById('player1Score')
      ) {
        resolve();
      } else {
        requestAnimationFrame(check);
      }
    };
    check();
  });
}



function markLeadoffInGuesses(guesses, leadoffName) {
  return guesses.map(g => ({
    ...g,
    isLeadoff: g.name === leadoffName
  }));
}



function startPrivateGame() {
  console.log('[DEBUG] startPrivateGame called');

  if (isLeavingGame) {
    console.log('[DEBUG] startPrivateGame aborted: isLeavingGame is true');
    return;
  }

  if (!myUsername) {
    alert('Missing username');
    return;
  }

  if (gameStarted && !gameOver) {
    alert('Finish your current game first.');
    return;
  }

  isPrivateGame = true;
  isLeavingGame = false;

  // Generate new room and clear stale room data
  const generatedRoomId = `room-${Math.random().toString(36).substring(2, 8)}`;
  roomId = generatedRoomId;
  myRoomId = generatedRoomId;

  window.supabase.auth.getUser().then(({ data }) => {
    const userId = data?.user?.id;
    if (!userId) {
      alert('Could not get your user ID. Please sign in again.');
      return;
    }
    socket.emit('joinGame', { roomId: myRoomId, username: myUsername, userId });

    statusDiv.textContent = `Started private room: ${myRoomId}`;
    document.getElementById('displayRoomCode').textContent = myRoomId;

    // **Don't overwrite the container innerHTML!**
    const inviteInput = document.getElementById('inviteLink');
    if (inviteInput) {
      inviteInput.value = `${window.location.origin}?room=${myRoomId}`;
    }

    // Show the waiting room section
    waitingRoom.classList.remove('hidden');

    // Setup copy button listeners
    setupCopyInviteListeners();

    navigateTo('/waiting');
  });
}



async function joinPublicGame() {
  console.log('[DEBUG] joinPublicGame called');

  isLeavingGame = false;
  localStorage.removeItem('isLeavingGame');

  if (!myUsername) {
    console.warn('[DEBUG] myUsername is null, attempting to recover from session');
    // Try to get username from current session
    const { data: { user } } = await supabase.auth.getUser();
    if (user) {
      myUsername = user.user_metadata?.username || user.email;
      localStorage.setItem('username', myUsername);
      console.log('[DEBUG] Recovered username:', myUsername);
    }

    // If still no username, show error
    if (!myUsername) {
      alert('Missing username. Please sign out and sign in again.');
      return;
    }
  }

  if (gameStarted && !gameOver) {
    alert('Finish your current game first.');
    return;
  }

  myRoomId = null;
  roomId = null;
  isPrivateGame = false;

  selectedPlayer = null;
  successfulGuesses = [];
  gameOver = false;

  // ‚úÖ Ensure socket is connected (don't re-initialize)
  if (!socket || !socket.connected) {
    console.log('[joinPublicGame] Socket not ready, waiting for connection...');
    // Socket should already be initialized in DOMContentLoaded
  }

  // Fetch user_id from Supabase and emit findMatch with userId
  const { data: { user } } = await supabase.auth.getUser();
  const userId = user?.id;
  if (!userId) {
    alert('Could not get your user ID. Please sign in again.');
    return;
  }

  console.log('[DEBUG] Navigating to /waiting...');
  await navigateTo('/waiting');

  console.log('[DEBUG] Using safeEmit to find match:', myUsername, userId);
  safeEmit('findMatch', { username: myUsername, userId });
}



  function safeEmit(event, data) {
    if (!socket) {
      console.warn(`[safeEmit] Socket is null ‚Äî this shouldn't happen after DOMContentLoaded`);
      return; // Don't emit if socket isn't ready
    }

  emitQueue.push({ event, data });

  if (socket && socket.connected) {
    console.log(`[safeEmit] Socket connected ‚Äî emitting "${event}" immediately`);
    flushEmitQueue();
  } else {
    console.log(`[safeEmit] Socket not connected ‚Äî queued "${event}"`);
  }
}

function flushEmitQueue() {
  if (!socket) {
    console.warn(`[flushEmitQueue] Socket is null ‚Äî cannot flush`);
    return;
  }

  while (socket.connected && emitQueue.length > 0) {
    const { event, data } = emitQueue.shift();
    console.log(`[safeEmit] Flushing queued "${event}"`);
    socket.emit(event, data);
  }
}


function updateHeadshot(player) {
  if (currentPlayerHeadshotEl) {
    currentPlayerHeadshotEl.src = player.headshot_url || '/images/default-player.png';
    currentPlayerHeadshotEl.alt = `${player.player_name || 'Unknown'} Headshot`;
  }
}



function attachRouteListeners(route) {
  switch (route) {
    case '/signup':
      // Setup auth tab switching
      setupAuthTabs();
      // Only non-form button listeners (forms handled by setupFormListeners)
      const forgotPasswordLink = document.getElementById('forgotPasswordLink');
      if (forgotPasswordLink) {
        forgotPasswordLink.addEventListener('click', (e) => {
          e.preventDefault();
          navigateTo('/reset');
        });
      }
      break;

    case '/confirmed':
      const confirmedContinueBtn = document.getElementById('confirmedContinueBtn');
      if (confirmedContinueBtn) {
        confirmedContinueBtn.addEventListener('click', () => {
          handleAuthSuccess();
        });
      }
      // Update nav state for confirmed page
      updateNavUserState();
      break;

    case '/home':
      const privateGameBtn = document.getElementById('privateGameBtn');
      const findGameBtn = document.getElementById('findGameBtn');
      
      if (privateGameBtn) {
        privateGameBtn.addEventListener('click', () => {
          if (privateGameBtn.disabled) return; // Prevent multiple clicks
          privateGameBtn.disabled = true;
          setTimeout(() => privateGameBtn.disabled = false, 2000); // Re-enable after 2s

          isLeavingGame = false;
          startPrivateGame();
        });
      }

      if (findGameBtn) {
        findGameBtn.addEventListener('click', () => {
          if (findGameBtn.disabled) return; // Prevent multiple clicks
          findGameBtn.disabled = true;
          setTimeout(() => findGameBtn.disabled = false, 2000); // Re-enable after 2s

          isLeavingGame = false;
          joinPublicGame();
        });
      }

      loadPlayerStats();
      break;

    case '/play':
      // Game-specific listeners
      const submitGuessBtn = document.getElementById('submitGuessBtn');
      const rematchBtn = document.getElementById('rematchBtn');
      
      if (submitGuessBtn) {
        submitGuessBtn.addEventListener('click', submitGuess);
      }
      
      if (rematchBtn) {
        rematchBtn.addEventListener('click', requestRematch);
      }
      
      // Setup autocomplete for gameplay
      setupAutocompleteListeners();
      setupMobileInputFocus();
      break;

    case '/waiting':
      if (isPrivateGame && myRoomId) {
        const inviteInput = document.getElementById('inviteLink');
        if (inviteInput) {
          inviteInput.value = `${window.location.origin}?room=${myRoomId}`;
        }

        const roomCodeEl = document.getElementById('displayRoomCode');
        if (roomCodeEl) {
          roomCodeEl.textContent = myRoomId;
        }

        waitingRoom.classList.remove('hidden');
      }
      // Setup copy invite button listener anyway
      setupCopyInviteListeners();
      break;


    // Add other route handlers as needed
  }
}

function navigateTo(path, options = {}) {
  return new Promise((resolve) => {
    // Track the intended route immediately
    currentRoute = path;

    if (!options.skipPush) {
      history.pushState({}, '', path);
    }

    showRouteSection(path);

    // Wrap updateUIForRoute with a guard
    if (currentRoute === path) {
      updateUIForRoute(path);
      attachRouteListeners(path);
    } else {
      console.debug('[navigateTo] Skipped updateUIForRoute ‚Äî stale path', path);
    }

    // Use rAF for next paint
    requestAnimationFrame(() => {
      resolve();
    });
  });
}

function setupMobileInputFocus() {
  const guessInput = document.getElementById('guessInput');
  if (guessInput) {
    guessInput.addEventListener('focus', () => {
      // Only apply if screen width is <= 480px (mobile)
      if (window.innerWidth <= 480) {
        const guessControls = document.getElementById('guessControls');
        const topOffset = guessControls.getBoundingClientRect().top + window.scrollY;
        const padding = parseFloat(getComputedStyle(document.body).paddingTop) || 16;

        window.scrollTo({
          top: topOffset - padding,
          behavior: 'smooth'
        });
      }
    });
  }
}

function setupAuthTabs() {
  const tabSignup = document.getElementById('tab-signup');
  const tabSignin = document.getElementById('tab-signin');
  const signupForm = document.getElementById('signupForm');
  const signinForm = document.getElementById('signinForm');
  
  if (tabSignup && tabSignin && signupForm && signinForm) {
    tabSignup.addEventListener('click', function() {
      tabSignup.classList.add('active');
      tabSignin.classList.remove('active');
      signupForm.classList.add('active');
      signinForm.classList.remove('active');
    });
    
    tabSignin.addEventListener('click', function() {
      tabSignin.classList.add('active');
      tabSignup.classList.remove('active');
      signinForm.classList.add('active');
      signupForm.classList.remove('active');
    });
  }
}



  function submitGuess() {
  const guess = guessInput.value.trim();
  clearGuessError();

  if (!guess) {
    showGuessError('Enter a guess');
    return;
  }
  if (guess !== selectedPlayer) {
    showGuessError('Please select a player from the dropdown list.');
    return;
  }

  socket.emit('playerGuess', { roomId, guess });
  guessInput.value = '';
  selectedPlayer = null;
  submitGuessBtn.disabled = true;
  clearAutocomplete();
}


function requestRematch() {
  if (!myRoomId) {
    console.error('No roomId defined. Cannot request rematch.');
    return;
  }
  rematchBtn.disabled = true;
  rematchBtn.textContent = 'Waiting for opponent...';
  socket.emit('requestRematch', { roomId: myRoomId });
}


function resetGameUI() {
  gameStarted = true;
  gameOver = false;

  // Clear old timers
  if (window.timerInterval) {
    clearInterval(window.timerInterval);
    window.timerInterval = null;
  }

  guessInput.disabled = true;
  submitGuessBtn.disabled = true;
  guessInput.value = '';
  clearGuessError();
  clearAutocomplete();

  // Reset rematch button visibility and style
  rematchBtn.style.display = 'none';  // Or 'inline-block' if you want it visible immediately
  rematchBtn.disabled = false;
  rematchBtn.textContent = 'Rematch';
  rematchBtn.style.backgroundColor = ''; // Clear any highlight

  // Reset UI parts
  messagesEl.innerHTML = '';
  messagesEl.style.display = 'block';

  successfulGuesses.length = 0;
  document.getElementById('successful-guesses-list').innerHTML = '';
  renderSuccessfulGuesses();

  currentPlayerNameEl.textContent = '';
  timerEl.textContent = '';

  // Show/hide game areas as needed
  waitingRoom.style.display = 'none';
  gameArea.style.display = 'block';
  document.getElementById('turnSection').style.display = 'block';

  // Hide game over container
  const gameOverContainer = document.getElementById('gameOverContainer');
  gameOverContainer.innerHTML = '';
  gameOverContainer.style.display = 'none';

  // Clear persistent rematch message
  const messageContainer = document.getElementById('messageContainer');
  if (messageContainer) {
    messageContainer.innerHTML = '';
  }
}


function showGuessError(message) {
  showMessage(message, 'error');
}


 function clearGuessError() {
    const container = document.getElementById('messageContainer');
    container.innerHTML = '';
  }

  function showMessage(message, type = 'info', persist = false) {
    const container = document.getElementById('messageContainer');
    container.innerHTML = '';

    const div = document.createElement('div');
    div.textContent = message;
    div.classList.add('message');

    if (type === 'error') div.classList.add('error');

    container.appendChild(div);

    if (!persist) {
      setTimeout(() => {
        div.classList.add('fade-out');
        setTimeout(() => container.innerHTML = '', 1000);
      }, 3000);
    }
  }




  function clearAutocomplete() {
    autocompleteList.innerHTML = '';
    autocompleteList.style.display = 'none';
  }


function showAutocompleteSuggestions(suggestions) {
  const list = document.getElementById('autocomplete-list');
  list.innerHTML = '';

  if (suggestions.length === 0) {
    list.style.display = 'none';  // Hide when empty
    return;
  }

  list.style.display = 'block'; // Show when populated

  suggestions.forEach(suggestionEl => {
    // suggestionEl is an element, append it directly
    list.appendChild(suggestionEl);
  });
}


function renderSuccessfulGuesses() {
  const listEl = document.getElementById('successful-guesses-list');
  if (!listEl || !Array.isArray(successfulGuesses)) return;

  listEl.innerHTML = '';

  const displayList = [...successfulGuesses].reverse();

  displayList.forEach((guessObj, index) => {
    // Defensive: make sure we handle all cases
    let rawName = guessObj?.name ?? '';
    let name = '';

    if (typeof rawName === 'string') {
      name = rawName.trim();
    } else if (rawName && typeof rawName === 'object' && rawName.player_name) {
      name = String(rawName.player_name).trim();
    } else {
      name = String(rawName).trim();
    }

    const isLeadoff = !!guessObj?.isLeadoff;
    const guesser = guessObj?.guesser ?? '';
    const sharedTeams = Array.isArray(guessObj?.sharedTeams) ? guessObj.sharedTeams : [];

    if (!name) return; // Skip invalid guesses

    // Guess box
    const box = document.createElement('div');
    box.style.border = '1px solid #ccc';
    box.style.borderRadius = '8px';
    box.style.padding = '0.75rem';
    box.style.margin = '0.5rem auto';
    box.style.maxWidth = '300px';
    box.style.textAlign = 'center';
    box.style.backgroundColor = isLeadoff
      ? '#e6f0ff'
      : (guesser === myUsername ? '#d4edda' : '#f1f1f1');
    box.style.boxShadow = '0 2px 6px rgba(0,0,0,0.05)';

    const nameEl = document.createElement('div');
    nameEl.textContent = name;
    nameEl.style.fontSize = '1.1rem';
    nameEl.style.fontWeight = 'bold';
    box.appendChild(nameEl);

    listEl.appendChild(box);

    // Shared stints above arrow, only if NOT leadoff
    if (!isLeadoff && sharedTeams.length > 0 && index < displayList.length - 1) {
      const sharedInfo = document.createElement('div');
      sharedInfo.style.textAlign = 'center';
      sharedInfo.style.fontSize = '0.85rem';
      sharedInfo.style.color = '#444';
      sharedInfo.style.marginBottom = '0.25rem';

      const teamStrings = sharedTeams.map(t => {
        if (typeof t === 'string') return t;
        if (typeof t === 'object' && t.team && t.years) {
          return `${t.team} (${t.years})`;
        }
        return JSON.stringify(t); // Fallback debug output
      });

      sharedInfo.textContent = teamStrings.join(' ‚Ä¢ ');

      listEl.appendChild(sharedInfo);
    }

    // Up arrow (except for last guess)
    if (index < displayList.length - 1) {
      const arrow = document.createElement('div');
      arrow.textContent = '‚Üë';
      arrow.style.fontSize = '1.2rem';
      arrow.style.color = '#888';
      arrow.style.textAlign = 'center';
      arrow.style.margin = '0.25rem 0 0 0';
      listEl.appendChild(arrow);
    }
  });
}


function setupGlobalNavListeners() {
  // Home navigation with game leave logic
  const navHomeLink = document.getElementById('nav-home-link');
  if (navHomeLink) {
    navHomeLink.addEventListener('click', (e) => {
      e.preventDefault();
      isLeavingGame = true;
      if (socket && socket.connected) {
        socket.emit('leaveGame');
      }
      navigateTo('/home');
    });
  }

  // Sign out button
  const navSignoutBtn = document.getElementById('nav-signout-btn');
if (navSignoutBtn) {
  navSignoutBtn.addEventListener('click', async () => {
    // Check if user is in an active game
    if (gameStarted && !gameOver && socket && socket.connected) {
      // Emit a specific sign-out event to give opponent the win
      socket.emit('playerSignedOut', { 
        roomId: myRoomId || roomId,
        username: myUsername,
        reason: 'signed_out'
      });
    }
    
    // Set leaving game flag to prevent reconnection attempts
    isLeavingGame = true;
    localStorage.setItem('isLeavingGame', 'true');
    
    // Sign out from Supabase
    await window.supabase.auth.signOut();
    
    // Clear game state
    gameStarted = false;
    gameOver = true;
    myRoomId = null;
    roomId = null;
    
    // Update UI and navigate
    updateNavUserState();
    navigateTo('/signup');
  });
}

  // Sign in button
  const navSigninBtn = document.getElementById('nav-signin-btn');
  if (navSigninBtn) {
    navSigninBtn.addEventListener('click', () => {
      window.location.href = '/signin.html';
    });
  }
}

function showRouteSection(path) {
  const allSections = document.querySelectorAll('section[data-route]');
  let matched = false;

  allSections.forEach(section => {
    const route = section.getAttribute('data-route');
    if (route === path) {
      section.classList.remove('hidden');
      matched = true;
    } else {
      section.classList.add('hidden');
    }
  });

  // Fallback if no matching route found
  if (!matched) {
    const defaultSection = document.querySelector('section[data-route="/signup"]');
    if (defaultSection) {
      defaultSection.classList.remove('hidden');
    }
  }
}

function updateUIForRoute(path) {
   if (path !== currentRoute) {
    console.debug('[updateUIForRoute] Skipped because stale:', path, 'Expected:', currentRoute);
    return;
  }

  console.debug('[updateUIForRoute] Handling:', path);
 if (path === '/home') {
  console.log('[DEBUG] updateUIForRoute: Handling /home');

  // ‚úÖ Mark that you are intentionally leaving
  if (socket && socket.connected) {
    isLeavingGame = true;
    socket.emit('leaveGame');
  }

  // üßπ Clear local game state
  gameStarted = false;
  gameOver = true;
  roomId = null;
  myRoomId = null;
  isPrivateGame = false;
  selectedPlayer = null;
  successfulGuesses = [];

  // ‚úÖ DO NOT reset isLeavingGame here!
  // Let it stay true until you explicitly join or navigate away.

  // Update welcome
  const welcomeEl = document.getElementById('home-welcome');
  if (welcomeEl && myUsername) {
    welcomeEl.textContent = `Welcome, ${myUsername}! Choose your game mode below.`;
  }
}



if (path === '/waiting') {
  if (isLeavingGame) {
    console.log('[DEBUG] updateUIForRoute: Skipping /waiting because isLeavingGame is true');
    return;  // üõë Prevent accidental waiting room navigation
  }

  // ‚úÖ Use the shared statusDiv declared once near top
  if (statusDiv) {
    statusDiv.textContent = 'Waiting for an opponent...';
  } else {
    console.warn('[WARN] statusDiv not found when trying to update!');
  }

  const codeEl = document.getElementById('displayRoomCode');
  const inviteWrapper = document.getElementById('inviteLinkWrapper');
  const inviteInput = document.getElementById('inviteLink');

  if (codeEl && myRoomId) {
    codeEl.textContent = myRoomId;
  }

  if (inviteWrapper && inviteInput) {
    if (isPrivateGame && myRoomId) {
      const inviteUrl = `${window.location.origin}?room=${myRoomId}`;
      inviteInput.value = inviteUrl;
      inviteWrapper.style.display = 'block';
      inviteInput.focus();
      inviteInput.select();
    } else {
      inviteInput.value = '';
      inviteWrapper.style.display = 'none';
    }
  }
}


  // Guess container visibility
  const guessContainer = document.getElementById('successful-guesses-container');
  if (guessContainer) {
    guessContainer.style.display = (path === '/play' || path === '/gameover') ? 'block' : 'none';
  }

  // Scoreboard visibility
  const scoreboard = document.getElementById('scoreboardSection');
  if (scoreboard) {
    if (path === '/play' || path === '/gameover') {
      scoreboard.classList.remove('hidden');
    } else {
      scoreboard.classList.add('hidden');
    }
  }
}



function setupFormListeners() {
  // Signup form
  const signupForm = document.getElementById('signupForm');
  if (signupForm) {
    signupForm.addEventListener('submit', signUp);
    console.log('[DEBUG] signupForm listener attached');
  } else {
    console.warn('[WARN] signupForm not found - may not be on signup route');
  }

  // Signin form
  const signinForm = document.getElementById('signinForm');
  if (signinForm) {
    signinForm.addEventListener('submit', signIn);
    console.log('[DEBUG] signinForm listener attached');
  } else {
    console.warn('[WARN] signinForm not found - may not be on signin route');
  }

  // Reset password form
  const resetForm = document.getElementById('resetForm');
  if (resetForm) {
    resetForm.addEventListener('submit', resetPassword);
    console.log('[DEBUG] resetForm listener attached');
  } else {
    console.warn('[WARN] resetForm not found - may not be on reset route');
  }

  // Update password form
  const updatePasswordForm = document.getElementById('updatePasswordForm');
  if (updatePasswordForm) {
    updatePasswordForm.addEventListener('submit', updatePassword);
    console.log('[DEBUG] updatePasswordForm listener attached');
  } else {
    console.warn('[WARN] updatePasswordForm not found - may not be on update-password route');
  }

  // Username form (if you have one for setting username)
  const usernameForm = document.getElementById('usernameForm');
  if (usernameForm) {
    usernameForm.addEventListener('submit', setUsername);
    console.log('[DEBUG] usernameForm listener attached');
  } else {
    console.warn('[WARN] usernameForm not found - may not be on username route');
  }
}



function handleGoHome() {
  console.debug('[CLIENT] handleGoHome called');

  // ‚úÖ Mark that you‚Äôre intentionally leaving ‚Äî and persist it!
  isLeavingGame = true;
  localStorage.setItem('isLeavingGame', 'true');

  // ‚úÖ Tell server if in an active game
  if (socket && socket.connected && gameStarted && !gameOver) {
    socket.emit('leaveGame');
  }

  // ‚úÖ Always clear local game state
  myRoomId = null;
  roomId = null;
  isPrivateGame = false;
  gameStarted = false;
  gameOver = true;
  selectedPlayer = null;
  successfulGuesses = [];

  localStorage.removeItem('privateRoomId');

  navigateTo('/home');
}

function setupCopyInviteListeners() {
  const copyInviteBtn = document.getElementById('copyInviteBtn');
  const copyToast = document.getElementById('copyToast');
  const inviteInput = document.getElementById('inviteLink');

  if (!copyInviteBtn || !copyToast || !inviteInput) {
    // Elements don't exist on this route, skip setup
    return;
  }

  copyInviteBtn.addEventListener('click', () => {
    navigator.clipboard.writeText(inviteInput.value)
      .then(() => {
        copyToast.style.display = 'block';
        copyInviteBtn.disabled = true; // Disable to prevent spamming

        // Hide toast after 2 seconds
        setTimeout(() => {
          copyToast.style.display = 'none';
          copyInviteBtn.disabled = false; // Re-enable button
        }, 2000);
      })
      .catch(err => {
        alert('Failed to copy link. Please copy it manually.');
        console.error('Clipboard copy failed:', err);
      });
  });
}




async function handleAuthSuccess() {
  const { data: { user }, error } = await supabase.auth.getUser();
  if (error || !user) {
    console.error('No user signed in');
    navigateTo('/signup');
    return;
  }

  const username = user.user_metadata?.username || null;

  if (!username) {
    console.error('No username found in user_metadata!');
    navigateTo('/signup');
    return;
  }

  // Try updating profiles row, but don‚Äôt block navigation if it fails
  const { error: updateError } = await supabase
    .from('profiles')
    .update({ username })
    .eq('id', user.id);

  if (updateError) {
    console.warn('Warning: Error updating profile:', updateError.message);
  } else {
    console.log('‚úÖ Username saved to profiles:', username);
  }

  myUsername = username;
  localStorage.setItem('username', myUsername);

  // Clear URL hash to remove confirmation tokens
  history.replaceState(null, '', window.location.pathname);

  navigateTo('/home');
}


async function signOut() {
  const { error } = await window.supabase.auth.signOut();
  if (error) {
    alert('Sign out error: ' + error.message);
    return;
  }
  alert('Signed out!');
  showUser();
}


async function updateNavUserState(session) {
  const usernameDiv = document.getElementById('nav-username');
  const signinBtn = document.getElementById('nav-signin-btn');
  const signoutBtn = document.getElementById('nav-signout-btn');
  const homeLink = document.getElementById('nav-home-link'); // ‚úÖ Add this

  if (!usernameDiv || !signinBtn || !signoutBtn || !homeLink) return;

  if (!session || !session.user) {
    // Not logged in
    usernameDiv.style.display = 'none';
    signinBtn.style.display = 'inline-block';
    signoutBtn.style.display = 'none';
    homeLink.style.display = 'none'; // ‚úÖ Hide Home link
  } else {
    // Logged in
    const user = session.user;
    usernameDiv.textContent = `Hello, ${user.user_metadata?.username || user.email}`;
    usernameDiv.style.display = 'inline-block';
    signinBtn.style.display = 'none';
    signoutBtn.style.display = 'inline-block';
    homeLink.style.display = 'inline-block'; // ‚úÖ Show Home link
  }
}


async function resetPassword() {
  const emailInput = document.getElementById('reset-email');
  const email = emailInput.value.trim();

  if (!email) {
    alert('Please enter your email address.');
    return;
  }

  try {
    const { data, error } = await supabase.auth.resetPasswordForEmail(email, {
      redirectTo: `${window.location.origin}/update-password`
    });

    if (error) {
      console.error('[ERROR] Supabase reset error:', error.message);
      alert('Error sending reset email: ' + error.message);
      return;
    }

    console.log('[INFO] Password reset email sent:', data);
    navigateTo('/reset-confirmed'); // Switch to your "Check your email" screen!
  } catch (err) {
    console.error('[ERROR] Unexpected:', err);
    alert('An unexpected error occurred.');
  }
}

async function updatePassword() {
  const newPasswordInput = document.getElementById('new-password');
  const newPassword = newPasswordInput.value.trim();

  if (!newPassword) {
    alert('Please enter a new password.');
    return;
  }

  const { data, error } = await supabase.auth.updateUser({
    password: newPassword
  });

  if (error) {
    console.error('[ERROR] Failed to update password:', error.message);
    alert('Error updating password: ' + error.message);
    return;
  }

  console.log('[INFO] Password updated:', data);

  // ‚úÖ Redirect the user back to sign in, or show success
  alert('Password updated successfully! Please sign in with your new password.');
  navigateTo('/signup');
}





function setupAutocompleteListeners() {
  const guessInput = document.getElementById('guessInput');
  const submitGuessBtn = document.getElementById('submitGuessBtn');
  
  if (!guessInput || !submitGuessBtn) {
    console.warn('Autocomplete elements not found');
    return;
  }

  guessInput.addEventListener('input', function() {
    const val = this.value.trim();
    clearAutocomplete();
    selectedPlayer = null;
    submitGuessBtn.disabled = true;

    if (!val) {
      showAutocompleteSuggestions([]);
      return;
    }

    if (fetchTimeout) clearTimeout(fetchTimeout);

    fetchTimeout = setTimeout(async () => {
      try {
        const res = await fetch(`/players?q=${encodeURIComponent(val)}`);
        if (!res.ok) throw new Error('Network response not ok');

        const results = await res.json();
        if (results.length === 0) {
          showAutocompleteSuggestions([]);
          return;
        }

        const suggestions = results.map(player => {
          const wrapper = document.createElement('div');
          wrapper.className = 'autocomplete-item';

          const nameSpan = document.createElement('span');
          nameSpan.textContent = player.player_name;

          const yearsSpan = document.createElement('span');
          yearsSpan.className = 'career-years';
          yearsSpan.textContent = ` ${player.first_year || '?'}‚Äì${player.last_year || '?'}`;
          yearsSpan.style.fontSize = '0.8em';
          yearsSpan.style.color = 'gray';
          yearsSpan.style.marginLeft = '5px';

          wrapper.appendChild(nameSpan);
          wrapper.appendChild(yearsSpan);

          wrapper.addEventListener('click', () => {
            guessInput.value = player.player_name;
            selectedPlayer = player.player_name;
            submitGuessBtn.disabled = false;
            clearAutocomplete();
          });

          return wrapper;
        });

        showAutocompleteSuggestions(suggestions);

      } catch (err) {
        console.error('Autocomplete fetch error:', err);
        showAutocompleteSuggestions([]);
      }
    }, 300);
  });

  guessInput.addEventListener('change', () => {
    if (guessInput.value !== selectedPlayer) {
      selectedPlayer = null;
      submitGuessBtn.disabled = true;
    }
  });
}


function initializeAuthStateListener() {
  if (window.supabase && window.supabase.auth) {
    window.supabase.auth.onAuthStateChange((event, session) => {
      updateNavUserState(session);
    });
  }
}


async function loadPlayerStats() {
  const el = document.getElementById('player-history');
  if (!el) return;

  // ‚úÖ Get the current session user
  const { data: sessionData, error: sessionError } = await supabase.auth.getSession();
  if (sessionError || !sessionData?.session?.user) {
    el.textContent = 'Games Played: 0 | Wins: 0 | Losses: 0';
    return;
  }

  const userId = sessionData.session.user.id;

  // ‚úÖ Fetch their stats
  const { data, error } = await supabase
    .from('user_stats')
    .select('games_played, wins, losses')
    .eq('user_id', userId)
    .single();

  console.log('[loadPlayerStats] Fetched data:', data);
  console.log('[loadPlayerStats] Error:', error);

  if (error || !data) {
    console.warn('[loadPlayerStats] No stats row found ‚Äî showing default zeros.');
    el.textContent = 'Games Played: 0 | Wins: 0 | Losses: 0';
  } else {
    el.textContent = `Games Played: ${data.games_played} | Wins: ${data.wins} | Losses: ${data.losses}`;
  }
}




///////////////////////////////////////////////
// 3. Socket handlers (outside DOMContentLoaded)
function setupSocketHandlers() {
socket.on('connect', () => {
  console.log('[safeEmit] Socket connected ‚Äî flushing emitQueue');
  flushEmitQueue();
});


socket.on('disconnect', (reason) => {
  console.log('[DEBUG] Socket disconnected:', reason);
  
  // If this was an intentional sign-out, handle it immediately
  if (isLeavingGame || localStorage.getItem('isLeavingGame') === 'true') {
    // Award win to opponent immediately
    handlePlayerLeaving(socket.roomId, socket.username, 'signed_out');
  } else {
    // For accidental disconnects, give a grace period
    setTimeout(() => {
      if (!socket.connected) {
        handlePlayerLeaving(socket.roomId, socket.username, 'disconnected');
      }
    }, 10000); // 10 second grace period
  }
});


socket.on('playersUpdate', (count) => {
  console.log('[DEBUG] playersUpdate received:', count);

  if (isLeavingGame) {
    console.log('[DEBUG] playersUpdate skipped: isLeavingGame is true');
    return;
  }

  const statusDiv = document.getElementById('statusDiv');
  const rematchBtn = document.getElementById('rematchBtn');

  if (statusDiv) {
    statusDiv.textContent = `Players in room: ${count}`;
  } else {
    console.warn('statusDiv not found in DOM');
  }

  if (rematchBtn) {
    if (count < 2) {
      rematchBtn.style.display = 'none';
      navigateTo('/waiting');
    } else {
      navigateTo('/play');
    }
  } else {
    console.warn('rematchBtn not found in DOM');
  }
});





socket.on('matched', ({ roomId, opponent }) => {
  if (isLeavingGame || localStorage.getItem('isLeavingGame') === 'true') {
    console.log('[DEBUG] Ignoring matched event because isLeavingGame is true');
    return;
  }

  if (gameStarted && !gameOver) return;

  // ‚úÖ Once matched, clear stale flags
  isLeavingGame = false;
  localStorage.removeItem('isLeavingGame');

  myRoomId = roomId;
  opponentName = opponent;

  statusDiv.textContent = `Matched with ${opponent}! Joining game...`;

  navigateTo('/waiting');

  // ‚úÖ Include userId!
  socket.emit('joinGame', { 
    roomId: myRoomId, 
    username: myUsername,
    userId: myUserId   // <-- this part is critical now
  });
});





// 2. Game Lifecycle
socket.on('gameStarted', async (data) => {
  if (isLeavingGame) {
    console.log('[DEBUG] Ignoring gameStarted because isLeavingGame === true');
    return;
  }

  console.log('[CLIENT] Received gameStarted event:', data);

  gameStarted = true;
  gameOver = false;

  const leadoffPlayer = data.leadoffPlayer || null;
  leadoffPlayerName = leadoffPlayer?.player_name || null;

  if (window.timerInterval) {
    clearInterval(window.timerInterval);
    window.timerInterval = null;
    console.warn('[CLIENT] Cleared leftover timer before starting new one.');
  }

  guessInput.disabled = true;
  submitGuessBtn.disabled = true;
  guessInput.value = '';
  clearGuessError();
  clearAutocomplete();

  rematchBtn.style.display = 'none';
  rematchBtn.disabled = false;
  rematchBtn.textContent = 'Rematch';

  messagesEl.innerHTML = '';
  messagesEl.style.display = 'block';

  successfulGuesses = [];
  if (leadoffPlayer && leadoffPlayer.player_name) {
    successfulGuesses.push({
      guesser: 'Leadoff',
      name: leadoffPlayer.player_name,
      isLeadoff: true,
      headshot_url: leadoffPlayer.headshot_url
    });

    // ‚úÖ Show leadoff headshot if you want to ‚Äî or skip if you only want current player
    updateHeadshot(leadoffPlayer);
  }

  console.log('[CLIENT] successfulGuesses after reset:', successfulGuesses);
  renderSuccessfulGuesses();

  // ‚úÖ Update current player name (NBA player)
  currentPlayerNameEl.textContent = data.currentPlayerName || '???';

  // ‚úÖ Update current player headshot
  if (currentPlayerHeadshotEl) {
    currentPlayerHeadshotEl.src = data.currentPlayerHeadshotUrl || '/images/default-player.png';
    currentPlayerHeadshotEl.alt = (data.currentPlayerName || 'Unknown') + ' Headshot';
  }

  // ‚úÖ Update player labels
  const playerYouEl = document.getElementById('playerYou');
  const playerOpponentEl = document.getElementById('playerOpponent');
  if (playerOpponentEl && data.opponentName) {
    playerOpponentEl.textContent = data.opponentName;
    opponentName = data.opponentName;
  }
  if (playerYouEl) playerYouEl.textContent = myUsername || 'You';

  // ‚úÖ Correct: use currentPlayerUsername, not currentPlayerName!
  const isYourTurn = data.currentPlayerUsername === myUsername;

  if (playerYouEl && playerOpponentEl) {
    playerYouEl.classList.toggle('active-turn', isYourTurn);
    playerOpponentEl.classList.toggle('active-turn', !isYourTurn);
  }

  timerEl.textContent = data.timeLeft || 15;
  console.log('[CLIENT] Timer initialized at:', data.timeLeft || 15);

  console.log('[DEBUG] Navigating to /play...');
  await navigateTo('/play');
  console.debug('[DEBUG] Waiting for scoreboard readiness...');
  await waitForScoreboard();
  socket.emit('getMatchStats');
});





socket.on('matchStats', (stats) => {
  console.log('[CLIENT] Updated matchStats:', stats);
  updateSplitScoreboard(stats, myUsername, opponentName);
});



socket.on('gameOver', (data) => {
  console.log('[DEBUG] gameOver received:', data);

  // ‚úÖ If I intentionally left, skip handling
  if (isLeavingGame) {
    console.debug('[DEBUG] Ignoring gameOver because isLeavingGame === true');
    isLeavingGame = false; // reset for next time
    return; // skip all the rest
  }

  gameOver = true;

  // Stop input & timer
  guessInput.disabled = true;
  submitGuessBtn.disabled = true;

  if (window.timerInterval) {
    clearInterval(window.timerInterval);
    window.timerInterval = null;
  }
  timerEl.textContent = '';

  // Ensure myUsername & opponentName
  if (!myUsername && data.winnerName && data.loserName) {
    if (data.role === 'winner') {
      myUsername = data.winnerName;
      opponentName = data.loserName;
    } else {
      myUsername = data.loserName;
      opponentName = data.winnerName;
    }
  } else if (!opponentName && data.winnerName && data.loserName) {
    opponentName = (myUsername === data.winnerName) ? data.loserName : data.winnerName;
  }

  // Show game over container
  const container = document.getElementById('gameOverContainer');
  container.style.display = 'flex';
  container.innerHTML = '';

  const gameOverMsg = document.createElement('div');
  gameOverMsg.style.fontSize = '1.5rem';
  gameOverMsg.style.textAlign = 'center';
  gameOverMsg.style.fontWeight = 'bold';
  gameOverMsg.style.marginTop = '1rem';

  if (data.message) {
    gameOverMsg.textContent = data.message;
  } else if (data.reason === 'opponent_left') {
    const opponent = opponentName || 'Your opponent';
    gameOverMsg.textContent = `${opponent} left the game.`;
  } else {
    gameOverMsg.textContent = 'Game Over!';
  }

  if (data.role === 'winner') {
    gameOverMsg.style.color = 'green';
  } else if (data.role === 'loser') {
    gameOverMsg.style.color = 'darkred';
  } else {
    gameOverMsg.style.color = 'gray';
  }

  container.appendChild(gameOverMsg);

  const resultsDiv = document.getElementById('gameOverResults');
  if (resultsDiv) {
    if (data.winnerName && data.loserName) {
      resultsDiv.innerHTML = `
        <p><strong>Winner:</strong> ${data.winnerName}</p>
        <p><strong>Loser:</strong> ${data.loserName}</p>
      `;
    } else {
      resultsDiv.innerHTML = '';
    }
  }

  if (data.canRematch === false || data.reason === 'opponent_left') {
    rematchBtn.style.display = 'none';
  } else {
    rematchBtn.style.display = 'block';
    rematchBtn.disabled = false;
    rematchBtn.textContent = 'Rematch';
  }

  // Let server 'matchStats' handle scoreboard update
  navigateTo('/gameover');
});




// 3. Turn Management
socket.on('yourTurn', (data) => {
  navigateTo('/play');

  const turnSection = document.getElementById('turnSection');

  turnSection.classList.add('your-turn');
  turnSection.classList.remove('opponent-turn');

  document.getElementById('guessControls').style.display = 'block';
  guessInput.disabled = false;
  submitGuessBtn.disabled = !guessInput.value.trim();

  // ‚úÖ NBA player to guess:
  currentPlayerNameEl.textContent = data.currentPlayerName || 'Your Turn';

  // ‚úÖ Update headshot too:
  if (currentPlayerHeadshotEl) {
    currentPlayerHeadshotEl.src = data.currentPlayerHeadshotUrl || '/images/default-player.png';
    currentPlayerHeadshotEl.alt = `${data.currentPlayerName || 'Player'} Headshot`;
  }

  timerEl.textContent = data.timeLeft || 15;

  turnSection.style.display = 'block';
  messagesEl.style.display = 'block';

  showMessage(data.message || "It's your turn to guess!", 'info');

  const turnPromptEl = document.getElementById('turnPromptText');
  if (turnPromptEl) {
    turnPromptEl.innerHTML = `üéØ Name any teammate of:<br><strong class="turn-player-name">${data.currentPlayerName}</strong>`;
  }

  // ‚úÖ Highlight the current player in playersDisplay
  const playerYouEl = document.getElementById('playerYou');
  const playerOpponentEl = document.getElementById('playerOpponent');

  if (playerYouEl && playerOpponentEl) {
    playerYouEl.classList.add('active-turn');
    playerOpponentEl.classList.remove('active-turn');
  }
});

socket.on('opponentTurn', (data) => {
  navigateTo('/play');

  const turnSection = document.getElementById('turnSection');

  turnSection.classList.remove('your-turn');
  turnSection.classList.add('opponent-turn');

  document.getElementById('guessControls').style.display = 'none';
  guessInput.disabled = true;
  submitGuessBtn.disabled = true;

  // ‚úÖ NBA player to guess:
  currentPlayerNameEl.textContent = data.currentPlayerName || "Opponent's Turn";

  // ‚úÖ Update headshot too:
  if (currentPlayerHeadshotEl) {
    currentPlayerHeadshotEl.src = data.currentPlayerHeadshotUrl || '/images/default-player.png';
    currentPlayerHeadshotEl.alt = `${data.currentPlayerName || 'Player'} Headshot`;
  }

  timerEl.textContent = data.timeLeft || '';

  turnSection.style.display = 'block';
  messagesEl.style.display = 'block';

  showMessage(data.message || "Waiting for your opponent to guess...", 'info');

  const turnPromptEl = document.getElementById('turnPromptText');
  if (turnPromptEl) {
    turnPromptEl.innerHTML = `üïí Waiting for opponent to name a teammate of:<br><strong class="turn-player-name">${data.currentPlayerName}</strong>`;
  }

  // ‚úÖ Highlight the opponent in playersDisplay
  const playerYouEl = document.getElementById('playerYou');
  const playerOpponentEl = document.getElementById('playerOpponent');

  if (playerYouEl && playerOpponentEl) {
    playerYouEl.classList.remove('active-turn');
    playerOpponentEl.classList.add('active-turn');
  }
});





socket.on('message', (msg) => {
  navigateTo('/play'); // Ensure user is on the gameplay page
  showMessage(msg, 'error');
});

socket.on('turnEnded', (data) => {
  console.log('turnEnded currentPlayerHeadshotUrl:', data.currentPlayerHeadshotUrl);
  navigateTo('/play');

  if (Array.isArray(data.successfulGuesses)) {
    successfulGuesses = markLeadoffInGuesses(data.successfulGuesses, leadoffPlayerName);
    renderSuccessfulGuesses();
  }

  if (data.message) {
    showMessage(data.message, data.message.startsWith('Incorrect guess') ? 'error' : 'info');
  }

  // ‚úÖ Save turn state
  currentPlayerName = data.currentPlayerName || '???';
  currentPlayerHeadshotUrl = data.currentPlayerHeadshotUrl || '/images/default-player.png';
  timeLeft = data.timeLeft || 15;

  renderPlayScreen();
});


function renderPlayScreen() {
  if (currentPlayerNameEl) {
    currentPlayerNameEl.textContent = currentPlayerName;
  }
  if (currentPlayerHeadshotEl) {
    currentPlayerHeadshotEl.src = currentPlayerHeadshotUrl;
    currentPlayerHeadshotEl.alt = `${currentPlayerName} Headshot`;
  }
  if (timerEl) {
    timerEl.textContent = timeLeft;
  }
}





socket.on('timerTick', (data) => {
  timerEl.textContent = data.timeLeft;
});





// When another player requests a rematch
socket.on('rematchRequested', ({ username }) => {
  showMessage(`${username} wants a rematch! Click your Rematch button to accept.`, 'info', true);

 
});

// When rematch actually starts
socket.on('rematchStarted', () => {
  resetGameUI();

  // Clear any rematch prompt message
  const rematchInfo = document.getElementById('rematch-info');
  if (rematchInfo) rematchInfo.remove();

  // Reset rematch button styles
  rematchBtn.disabled = false;
  rematchBtn.style.backgroundColor = ''; // Reset highlight
  rematchBtn.textContent = 'Rematch';

  // ‚úÖ Re-join the same room to trigger new game start
  if (myRoomId && myUsername) {
    console.log('[CLIENT] Rejoining room for rematch:', myRoomId);
    socket.emit('joinGame', { roomId: myRoomId, username: myUsername });
    socket.emit('getMatchStats');
  } else {
    console.error('[CLIENT] Missing roomId or username for rematch.');
  }
});

  }




// 4. DOMContentLoaded (minimal, focused)
  document.addEventListener('DOMContentLoaded', async () => {
  console.log('[DEBUG] DOMContentLoaded');

  let justConfirmed = false;

  // Initialize all event listeners
  setupAutocompleteListeners();
  setupFormListeners();
  setupAuthTabs();
  initializeAuthStateListener();
  updateNavUserState();
  setupGlobalNavListeners();

  // Cache DOM element references
  statusDiv = document.getElementById('status');
  guessInput = document.getElementById('guessInput');
  submitGuessBtn = document.getElementById('submitGuessBtn');
  rematchBtn = document.getElementById('rematchBtn');
  messagesEl = document.getElementById('messageContainer');
  currentPlayerNameEl = document.getElementById('currentPlayerName');
  currentPlayerHeadshotEl = document.getElementById('currentPlayerHeadshot');
  timerEl = document.getElementById('timer');
  autocompleteList = document.getElementById('autocomplete-list');
  waitingRoom = document.getElementById('waitingRoom');
  gameArea = document.getElementById('gameArea');
  inviteLinkContainer = document.getElementById('inviteLinkContainer');
  

  supabase.auth.onAuthStateChange((_event, session) => {
    updateNavUserState(session);
  });

  const urlHash = window.location.hash;
  const searchParams = new URLSearchParams(window.location.search);
  const typeParam = searchParams.get('type');

  console.log('[DEBUG] On load: urlHash:', urlHash, 'typeParam:', typeParam);

  if (
    (urlHash.includes('access_token') &&
      (urlHash.includes('type=signup') || urlHash.includes('type=recovery') || urlHash.includes('type=email_confirm')))
    || (typeParam === 'signup' || typeParam === 'recovery' || typeParam === 'email_confirm')
  ) {
    console.log('[DEBUG] Found email confirmation or recovery in URL');
    try {
      const { data: { user }, error } = await supabase.auth.getUser();
      if (error) {
        console.error('[ERROR] Email confirmation failed:', error.message);
      } else {
        console.log('[DEBUG] Email confirmed for:', user?.email);

        myUsername = user.user_metadata?.username || user.email;
        myUserId = user.id;  // ‚úÖ Save userId
        localStorage.setItem('username', myUsername);
        localStorage.setItem('userId', myUserId);

        const { data: { session } } = await supabase.auth.getSession();

        await navigateTo('/confirmed');
        await updateNavUserState(session);
      }
    } catch (e) {
      console.error('[ERROR] Exception during email confirmation:', e);
    }
    if (!socket) {
      socket = io();
      setupSocketHandlers();
    }
    return;
  }

  // --- 2Ô∏è‚É£ Connect socket early ---
  socket = io();
  setupSocketHandlers();

  // --- 3Ô∏è‚É£ Get current Supabase session ---
  const { data } = await supabase.auth.getSession();
  await updateNavUserState(data.session);

  if (data.session?.user) {
    const user = data.session.user;
    myUsername = user.user_metadata?.username || user.email;
    myUserId = user.id;  // ‚úÖ Save userId
    localStorage.setItem('username', myUsername);
    localStorage.setItem('userId', myUserId);
    console.log('[DEBUG] Username set from session:', myUsername);
    console.log('[DEBUG] User ID set from session:', myUserId);
  } else {
    myUsername = localStorage.getItem('username') || null;
    myUserId = localStorage.getItem('userId') || null;  // ‚úÖ Fallback
    console.log('[DEBUG] Username from localStorage:', myUsername);
    console.log('[DEBUG] User ID from localStorage:', myUserId);
  }

  // --- 4Ô∏è‚É£ Load room info ---
  const params = new URLSearchParams(window.location.search);
  const roomFromUrl = params.get('room');
  if (roomFromUrl) {
    console.log('[DEBUG] Found invite link for room:', roomFromUrl);
    myRoomId = roomFromUrl;
    roomId = roomFromUrl;
    isPrivateGame = true;
    localStorage.setItem('privateRoomId', roomFromUrl);
  } else {
    const savedRoom = localStorage.getItem('privateRoomId');
    if (savedRoom) {
      console.log('[DEBUG] Found saved private room:', savedRoom);
      myRoomId = savedRoom;
      roomId = savedRoom;
      isPrivateGame = true;
    }
  }

  console.log('[DEBUG] Final state before routing:', {
    myUsername,
    myUserId,  // ‚úÖ Add to debug
    myRoomId,
    isPrivateGame,
    isLeavingGame,
  });

  window.addEventListener('popstate', () => {
    navigateTo(window.location.pathname, { skipPush: true });
  });

  window.addEventListener('beforeunload', (e) => {
    if (gameStarted && !gameOver && socket && socket.connected) {
      isLeavingGame = true;
      socket.emit('playerSignedOut', {
        roomId: myRoomId || roomId,
        username: myUsername,
        userId: myUserId,  // ‚úÖ Include if helpful
        reason: 'page_closed'
      });
    }
  });

  // --- 5Ô∏è‚É£ Determine initial route ---
  if (!myUsername) {
    navigateTo('/signup');
  } else if (isLeavingGame) {
    console.log('[DEBUG] Routing to /home because isLeavingGame=true');
    navigateTo('/home');
  } else if (myRoomId && !isLeavingGame && localStorage.getItem('isLeavingGame') !== 'true') {
    socket.emit('joinGame', {
      roomId: myRoomId,
      username: myUsername,
      userId: myUserId   // ‚úÖ Always emit userId
    });
    navigateTo('/waiting');
  } else {
    navigateTo('/home');
  }
});

</script>


















</body>
</html>